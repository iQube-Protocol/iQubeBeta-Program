"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@dfinity";
exports.ids = ["vendor-chunks/@dfinity"];
exports.modules = {

/***/ "(ssr)/../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/actor.js":
/*!**************************************************************************!*\
  !*** ../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/actor.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ACTOR_METHOD_WITH_CERTIFICATE: () => (/* binding */ ACTOR_METHOD_WITH_CERTIFICATE),\n/* harmony export */   ACTOR_METHOD_WITH_HTTP_DETAILS: () => (/* binding */ ACTOR_METHOD_WITH_HTTP_DETAILS),\n/* harmony export */   Actor: () => (/* binding */ Actor)\n/* harmony export */ });\n/* harmony import */ var _agent_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./agent/index.js */ \"(ssr)/../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/agent/api.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./errors.js */ \"(ssr)/../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/errors.js\");\n/* harmony import */ var _dfinity_candid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @dfinity/candid */ \"(ssr)/../../packages/sdk-js/node_modules/@dfinity/candid/lib/esm/idl.js\");\n/* harmony import */ var _polling_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./polling/index.js */ \"(ssr)/../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/polling/index.js\");\n/* harmony import */ var _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @dfinity/principal */ \"(ssr)/../../packages/sdk-js/node_modules/@dfinity/principal/lib/esm/principal.js\");\n/* harmony import */ var _certificate_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./certificate.js */ \"(ssr)/../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/certificate.js\");\n/* harmony import */ var _agent_http_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./agent/http/index.js */ \"(ssr)/../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/agent/http/index.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @noble/hashes/utils */ \"(ssr)/../../packages/sdk-js/node_modules/@noble/hashes/esm/utils.js\");\n\n\n\n\n\n\n\n\nconst metadataSymbol = Symbol.for('ic-agent-metadata');\n/**\n * An actor base class. An actor is an object containing only functions that will\n * return a promise. These functions are derived from the IDL definition.\n */\nclass Actor {\n    /**\n     * Get the Agent class this Actor would call, or undefined if the Actor would use\n     * the default agent (global.ic.agent).\n     * @param actor The actor to get the agent of.\n     */\n    static agentOf(actor) {\n        return actor[metadataSymbol].config.agent;\n    }\n    /**\n     * Get the interface of an actor, in the form of an instance of a Service.\n     * @param actor The actor to get the interface of.\n     */\n    static interfaceOf(actor) {\n        return actor[metadataSymbol].service;\n    }\n    static canisterIdOf(actor) {\n        return _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.from(actor[metadataSymbol].config.canisterId);\n    }\n    static createActorClass(interfaceFactory, options) {\n        const service = interfaceFactory({ IDL: _dfinity_candid__WEBPACK_IMPORTED_MODULE_1__ });\n        class CanisterActor extends Actor {\n            constructor(config) {\n                if (!config.canisterId) {\n                    throw _errors_js__WEBPACK_IMPORTED_MODULE_2__.InputError.fromCode(new _errors_js__WEBPACK_IMPORTED_MODULE_2__.MissingCanisterIdErrorCode(config.canisterId));\n                }\n                const canisterId = typeof config.canisterId === 'string'\n                    ? _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.fromText(config.canisterId)\n                    : config.canisterId;\n                super({\n                    config: {\n                        ...DEFAULT_ACTOR_CONFIG,\n                        ...config,\n                        canisterId,\n                    },\n                    service,\n                });\n                for (const [methodName, func] of service._fields) {\n                    if (options?.httpDetails) {\n                        func.annotations.push(ACTOR_METHOD_WITH_HTTP_DETAILS);\n                    }\n                    if (options?.certificate) {\n                        func.annotations.push(ACTOR_METHOD_WITH_CERTIFICATE);\n                    }\n                    this[methodName] = _createActorMethod(this, methodName, func, config.blsVerify);\n                }\n            }\n        }\n        return CanisterActor;\n    }\n    static createActor(interfaceFactory, configuration) {\n        if (!configuration.canisterId) {\n            throw _errors_js__WEBPACK_IMPORTED_MODULE_2__.InputError.fromCode(new _errors_js__WEBPACK_IMPORTED_MODULE_2__.MissingCanisterIdErrorCode(configuration.canisterId));\n        }\n        return new (this.createActorClass(interfaceFactory))(configuration);\n    }\n    /**\n     * Returns an actor with methods that return the http response details along with the result\n     * @param interfaceFactory - the interface factory for the actor\n     * @param configuration - the configuration for the actor\n     * @deprecated - use createActor with actorClassOptions instead\n     */\n    static createActorWithHttpDetails(interfaceFactory, configuration) {\n        return new (this.createActorClass(interfaceFactory, { httpDetails: true }))(configuration);\n    }\n    /**\n     * Returns an actor with methods that return the http response details along with the result\n     * @param interfaceFactory - the interface factory for the actor\n     * @param configuration - the configuration for the actor\n     * @param actorClassOptions - options for the actor class extended details to return with the result\n     */\n    static createActorWithExtendedDetails(interfaceFactory, configuration, actorClassOptions = {\n        httpDetails: true,\n        certificate: true,\n    }) {\n        return new (this.createActorClass(interfaceFactory, actorClassOptions))(configuration);\n    }\n    constructor(metadata) {\n        this[metadataSymbol] = Object.freeze(metadata);\n    }\n}\n// IDL functions can have multiple return values, so decoding always\n// produces an array. Ensure that functions with single or zero return\n// values behave as expected.\nfunction decodeReturnValue(types, msg) {\n    const returnValues = _dfinity_candid__WEBPACK_IMPORTED_MODULE_1__.decode(types, msg);\n    switch (returnValues.length) {\n        case 0:\n            return undefined;\n        case 1:\n            return returnValues[0];\n        default:\n            return returnValues;\n    }\n}\nconst DEFAULT_ACTOR_CONFIG = {\n    pollingOptions: _polling_index_js__WEBPACK_IMPORTED_MODULE_3__.DEFAULT_POLLING_OPTIONS,\n};\nconst ACTOR_METHOD_WITH_HTTP_DETAILS = 'http-details';\nconst ACTOR_METHOD_WITH_CERTIFICATE = 'certificate';\nfunction _createActorMethod(actor, methodName, func, blsVerify) {\n    let caller;\n    if (func.annotations.includes('query') || func.annotations.includes('composite_query')) {\n        caller = async (options, ...args) => {\n            // First, if there's a config transformation, call it.\n            options = {\n                ...options,\n                ...actor[metadataSymbol].config.queryTransform?.(methodName, args, {\n                    ...actor[metadataSymbol].config,\n                    ...options,\n                }),\n            };\n            const agent = options.agent || actor[metadataSymbol].config.agent || new _agent_http_index_js__WEBPACK_IMPORTED_MODULE_4__.HttpAgent();\n            const cid = _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.from(options.canisterId || actor[metadataSymbol].config.canisterId);\n            const arg = _dfinity_candid__WEBPACK_IMPORTED_MODULE_1__.encode(func.argTypes, args);\n            const result = await agent.query(cid, {\n                methodName,\n                arg,\n                effectiveCanisterId: options.effectiveCanisterId,\n            });\n            const httpDetails = {\n                ...result.httpDetails,\n                requestDetails: result.requestDetails,\n            };\n            switch (result.status) {\n                case _agent_index_js__WEBPACK_IMPORTED_MODULE_5__.QueryResponseStatus.Rejected: {\n                    const uncertifiedRejectErrorCode = new _errors_js__WEBPACK_IMPORTED_MODULE_2__.UncertifiedRejectErrorCode(result.requestId, result.reject_code, result.reject_message, result.error_code, result.signatures);\n                    uncertifiedRejectErrorCode.callContext = {\n                        canisterId: cid,\n                        methodName,\n                        httpDetails,\n                    };\n                    throw _errors_js__WEBPACK_IMPORTED_MODULE_2__.RejectError.fromCode(uncertifiedRejectErrorCode);\n                }\n                case _agent_index_js__WEBPACK_IMPORTED_MODULE_5__.QueryResponseStatus.Replied:\n                    return func.annotations.includes(ACTOR_METHOD_WITH_HTTP_DETAILS)\n                        ? {\n                            httpDetails,\n                            result: decodeReturnValue(func.retTypes, result.reply.arg),\n                        }\n                        : decodeReturnValue(func.retTypes, result.reply.arg);\n            }\n        };\n    }\n    else {\n        caller = async (options, ...args) => {\n            // First, if there's a config transformation, call it.\n            options = {\n                ...options,\n                ...actor[metadataSymbol].config.callTransform?.(methodName, args, {\n                    ...actor[metadataSymbol].config,\n                    ...options,\n                }),\n            };\n            const agent = options.agent || actor[metadataSymbol].config.agent || _agent_http_index_js__WEBPACK_IMPORTED_MODULE_4__.HttpAgent.createSync();\n            const { canisterId, effectiveCanisterId, pollingOptions } = {\n                ...DEFAULT_ACTOR_CONFIG,\n                ...actor[metadataSymbol].config,\n                ...options,\n            };\n            const cid = _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.from(canisterId);\n            const ecid = effectiveCanisterId !== undefined ? _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.from(effectiveCanisterId) : cid;\n            const arg = _dfinity_candid__WEBPACK_IMPORTED_MODULE_1__.encode(func.argTypes, args);\n            const { requestId, response, requestDetails } = await agent.call(cid, {\n                methodName,\n                arg,\n                effectiveCanisterId: ecid,\n                nonce: options.nonce,\n            });\n            let reply;\n            let certificate;\n            if ((0,_agent_index_js__WEBPACK_IMPORTED_MODULE_5__.isV3ResponseBody)(response.body)) {\n                if (agent.rootKey == null) {\n                    throw _errors_js__WEBPACK_IMPORTED_MODULE_2__.ExternalError.fromCode(new _errors_js__WEBPACK_IMPORTED_MODULE_2__.MissingRootKeyErrorCode());\n                }\n                const cert = response.body.certificate;\n                certificate = await _certificate_js__WEBPACK_IMPORTED_MODULE_6__.Certificate.create({\n                    certificate: cert,\n                    rootKey: agent.rootKey,\n                    canisterId: ecid,\n                    blsVerify,\n                    agent,\n                });\n                const path = [(0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_7__.utf8ToBytes)('request_status'), requestId];\n                const status = new TextDecoder().decode((0,_certificate_js__WEBPACK_IMPORTED_MODULE_6__.lookupResultToBuffer)(certificate.lookup_path([...path, 'status'])));\n                switch (status) {\n                    case 'replied':\n                        reply = (0,_certificate_js__WEBPACK_IMPORTED_MODULE_6__.lookupResultToBuffer)(certificate.lookup_path([...path, 'reply']));\n                        break;\n                    case 'rejected': {\n                        // Find rejection details in the certificate\n                        const rejectCode = new Uint8Array((0,_certificate_js__WEBPACK_IMPORTED_MODULE_6__.lookupResultToBuffer)(certificate.lookup_path([...path, 'reject_code'])))[0];\n                        const rejectMessage = new TextDecoder().decode((0,_certificate_js__WEBPACK_IMPORTED_MODULE_6__.lookupResultToBuffer)(certificate.lookup_path([...path, 'reject_message'])));\n                        const error_code_buf = (0,_certificate_js__WEBPACK_IMPORTED_MODULE_6__.lookupResultToBuffer)(certificate.lookup_path([...path, 'error_code']));\n                        const error_code = error_code_buf\n                            ? new TextDecoder().decode(error_code_buf)\n                            : undefined;\n                        const certifiedRejectErrorCode = new _errors_js__WEBPACK_IMPORTED_MODULE_2__.CertifiedRejectErrorCode(requestId, rejectCode, rejectMessage, error_code);\n                        certifiedRejectErrorCode.callContext = {\n                            canisterId: cid,\n                            methodName,\n                            httpDetails: response,\n                        };\n                        throw _errors_js__WEBPACK_IMPORTED_MODULE_2__.RejectError.fromCode(certifiedRejectErrorCode);\n                    }\n                }\n            }\n            else if ((0,_agent_index_js__WEBPACK_IMPORTED_MODULE_5__.isV2ResponseBody)(response.body)) {\n                const { reject_code, reject_message, error_code } = response.body;\n                const errorCode = new _errors_js__WEBPACK_IMPORTED_MODULE_2__.UncertifiedRejectUpdateErrorCode(requestId, reject_code, reject_message, error_code);\n                errorCode.callContext = {\n                    canisterId: cid,\n                    methodName,\n                    httpDetails: response,\n                };\n                throw _errors_js__WEBPACK_IMPORTED_MODULE_2__.RejectError.fromCode(errorCode);\n            }\n            // Fall back to polling if we receive an Accepted response code\n            if (response.status === 202) {\n                const pollOptions = {\n                    ...pollingOptions,\n                    blsVerify,\n                };\n                // Contains the certificate and the reply from the boundary node\n                const response = await (0,_polling_index_js__WEBPACK_IMPORTED_MODULE_3__.pollForResponse)(agent, ecid, requestId, pollOptions);\n                certificate = response.certificate;\n                reply = response.reply;\n            }\n            const shouldIncludeHttpDetails = func.annotations.includes(ACTOR_METHOD_WITH_HTTP_DETAILS);\n            const shouldIncludeCertificate = func.annotations.includes(ACTOR_METHOD_WITH_CERTIFICATE);\n            const httpDetails = { ...response, requestDetails };\n            if (reply !== undefined) {\n                if (shouldIncludeHttpDetails && shouldIncludeCertificate) {\n                    return {\n                        httpDetails,\n                        certificate,\n                        result: decodeReturnValue(func.retTypes, reply),\n                    };\n                }\n                else if (shouldIncludeCertificate) {\n                    return {\n                        certificate,\n                        result: decodeReturnValue(func.retTypes, reply),\n                    };\n                }\n                else if (shouldIncludeHttpDetails) {\n                    return {\n                        httpDetails,\n                        result: decodeReturnValue(func.retTypes, reply),\n                    };\n                }\n                return decodeReturnValue(func.retTypes, reply);\n            }\n            else {\n                const errorCode = new _errors_js__WEBPACK_IMPORTED_MODULE_2__.UnexpectedErrorCode(`Call was returned undefined. We cannot determine if the call was successful or not. Return types: [${func.retTypes.map(t => t.display()).join(',')}].`);\n                errorCode.callContext = {\n                    canisterId: cid,\n                    methodName,\n                    httpDetails,\n                };\n                throw _errors_js__WEBPACK_IMPORTED_MODULE_2__.UnknownError.fromCode(errorCode);\n            }\n        };\n    }\n    const handler = (...args) => caller({}, ...args);\n    handler.withOptions =\n        (options) => (...args) => caller(options, ...args);\n    return handler;\n}\n//# sourceMappingURL=actor.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vcGFja2FnZXMvc2RrLWpzL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL2FjdG9yLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQTRGO0FBQzBKO0FBQ2hOO0FBQ3dDO0FBQy9CO0FBQ3NCO0FBQ25CO0FBQ0E7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHlEQUFTO0FBQ3hCO0FBQ0E7QUFDQSwyQ0FBMkMsR0FBRyxnREFBRTtBQUNoRDtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsa0RBQVUsY0FBYyxrRUFBMEI7QUFDNUU7QUFDQTtBQUNBLHNCQUFzQix5REFBUztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtEQUFVLGNBQWMsa0VBQTBCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELG1CQUFtQjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixtREFBVTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzRUFBdUI7QUFDM0M7QUFDTztBQUNBO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxxRkFBcUYsMkRBQVM7QUFDOUYsd0JBQXdCLHlEQUFTO0FBQ2pDLHdCQUF3QixtREFBVTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGdFQUFtQjtBQUN4QywyREFBMkQsa0VBQTBCO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsbURBQVc7QUFDckM7QUFDQSxxQkFBcUIsZ0VBQW1CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxpRkFBaUYsMkRBQVM7QUFDMUYsb0JBQW9CLGtEQUFrRDtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix5REFBUztBQUNqQyw2REFBNkQseURBQVM7QUFDdEUsd0JBQXdCLG1EQUFVO0FBQ2xDLG9CQUFvQixzQ0FBc0M7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGdCQUFnQixpRUFBZ0I7QUFDaEM7QUFDQSwwQkFBMEIscURBQWEsY0FBYywrREFBdUI7QUFDNUU7QUFDQTtBQUNBLG9DQUFvQyx3REFBVztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLDhCQUE4QixnRUFBVztBQUN6Qyx3REFBd0QscUVBQW9CO0FBQzVFO0FBQ0E7QUFDQSxnQ0FBZ0MscUVBQW9CO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxxRUFBb0I7QUFDOUUsdUVBQXVFLHFFQUFvQjtBQUMzRiwrQ0FBK0MscUVBQW9CO0FBQ25FO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxnRUFBd0I7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixtREFBVztBQUN6QztBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsaUVBQWdCO0FBQ3JDLHdCQUF3QiwwQ0FBMEM7QUFDbEUsc0NBQXNDLHdFQUFnQztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG1EQUFXO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsa0VBQWU7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLDJEQUFtQix1R0FBdUcsOENBQThDO0FBQzlNO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isb0RBQVk7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AaXF1YmUvb3BzLWNvbnNvbGUvLi4vLi4vcGFja2FnZXMvc2RrLWpzL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL2FjdG9yLmpzPzI3NTciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaXNWMlJlc3BvbnNlQm9keSwgaXNWM1Jlc3BvbnNlQm9keSwgUXVlcnlSZXNwb25zZVN0YXR1cywgfSBmcm9tIFwiLi9hZ2VudC9pbmRleC5qc1wiO1xuaW1wb3J0IHsgQ2VydGlmaWVkUmVqZWN0RXJyb3JDb2RlLCBFeHRlcm5hbEVycm9yLCBJbnB1dEVycm9yLCBNaXNzaW5nQ2FuaXN0ZXJJZEVycm9yQ29kZSwgTWlzc2luZ1Jvb3RLZXlFcnJvckNvZGUsIFJlamVjdEVycm9yLCBVbmNlcnRpZmllZFJlamVjdEVycm9yQ29kZSwgVW5jZXJ0aWZpZWRSZWplY3RVcGRhdGVFcnJvckNvZGUsIFVuZXhwZWN0ZWRFcnJvckNvZGUsIFVua25vd25FcnJvciwgfSBmcm9tIFwiLi9lcnJvcnMuanNcIjtcbmltcG9ydCB7IElETCB9IGZyb20gJ0BkZmluaXR5L2NhbmRpZCc7XG5pbXBvcnQgeyBwb2xsRm9yUmVzcG9uc2UsIERFRkFVTFRfUE9MTElOR19PUFRJT05TIH0gZnJvbSBcIi4vcG9sbGluZy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgUHJpbmNpcGFsIH0gZnJvbSAnQGRmaW5pdHkvcHJpbmNpcGFsJztcbmltcG9ydCB7IENlcnRpZmljYXRlLCBsb29rdXBSZXN1bHRUb0J1ZmZlciB9IGZyb20gXCIuL2NlcnRpZmljYXRlLmpzXCI7XG5pbXBvcnQgeyBIdHRwQWdlbnQgfSBmcm9tIFwiLi9hZ2VudC9odHRwL2luZGV4LmpzXCI7XG5pbXBvcnQgeyB1dGY4VG9CeXRlcyB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvdXRpbHMnO1xuY29uc3QgbWV0YWRhdGFTeW1ib2wgPSBTeW1ib2wuZm9yKCdpYy1hZ2VudC1tZXRhZGF0YScpO1xuLyoqXG4gKiBBbiBhY3RvciBiYXNlIGNsYXNzLiBBbiBhY3RvciBpcyBhbiBvYmplY3QgY29udGFpbmluZyBvbmx5IGZ1bmN0aW9ucyB0aGF0IHdpbGxcbiAqIHJldHVybiBhIHByb21pc2UuIFRoZXNlIGZ1bmN0aW9ucyBhcmUgZGVyaXZlZCBmcm9tIHRoZSBJREwgZGVmaW5pdGlvbi5cbiAqL1xuZXhwb3J0IGNsYXNzIEFjdG9yIHtcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIEFnZW50IGNsYXNzIHRoaXMgQWN0b3Igd291bGQgY2FsbCwgb3IgdW5kZWZpbmVkIGlmIHRoZSBBY3RvciB3b3VsZCB1c2VcbiAgICAgKiB0aGUgZGVmYXVsdCBhZ2VudCAoZ2xvYmFsLmljLmFnZW50KS5cbiAgICAgKiBAcGFyYW0gYWN0b3IgVGhlIGFjdG9yIHRvIGdldCB0aGUgYWdlbnQgb2YuXG4gICAgICovXG4gICAgc3RhdGljIGFnZW50T2YoYWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIGFjdG9yW21ldGFkYXRhU3ltYm9sXS5jb25maWcuYWdlbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgaW50ZXJmYWNlIG9mIGFuIGFjdG9yLCBpbiB0aGUgZm9ybSBvZiBhbiBpbnN0YW5jZSBvZiBhIFNlcnZpY2UuXG4gICAgICogQHBhcmFtIGFjdG9yIFRoZSBhY3RvciB0byBnZXQgdGhlIGludGVyZmFjZSBvZi5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50ZXJmYWNlT2YoYWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIGFjdG9yW21ldGFkYXRhU3ltYm9sXS5zZXJ2aWNlO1xuICAgIH1cbiAgICBzdGF0aWMgY2FuaXN0ZXJJZE9mKGFjdG9yKSB7XG4gICAgICAgIHJldHVybiBQcmluY2lwYWwuZnJvbShhY3RvclttZXRhZGF0YVN5bWJvbF0uY29uZmlnLmNhbmlzdGVySWQpO1xuICAgIH1cbiAgICBzdGF0aWMgY3JlYXRlQWN0b3JDbGFzcyhpbnRlcmZhY2VGYWN0b3J5LCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHNlcnZpY2UgPSBpbnRlcmZhY2VGYWN0b3J5KHsgSURMIH0pO1xuICAgICAgICBjbGFzcyBDYW5pc3RlckFjdG9yIGV4dGVuZHMgQWN0b3Ige1xuICAgICAgICAgICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjb25maWcuY2FuaXN0ZXJJZCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBJbnB1dEVycm9yLmZyb21Db2RlKG5ldyBNaXNzaW5nQ2FuaXN0ZXJJZEVycm9yQ29kZShjb25maWcuY2FuaXN0ZXJJZCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBjYW5pc3RlcklkID0gdHlwZW9mIGNvbmZpZy5jYW5pc3RlcklkID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgICAgICAgICA/IFByaW5jaXBhbC5mcm9tVGV4dChjb25maWcuY2FuaXN0ZXJJZClcbiAgICAgICAgICAgICAgICAgICAgOiBjb25maWcuY2FuaXN0ZXJJZDtcbiAgICAgICAgICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4uREVGQVVMVF9BQ1RPUl9DT05GSUcsXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5jb25maWcsXG4gICAgICAgICAgICAgICAgICAgICAgICBjYW5pc3RlcklkLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBzZXJ2aWNlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgW21ldGhvZE5hbWUsIGZ1bmNdIG9mIHNlcnZpY2UuX2ZpZWxkcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucz8uaHR0cERldGFpbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmMuYW5ub3RhdGlvbnMucHVzaChBQ1RPUl9NRVRIT0RfV0lUSF9IVFRQX0RFVEFJTFMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zPy5jZXJ0aWZpY2F0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnVuYy5hbm5vdGF0aW9ucy5wdXNoKEFDVE9SX01FVEhPRF9XSVRIX0NFUlRJRklDQVRFKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzW21ldGhvZE5hbWVdID0gX2NyZWF0ZUFjdG9yTWV0aG9kKHRoaXMsIG1ldGhvZE5hbWUsIGZ1bmMsIGNvbmZpZy5ibHNWZXJpZnkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQ2FuaXN0ZXJBY3RvcjtcbiAgICB9XG4gICAgc3RhdGljIGNyZWF0ZUFjdG9yKGludGVyZmFjZUZhY3RvcnksIGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgaWYgKCFjb25maWd1cmF0aW9uLmNhbmlzdGVySWQpIHtcbiAgICAgICAgICAgIHRocm93IElucHV0RXJyb3IuZnJvbUNvZGUobmV3IE1pc3NpbmdDYW5pc3RlcklkRXJyb3JDb2RlKGNvbmZpZ3VyYXRpb24uY2FuaXN0ZXJJZCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgKHRoaXMuY3JlYXRlQWN0b3JDbGFzcyhpbnRlcmZhY2VGYWN0b3J5KSkoY29uZmlndXJhdGlvbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gYWN0b3Igd2l0aCBtZXRob2RzIHRoYXQgcmV0dXJuIHRoZSBodHRwIHJlc3BvbnNlIGRldGFpbHMgYWxvbmcgd2l0aCB0aGUgcmVzdWx0XG4gICAgICogQHBhcmFtIGludGVyZmFjZUZhY3RvcnkgLSB0aGUgaW50ZXJmYWNlIGZhY3RvcnkgZm9yIHRoZSBhY3RvclxuICAgICAqIEBwYXJhbSBjb25maWd1cmF0aW9uIC0gdGhlIGNvbmZpZ3VyYXRpb24gZm9yIHRoZSBhY3RvclxuICAgICAqIEBkZXByZWNhdGVkIC0gdXNlIGNyZWF0ZUFjdG9yIHdpdGggYWN0b3JDbGFzc09wdGlvbnMgaW5zdGVhZFxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVBY3RvcldpdGhIdHRwRGV0YWlscyhpbnRlcmZhY2VGYWN0b3J5LCBjb25maWd1cmF0aW9uKSB7XG4gICAgICAgIHJldHVybiBuZXcgKHRoaXMuY3JlYXRlQWN0b3JDbGFzcyhpbnRlcmZhY2VGYWN0b3J5LCB7IGh0dHBEZXRhaWxzOiB0cnVlIH0pKShjb25maWd1cmF0aW9uKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBhY3RvciB3aXRoIG1ldGhvZHMgdGhhdCByZXR1cm4gdGhlIGh0dHAgcmVzcG9uc2UgZGV0YWlscyBhbG9uZyB3aXRoIHRoZSByZXN1bHRcbiAgICAgKiBAcGFyYW0gaW50ZXJmYWNlRmFjdG9yeSAtIHRoZSBpbnRlcmZhY2UgZmFjdG9yeSBmb3IgdGhlIGFjdG9yXG4gICAgICogQHBhcmFtIGNvbmZpZ3VyYXRpb24gLSB0aGUgY29uZmlndXJhdGlvbiBmb3IgdGhlIGFjdG9yXG4gICAgICogQHBhcmFtIGFjdG9yQ2xhc3NPcHRpb25zIC0gb3B0aW9ucyBmb3IgdGhlIGFjdG9yIGNsYXNzIGV4dGVuZGVkIGRldGFpbHMgdG8gcmV0dXJuIHdpdGggdGhlIHJlc3VsdFxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVBY3RvcldpdGhFeHRlbmRlZERldGFpbHMoaW50ZXJmYWNlRmFjdG9yeSwgY29uZmlndXJhdGlvbiwgYWN0b3JDbGFzc09wdGlvbnMgPSB7XG4gICAgICAgIGh0dHBEZXRhaWxzOiB0cnVlLFxuICAgICAgICBjZXJ0aWZpY2F0ZTogdHJ1ZSxcbiAgICB9KSB7XG4gICAgICAgIHJldHVybiBuZXcgKHRoaXMuY3JlYXRlQWN0b3JDbGFzcyhpbnRlcmZhY2VGYWN0b3J5LCBhY3RvckNsYXNzT3B0aW9ucykpKGNvbmZpZ3VyYXRpb24pO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihtZXRhZGF0YSkge1xuICAgICAgICB0aGlzW21ldGFkYXRhU3ltYm9sXSA9IE9iamVjdC5mcmVlemUobWV0YWRhdGEpO1xuICAgIH1cbn1cbi8vIElETCBmdW5jdGlvbnMgY2FuIGhhdmUgbXVsdGlwbGUgcmV0dXJuIHZhbHVlcywgc28gZGVjb2RpbmcgYWx3YXlzXG4vLyBwcm9kdWNlcyBhbiBhcnJheS4gRW5zdXJlIHRoYXQgZnVuY3Rpb25zIHdpdGggc2luZ2xlIG9yIHplcm8gcmV0dXJuXG4vLyB2YWx1ZXMgYmVoYXZlIGFzIGV4cGVjdGVkLlxuZnVuY3Rpb24gZGVjb2RlUmV0dXJuVmFsdWUodHlwZXMsIG1zZykge1xuICAgIGNvbnN0IHJldHVyblZhbHVlcyA9IElETC5kZWNvZGUodHlwZXMsIG1zZyk7XG4gICAgc3dpdGNoIChyZXR1cm5WYWx1ZXMubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHJldHVybiByZXR1cm5WYWx1ZXNbMF07XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWVzO1xuICAgIH1cbn1cbmNvbnN0IERFRkFVTFRfQUNUT1JfQ09ORklHID0ge1xuICAgIHBvbGxpbmdPcHRpb25zOiBERUZBVUxUX1BPTExJTkdfT1BUSU9OUyxcbn07XG5leHBvcnQgY29uc3QgQUNUT1JfTUVUSE9EX1dJVEhfSFRUUF9ERVRBSUxTID0gJ2h0dHAtZGV0YWlscyc7XG5leHBvcnQgY29uc3QgQUNUT1JfTUVUSE9EX1dJVEhfQ0VSVElGSUNBVEUgPSAnY2VydGlmaWNhdGUnO1xuZnVuY3Rpb24gX2NyZWF0ZUFjdG9yTWV0aG9kKGFjdG9yLCBtZXRob2ROYW1lLCBmdW5jLCBibHNWZXJpZnkpIHtcbiAgICBsZXQgY2FsbGVyO1xuICAgIGlmIChmdW5jLmFubm90YXRpb25zLmluY2x1ZGVzKCdxdWVyeScpIHx8IGZ1bmMuYW5ub3RhdGlvbnMuaW5jbHVkZXMoJ2NvbXBvc2l0ZV9xdWVyeScpKSB7XG4gICAgICAgIGNhbGxlciA9IGFzeW5jIChvcHRpb25zLCAuLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICAvLyBGaXJzdCwgaWYgdGhlcmUncyBhIGNvbmZpZyB0cmFuc2Zvcm1hdGlvbiwgY2FsbCBpdC5cbiAgICAgICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgICAgICAuLi5hY3RvclttZXRhZGF0YVN5bWJvbF0uY29uZmlnLnF1ZXJ5VHJhbnNmb3JtPy4obWV0aG9kTmFtZSwgYXJncywge1xuICAgICAgICAgICAgICAgICAgICAuLi5hY3RvclttZXRhZGF0YVN5bWJvbF0uY29uZmlnLFxuICAgICAgICAgICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IGFnZW50ID0gb3B0aW9ucy5hZ2VudCB8fCBhY3RvclttZXRhZGF0YVN5bWJvbF0uY29uZmlnLmFnZW50IHx8IG5ldyBIdHRwQWdlbnQoKTtcbiAgICAgICAgICAgIGNvbnN0IGNpZCA9IFByaW5jaXBhbC5mcm9tKG9wdGlvbnMuY2FuaXN0ZXJJZCB8fCBhY3RvclttZXRhZGF0YVN5bWJvbF0uY29uZmlnLmNhbmlzdGVySWQpO1xuICAgICAgICAgICAgY29uc3QgYXJnID0gSURMLmVuY29kZShmdW5jLmFyZ1R5cGVzLCBhcmdzKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGFnZW50LnF1ZXJ5KGNpZCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZE5hbWUsXG4gICAgICAgICAgICAgICAgYXJnLFxuICAgICAgICAgICAgICAgIGVmZmVjdGl2ZUNhbmlzdGVySWQ6IG9wdGlvbnMuZWZmZWN0aXZlQ2FuaXN0ZXJJZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgaHR0cERldGFpbHMgPSB7XG4gICAgICAgICAgICAgICAgLi4ucmVzdWx0Lmh0dHBEZXRhaWxzLFxuICAgICAgICAgICAgICAgIHJlcXVlc3REZXRhaWxzOiByZXN1bHQucmVxdWVzdERldGFpbHMsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgc3dpdGNoIChyZXN1bHQuc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBRdWVyeVJlc3BvbnNlU3RhdHVzLlJlamVjdGVkOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHVuY2VydGlmaWVkUmVqZWN0RXJyb3JDb2RlID0gbmV3IFVuY2VydGlmaWVkUmVqZWN0RXJyb3JDb2RlKHJlc3VsdC5yZXF1ZXN0SWQsIHJlc3VsdC5yZWplY3RfY29kZSwgcmVzdWx0LnJlamVjdF9tZXNzYWdlLCByZXN1bHQuZXJyb3JfY29kZSwgcmVzdWx0LnNpZ25hdHVyZXMpO1xuICAgICAgICAgICAgICAgICAgICB1bmNlcnRpZmllZFJlamVjdEVycm9yQ29kZS5jYWxsQ29udGV4dCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbmlzdGVySWQ6IGNpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZE5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBodHRwRGV0YWlscyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgUmVqZWN0RXJyb3IuZnJvbUNvZGUodW5jZXJ0aWZpZWRSZWplY3RFcnJvckNvZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFF1ZXJ5UmVzcG9uc2VTdGF0dXMuUmVwbGllZDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmMuYW5ub3RhdGlvbnMuaW5jbHVkZXMoQUNUT1JfTUVUSE9EX1dJVEhfSFRUUF9ERVRBSUxTKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHR0cERldGFpbHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiBkZWNvZGVSZXR1cm5WYWx1ZShmdW5jLnJldFR5cGVzLCByZXN1bHQucmVwbHkuYXJnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIDogZGVjb2RlUmV0dXJuVmFsdWUoZnVuYy5yZXRUeXBlcywgcmVzdWx0LnJlcGx5LmFyZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjYWxsZXIgPSBhc3luYyAob3B0aW9ucywgLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgLy8gRmlyc3QsIGlmIHRoZXJlJ3MgYSBjb25maWcgdHJhbnNmb3JtYXRpb24sIGNhbGwgaXQuXG4gICAgICAgICAgICBvcHRpb25zID0ge1xuICAgICAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgLi4uYWN0b3JbbWV0YWRhdGFTeW1ib2xdLmNvbmZpZy5jYWxsVHJhbnNmb3JtPy4obWV0aG9kTmFtZSwgYXJncywge1xuICAgICAgICAgICAgICAgICAgICAuLi5hY3RvclttZXRhZGF0YVN5bWJvbF0uY29uZmlnLFxuICAgICAgICAgICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IGFnZW50ID0gb3B0aW9ucy5hZ2VudCB8fCBhY3RvclttZXRhZGF0YVN5bWJvbF0uY29uZmlnLmFnZW50IHx8IEh0dHBBZ2VudC5jcmVhdGVTeW5jKCk7XG4gICAgICAgICAgICBjb25zdCB7IGNhbmlzdGVySWQsIGVmZmVjdGl2ZUNhbmlzdGVySWQsIHBvbGxpbmdPcHRpb25zIH0gPSB7XG4gICAgICAgICAgICAgICAgLi4uREVGQVVMVF9BQ1RPUl9DT05GSUcsXG4gICAgICAgICAgICAgICAgLi4uYWN0b3JbbWV0YWRhdGFTeW1ib2xdLmNvbmZpZyxcbiAgICAgICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IGNpZCA9IFByaW5jaXBhbC5mcm9tKGNhbmlzdGVySWQpO1xuICAgICAgICAgICAgY29uc3QgZWNpZCA9IGVmZmVjdGl2ZUNhbmlzdGVySWQgIT09IHVuZGVmaW5lZCA/IFByaW5jaXBhbC5mcm9tKGVmZmVjdGl2ZUNhbmlzdGVySWQpIDogY2lkO1xuICAgICAgICAgICAgY29uc3QgYXJnID0gSURMLmVuY29kZShmdW5jLmFyZ1R5cGVzLCBhcmdzKTtcbiAgICAgICAgICAgIGNvbnN0IHsgcmVxdWVzdElkLCByZXNwb25zZSwgcmVxdWVzdERldGFpbHMgfSA9IGF3YWl0IGFnZW50LmNhbGwoY2lkLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kTmFtZSxcbiAgICAgICAgICAgICAgICBhcmcsXG4gICAgICAgICAgICAgICAgZWZmZWN0aXZlQ2FuaXN0ZXJJZDogZWNpZCxcbiAgICAgICAgICAgICAgICBub25jZTogb3B0aW9ucy5ub25jZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGV0IHJlcGx5O1xuICAgICAgICAgICAgbGV0IGNlcnRpZmljYXRlO1xuICAgICAgICAgICAgaWYgKGlzVjNSZXNwb25zZUJvZHkocmVzcG9uc2UuYm9keSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoYWdlbnQucm9vdEtleSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IEV4dGVybmFsRXJyb3IuZnJvbUNvZGUobmV3IE1pc3NpbmdSb290S2V5RXJyb3JDb2RlKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBjZXJ0ID0gcmVzcG9uc2UuYm9keS5jZXJ0aWZpY2F0ZTtcbiAgICAgICAgICAgICAgICBjZXJ0aWZpY2F0ZSA9IGF3YWl0IENlcnRpZmljYXRlLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIGNlcnRpZmljYXRlOiBjZXJ0LFxuICAgICAgICAgICAgICAgICAgICByb290S2V5OiBhZ2VudC5yb290S2V5LFxuICAgICAgICAgICAgICAgICAgICBjYW5pc3RlcklkOiBlY2lkLFxuICAgICAgICAgICAgICAgICAgICBibHNWZXJpZnksXG4gICAgICAgICAgICAgICAgICAgIGFnZW50LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhdGggPSBbdXRmOFRvQnl0ZXMoJ3JlcXVlc3Rfc3RhdHVzJyksIHJlcXVlc3RJZF07XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhdHVzID0gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKGxvb2t1cFJlc3VsdFRvQnVmZmVyKGNlcnRpZmljYXRlLmxvb2t1cF9wYXRoKFsuLi5wYXRoLCAnc3RhdHVzJ10pKSk7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChzdGF0dXMpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncmVwbGllZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXBseSA9IGxvb2t1cFJlc3VsdFRvQnVmZmVyKGNlcnRpZmljYXRlLmxvb2t1cF9wYXRoKFsuLi5wYXRoLCAncmVwbHknXSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3JlamVjdGVkJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmluZCByZWplY3Rpb24gZGV0YWlscyBpbiB0aGUgY2VydGlmaWNhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlamVjdENvZGUgPSBuZXcgVWludDhBcnJheShsb29rdXBSZXN1bHRUb0J1ZmZlcihjZXJ0aWZpY2F0ZS5sb29rdXBfcGF0aChbLi4ucGF0aCwgJ3JlamVjdF9jb2RlJ10pKSlbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZWplY3RNZXNzYWdlID0gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKGxvb2t1cFJlc3VsdFRvQnVmZmVyKGNlcnRpZmljYXRlLmxvb2t1cF9wYXRoKFsuLi5wYXRoLCAncmVqZWN0X21lc3NhZ2UnXSkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yX2NvZGVfYnVmID0gbG9va3VwUmVzdWx0VG9CdWZmZXIoY2VydGlmaWNhdGUubG9va3VwX3BhdGgoWy4uLnBhdGgsICdlcnJvcl9jb2RlJ10pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yX2NvZGUgPSBlcnJvcl9jb2RlX2J1ZlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKGVycm9yX2NvZGVfYnVmKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2VydGlmaWVkUmVqZWN0RXJyb3JDb2RlID0gbmV3IENlcnRpZmllZFJlamVjdEVycm9yQ29kZShyZXF1ZXN0SWQsIHJlamVjdENvZGUsIHJlamVjdE1lc3NhZ2UsIGVycm9yX2NvZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2VydGlmaWVkUmVqZWN0RXJyb3JDb2RlLmNhbGxDb250ZXh0ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbmlzdGVySWQ6IGNpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRob2ROYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0dHBEZXRhaWxzOiByZXNwb25zZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBSZWplY3RFcnJvci5mcm9tQ29kZShjZXJ0aWZpZWRSZWplY3RFcnJvckNvZGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNWMlJlc3BvbnNlQm9keShyZXNwb25zZS5ib2R5KSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgcmVqZWN0X2NvZGUsIHJlamVjdF9tZXNzYWdlLCBlcnJvcl9jb2RlIH0gPSByZXNwb25zZS5ib2R5O1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yQ29kZSA9IG5ldyBVbmNlcnRpZmllZFJlamVjdFVwZGF0ZUVycm9yQ29kZShyZXF1ZXN0SWQsIHJlamVjdF9jb2RlLCByZWplY3RfbWVzc2FnZSwgZXJyb3JfY29kZSk7XG4gICAgICAgICAgICAgICAgZXJyb3JDb2RlLmNhbGxDb250ZXh0ID0ge1xuICAgICAgICAgICAgICAgICAgICBjYW5pc3RlcklkOiBjaWQsXG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZE5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGh0dHBEZXRhaWxzOiByZXNwb25zZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRocm93IFJlamVjdEVycm9yLmZyb21Db2RlKGVycm9yQ29kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBGYWxsIGJhY2sgdG8gcG9sbGluZyBpZiB3ZSByZWNlaXZlIGFuIEFjY2VwdGVkIHJlc3BvbnNlIGNvZGVcbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDIwMikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBvbGxPcHRpb25zID0ge1xuICAgICAgICAgICAgICAgICAgICAuLi5wb2xsaW5nT3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgYmxzVmVyaWZ5LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgLy8gQ29udGFpbnMgdGhlIGNlcnRpZmljYXRlIGFuZCB0aGUgcmVwbHkgZnJvbSB0aGUgYm91bmRhcnkgbm9kZVxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcG9sbEZvclJlc3BvbnNlKGFnZW50LCBlY2lkLCByZXF1ZXN0SWQsIHBvbGxPcHRpb25zKTtcbiAgICAgICAgICAgICAgICBjZXJ0aWZpY2F0ZSA9IHJlc3BvbnNlLmNlcnRpZmljYXRlO1xuICAgICAgICAgICAgICAgIHJlcGx5ID0gcmVzcG9uc2UucmVwbHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzaG91bGRJbmNsdWRlSHR0cERldGFpbHMgPSBmdW5jLmFubm90YXRpb25zLmluY2x1ZGVzKEFDVE9SX01FVEhPRF9XSVRIX0hUVFBfREVUQUlMUyk7XG4gICAgICAgICAgICBjb25zdCBzaG91bGRJbmNsdWRlQ2VydGlmaWNhdGUgPSBmdW5jLmFubm90YXRpb25zLmluY2x1ZGVzKEFDVE9SX01FVEhPRF9XSVRIX0NFUlRJRklDQVRFKTtcbiAgICAgICAgICAgIGNvbnN0IGh0dHBEZXRhaWxzID0geyAuLi5yZXNwb25zZSwgcmVxdWVzdERldGFpbHMgfTtcbiAgICAgICAgICAgIGlmIChyZXBseSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNob3VsZEluY2x1ZGVIdHRwRGV0YWlscyAmJiBzaG91bGRJbmNsdWRlQ2VydGlmaWNhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0dHBEZXRhaWxzLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2VydGlmaWNhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IGRlY29kZVJldHVyblZhbHVlKGZ1bmMucmV0VHlwZXMsIHJlcGx5KSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2hvdWxkSW5jbHVkZUNlcnRpZmljYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjZXJ0aWZpY2F0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDogZGVjb2RlUmV0dXJuVmFsdWUoZnVuYy5yZXRUeXBlcywgcmVwbHkpLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzaG91bGRJbmNsdWRlSHR0cERldGFpbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0dHBEZXRhaWxzLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiBkZWNvZGVSZXR1cm5WYWx1ZShmdW5jLnJldFR5cGVzLCByZXBseSksXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBkZWNvZGVSZXR1cm5WYWx1ZShmdW5jLnJldFR5cGVzLCByZXBseSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvckNvZGUgPSBuZXcgVW5leHBlY3RlZEVycm9yQ29kZShgQ2FsbCB3YXMgcmV0dXJuZWQgdW5kZWZpbmVkLiBXZSBjYW5ub3QgZGV0ZXJtaW5lIGlmIHRoZSBjYWxsIHdhcyBzdWNjZXNzZnVsIG9yIG5vdC4gUmV0dXJuIHR5cGVzOiBbJHtmdW5jLnJldFR5cGVzLm1hcCh0ID0+IHQuZGlzcGxheSgpKS5qb2luKCcsJyl9XS5gKTtcbiAgICAgICAgICAgICAgICBlcnJvckNvZGUuY2FsbENvbnRleHQgPSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbmlzdGVySWQ6IGNpZCxcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgaHR0cERldGFpbHMsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0aHJvdyBVbmtub3duRXJyb3IuZnJvbUNvZGUoZXJyb3JDb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgaGFuZGxlciA9ICguLi5hcmdzKSA9PiBjYWxsZXIoe30sIC4uLmFyZ3MpO1xuICAgIGhhbmRsZXIud2l0aE9wdGlvbnMgPVxuICAgICAgICAob3B0aW9ucykgPT4gKC4uLmFyZ3MpID0+IGNhbGxlcihvcHRpb25zLCAuLi5hcmdzKTtcbiAgICByZXR1cm4gaGFuZGxlcjtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFjdG9yLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/actor.js\n");

/***/ }),

/***/ "(ssr)/../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/agent/api.js":
/*!******************************************************************************!*\
  !*** ../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/agent/api.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   QueryResponseStatus: () => (/* binding */ QueryResponseStatus),\n/* harmony export */   ReplicaRejectCode: () => (/* binding */ ReplicaRejectCode),\n/* harmony export */   isV2ResponseBody: () => (/* binding */ isV2ResponseBody),\n/* harmony export */   isV3ResponseBody: () => (/* binding */ isV3ResponseBody)\n/* harmony export */ });\n/**\n * Codes used by the replica for rejecting a message.\n * See {@link https://sdk.dfinity.org/docs/interface-spec/#reject-codes | the interface spec}.\n */\nvar ReplicaRejectCode;\n(function (ReplicaRejectCode) {\n    ReplicaRejectCode[ReplicaRejectCode[\"SysFatal\"] = 1] = \"SysFatal\";\n    ReplicaRejectCode[ReplicaRejectCode[\"SysTransient\"] = 2] = \"SysTransient\";\n    ReplicaRejectCode[ReplicaRejectCode[\"DestinationInvalid\"] = 3] = \"DestinationInvalid\";\n    ReplicaRejectCode[ReplicaRejectCode[\"CanisterReject\"] = 4] = \"CanisterReject\";\n    ReplicaRejectCode[ReplicaRejectCode[\"CanisterError\"] = 5] = \"CanisterError\";\n})(ReplicaRejectCode || (ReplicaRejectCode = {}));\nvar QueryResponseStatus;\n(function (QueryResponseStatus) {\n    QueryResponseStatus[\"Replied\"] = \"replied\";\n    QueryResponseStatus[\"Rejected\"] = \"rejected\";\n})(QueryResponseStatus || (QueryResponseStatus = {}));\n/**\n * Utility function to check if a body is a v2ResponseBody for type safety.\n * @param body The body to check\n * @returns boolean indicating if the body is a v2ResponseBody\n */\nfunction isV2ResponseBody(body) {\n    return body !== null && body !== undefined && 'reject_code' in body;\n}\n/**\n * Utility function to check if a body is a v3ResponseBody for type safety.\n * @param body The body to check\n * @returns boolean indicating if the body is a v3ResponseBody\n */\nfunction isV3ResponseBody(body) {\n    return body !== null && body !== undefined && 'certificate' in body;\n}\n//# sourceMappingURL=api.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vcGFja2FnZXMvc2RrLWpzL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL2FnZW50L2FwaS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNBLFFBQVEscUZBQXFGO0FBQzdGO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDhDQUE4QztBQUN4QztBQUNQO0FBQ0E7QUFDQTtBQUNBLENBQUMsa0RBQWtEO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AaXF1YmUvb3BzLWNvbnNvbGUvLi4vLi4vcGFja2FnZXMvc2RrLWpzL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL2FnZW50L2FwaS5qcz80ZjU5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29kZXMgdXNlZCBieSB0aGUgcmVwbGljYSBmb3IgcmVqZWN0aW5nIGEgbWVzc2FnZS5cbiAqIFNlZSB7QGxpbmsgaHR0cHM6Ly9zZGsuZGZpbml0eS5vcmcvZG9jcy9pbnRlcmZhY2Utc3BlYy8jcmVqZWN0LWNvZGVzIHwgdGhlIGludGVyZmFjZSBzcGVjfS5cbiAqL1xuZXhwb3J0IHZhciBSZXBsaWNhUmVqZWN0Q29kZTtcbihmdW5jdGlvbiAoUmVwbGljYVJlamVjdENvZGUpIHtcbiAgICBSZXBsaWNhUmVqZWN0Q29kZVtSZXBsaWNhUmVqZWN0Q29kZVtcIlN5c0ZhdGFsXCJdID0gMV0gPSBcIlN5c0ZhdGFsXCI7XG4gICAgUmVwbGljYVJlamVjdENvZGVbUmVwbGljYVJlamVjdENvZGVbXCJTeXNUcmFuc2llbnRcIl0gPSAyXSA9IFwiU3lzVHJhbnNpZW50XCI7XG4gICAgUmVwbGljYVJlamVjdENvZGVbUmVwbGljYVJlamVjdENvZGVbXCJEZXN0aW5hdGlvbkludmFsaWRcIl0gPSAzXSA9IFwiRGVzdGluYXRpb25JbnZhbGlkXCI7XG4gICAgUmVwbGljYVJlamVjdENvZGVbUmVwbGljYVJlamVjdENvZGVbXCJDYW5pc3RlclJlamVjdFwiXSA9IDRdID0gXCJDYW5pc3RlclJlamVjdFwiO1xuICAgIFJlcGxpY2FSZWplY3RDb2RlW1JlcGxpY2FSZWplY3RDb2RlW1wiQ2FuaXN0ZXJFcnJvclwiXSA9IDVdID0gXCJDYW5pc3RlckVycm9yXCI7XG59KShSZXBsaWNhUmVqZWN0Q29kZSB8fCAoUmVwbGljYVJlamVjdENvZGUgPSB7fSkpO1xuZXhwb3J0IHZhciBRdWVyeVJlc3BvbnNlU3RhdHVzO1xuKGZ1bmN0aW9uIChRdWVyeVJlc3BvbnNlU3RhdHVzKSB7XG4gICAgUXVlcnlSZXNwb25zZVN0YXR1c1tcIlJlcGxpZWRcIl0gPSBcInJlcGxpZWRcIjtcbiAgICBRdWVyeVJlc3BvbnNlU3RhdHVzW1wiUmVqZWN0ZWRcIl0gPSBcInJlamVjdGVkXCI7XG59KShRdWVyeVJlc3BvbnNlU3RhdHVzIHx8IChRdWVyeVJlc3BvbnNlU3RhdHVzID0ge30pKTtcbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbiB0byBjaGVjayBpZiBhIGJvZHkgaXMgYSB2MlJlc3BvbnNlQm9keSBmb3IgdHlwZSBzYWZldHkuXG4gKiBAcGFyYW0gYm9keSBUaGUgYm9keSB0byBjaGVja1xuICogQHJldHVybnMgYm9vbGVhbiBpbmRpY2F0aW5nIGlmIHRoZSBib2R5IGlzIGEgdjJSZXNwb25zZUJvZHlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVjJSZXNwb25zZUJvZHkoYm9keSkge1xuICAgIHJldHVybiBib2R5ICE9PSBudWxsICYmIGJvZHkgIT09IHVuZGVmaW5lZCAmJiAncmVqZWN0X2NvZGUnIGluIGJvZHk7XG59XG4vKipcbiAqIFV0aWxpdHkgZnVuY3Rpb24gdG8gY2hlY2sgaWYgYSBib2R5IGlzIGEgdjNSZXNwb25zZUJvZHkgZm9yIHR5cGUgc2FmZXR5LlxuICogQHBhcmFtIGJvZHkgVGhlIGJvZHkgdG8gY2hlY2tcbiAqIEByZXR1cm5zIGJvb2xlYW4gaW5kaWNhdGluZyBpZiB0aGUgYm9keSBpcyBhIHYzUmVzcG9uc2VCb2R5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1YzUmVzcG9uc2VCb2R5KGJvZHkpIHtcbiAgICByZXR1cm4gYm9keSAhPT0gbnVsbCAmJiBib2R5ICE9PSB1bmRlZmluZWQgJiYgJ2NlcnRpZmljYXRlJyBpbiBib2R5O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXBpLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/agent/api.js\n");

/***/ }),

/***/ "(ssr)/../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/agent/http/index.js":
/*!*************************************************************************************!*\
  !*** ../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/agent/http/index.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Expiry: () => (/* reexport safe */ _transforms_js__WEBPACK_IMPORTED_MODULE_0__.Expiry),\n/* harmony export */   HttpAgent: () => (/* binding */ HttpAgent),\n/* harmony export */   IC_ROOT_KEY: () => (/* binding */ IC_ROOT_KEY),\n/* harmony export */   JSON_KEY_EXPIRY: () => (/* reexport safe */ _transforms_js__WEBPACK_IMPORTED_MODULE_0__.JSON_KEY_EXPIRY),\n/* harmony export */   MANAGEMENT_CANISTER_ID: () => (/* binding */ MANAGEMENT_CANISTER_ID),\n/* harmony export */   RequestStatusResponseStatus: () => (/* binding */ RequestStatusResponseStatus),\n/* harmony export */   calculateIngressExpiry: () => (/* binding */ calculateIngressExpiry),\n/* harmony export */   httpHeadersTransform: () => (/* reexport safe */ _transforms_js__WEBPACK_IMPORTED_MODULE_0__.httpHeadersTransform),\n/* harmony export */   makeExpiryTransform: () => (/* reexport safe */ _transforms_js__WEBPACK_IMPORTED_MODULE_0__.makeExpiryTransform),\n/* harmony export */   makeNonce: () => (/* reexport safe */ _types_js__WEBPACK_IMPORTED_MODULE_1__.makeNonce),\n/* harmony export */   makeNonceTransform: () => (/* reexport safe */ _transforms_js__WEBPACK_IMPORTED_MODULE_0__.makeNonceTransform)\n/* harmony export */ });\n/* harmony import */ var _dfinity_principal__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @dfinity/principal */ \"(ssr)/../../packages/sdk-js/node_modules/@dfinity/principal/lib/esm/principal.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../errors.js */ \"(ssr)/../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/errors.js\");\n/* harmony import */ var _auth_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../auth.js */ \"(ssr)/../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/auth.js\");\n/* harmony import */ var _cbor_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../cbor.js */ \"(ssr)/../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/cbor.js\");\n/* harmony import */ var _request_id_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../request_id.js */ \"(ssr)/../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/request_id.js\");\n/* harmony import */ var _api_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../api.js */ \"(ssr)/../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/agent/api.js\");\n/* harmony import */ var _transforms_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./transforms.js */ \"(ssr)/../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/agent/http/transforms.js\");\n/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./types.js */ \"(ssr)/../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/agent/http/types.js\");\n/* harmony import */ var _canisterStatus_index_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../../canisterStatus/index.js */ \"(ssr)/../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/canisterStatus/index.js\");\n/* harmony import */ var _certificate_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../../certificate.js */ \"(ssr)/../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/certificate.js\");\n/* harmony import */ var _noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @noble/curves/ed25519 */ \"(ssr)/../../packages/sdk-js/node_modules/@noble/curves/esm/ed25519.js\");\n/* harmony import */ var _utils_expirableMap_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../utils/expirableMap.js */ \"(ssr)/../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/utils/expirableMap.js\");\n/* harmony import */ var _public_key_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../public_key.js */ \"(ssr)/../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/public_key.js\");\n/* harmony import */ var _observable_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../observable.js */ \"(ssr)/../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/observable.js\");\n/* harmony import */ var _polling_backoff_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../polling/backoff.js */ \"(ssr)/../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/polling/backoff.js\");\n/* harmony import */ var _utils_leb_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../../utils/leb.js */ \"(ssr)/../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/utils/leb.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @noble/hashes/utils */ \"(ssr)/../../packages/sdk-js/node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _utils_buffer_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../../utils/buffer.js */ \"(ssr)/../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/utils/buffer.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../constants.js */ \"(ssr)/../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/constants.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar RequestStatusResponseStatus;\n(function (RequestStatusResponseStatus) {\n    RequestStatusResponseStatus[\"Received\"] = \"received\";\n    RequestStatusResponseStatus[\"Processing\"] = \"processing\";\n    RequestStatusResponseStatus[\"Replied\"] = \"replied\";\n    RequestStatusResponseStatus[\"Rejected\"] = \"rejected\";\n    RequestStatusResponseStatus[\"Unknown\"] = \"unknown\";\n    RequestStatusResponseStatus[\"Done\"] = \"done\";\n})(RequestStatusResponseStatus || (RequestStatusResponseStatus = {}));\nconst MINUTE_TO_MSECS = 60 * 1_000;\nconst MSECS_TO_NANOSECONDS = 1_000_000;\nconst DEFAULT_TIME_DIFF_MSECS = 0;\n// Root public key for the IC, encoded as hex\nconst IC_ROOT_KEY = '308182301d060d2b0601040182dc7c0503010201060c2b0601040182dc7c05030201036100814' +\n    'c0e6ec71fab583b08bd81373c255c3c371b2e84863c98a4f1e08b74235d14fb5d9c0cd546d968' +\n    '5f913a0c0b2cc5341583bf4b4392e467db96d65b9bb4cb717112f8472e0d5a4d14505ffd7484' +\n    'b01291091c5f87b98883463f98091a0baaae';\nconst MANAGEMENT_CANISTER_ID = 'aaaaa-aa';\n// IC0 domain info\nconst IC0_DOMAIN = 'ic0.app';\nconst IC0_SUB_DOMAIN = '.ic0.app';\nconst ICP0_DOMAIN = 'icp0.io';\nconst ICP0_SUB_DOMAIN = '.icp0.io';\nconst ICP_API_DOMAIN = 'icp-api.io';\nconst ICP_API_SUB_DOMAIN = '.icp-api.io';\nconst HTTP_STATUS_OK = 200;\nconst HTTP_STATUS_ACCEPTED = 202;\nconst HTTP_STATUS_NOT_FOUND = 404;\nfunction getDefaultFetch() {\n    let defaultFetch;\n    if (typeof window !== 'undefined') {\n        // Browser context\n        if (window.fetch) {\n            defaultFetch = window.fetch.bind(window);\n        }\n        else {\n            throw _errors_js__WEBPACK_IMPORTED_MODULE_2__.ExternalError.fromCode(new _errors_js__WEBPACK_IMPORTED_MODULE_2__.HttpDefaultFetchErrorCode('Fetch implementation was not available. You appear to be in a browser context, but window.fetch was not present.'));\n        }\n    }\n    else if (typeof global !== 'undefined') {\n        // Node context\n        if (global.fetch) {\n            defaultFetch = global.fetch.bind(global);\n        }\n        else {\n            throw _errors_js__WEBPACK_IMPORTED_MODULE_2__.ExternalError.fromCode(new _errors_js__WEBPACK_IMPORTED_MODULE_2__.HttpDefaultFetchErrorCode('Fetch implementation was not available. You appear to be in a Node.js context, but global.fetch was not available.'));\n        }\n    }\n    else if (typeof self !== 'undefined') {\n        if (self.fetch) {\n            defaultFetch = self.fetch.bind(self);\n        }\n    }\n    if (defaultFetch) {\n        return defaultFetch;\n    }\n    throw _errors_js__WEBPACK_IMPORTED_MODULE_2__.ExternalError.fromCode(new _errors_js__WEBPACK_IMPORTED_MODULE_2__.HttpDefaultFetchErrorCode('Fetch implementation was not available. Please provide fetch to the HttpAgent constructor, or ensure it is available in the window or global context.'));\n}\nfunction determineHost(configuredHost) {\n    let host;\n    if (configuredHost !== undefined) {\n        if (!configuredHost.match(/^[a-z]+:/) && typeof window !== 'undefined') {\n            host = new URL(window.location.protocol + '//' + configuredHost);\n        }\n        else {\n            host = new URL(configuredHost);\n        }\n    }\n    else {\n        // Mainnet, local, and remote environments will have the api route available\n        const knownHosts = ['ic0.app', 'icp0.io', '127.0.0.1', 'localhost'];\n        const remoteHosts = ['.github.dev', '.gitpod.io'];\n        const location = typeof window !== 'undefined' ? window.location : undefined;\n        const hostname = location?.hostname;\n        let knownHost;\n        if (hostname && typeof hostname === 'string') {\n            if (remoteHosts.some(host => hostname.endsWith(host))) {\n                knownHost = hostname;\n            }\n            else {\n                knownHost = knownHosts.find(host => hostname.endsWith(host));\n            }\n        }\n        if (location && knownHost) {\n            // If the user is on a boundary-node provided host, we can use the same host for the agent\n            host = new URL(`${location.protocol}//${knownHost}${location.port ? ':' + location.port : ''}`);\n        }\n        else {\n            host = new URL('https://icp-api.io');\n        }\n    }\n    return host.toString();\n}\n/**\n * A HTTP agent allows users to interact with a client of the internet computer\nusing the available methods. It exposes an API that closely follows the\npublic view of the internet computer, and is not intended to be exposed\ndirectly to the majority of users due to its low-level interface.\n * There is a pipeline to apply transformations to the request before sending\nit to the client. This is to decouple signature, nonce generation and\nother computations so that this class can stay as simple as possible while\nallowing extensions.\n */\nclass HttpAgent {\n    #rootKeyPromise;\n    #shouldFetchRootKey;\n    #timeDiffMsecs;\n    #hasSyncedTime;\n    #syncTimePromise;\n    #shouldSyncTime;\n    #identity;\n    #fetch;\n    #fetchOptions;\n    #callOptions;\n    #credentials;\n    #retryTimes; // Retry requests N times before erroring by default\n    #backoffStrategy;\n    #maxIngressExpiryInMinutes;\n    get #maxIngressExpiryInMs() {\n        return this.#maxIngressExpiryInMinutes * MINUTE_TO_MSECS;\n    }\n    #queryPipeline;\n    #updatePipeline;\n    #subnetKeys;\n    #verifyQuerySignatures;\n    /**\n     * @param options - Options for the HttpAgent\n     * @deprecated Use `HttpAgent.create` or `HttpAgent.createSync` instead\n     */\n    constructor(options = {}) {\n        this.#rootKeyPromise = null;\n        this.#shouldFetchRootKey = false;\n        this.#timeDiffMsecs = DEFAULT_TIME_DIFF_MSECS;\n        this.#hasSyncedTime = false;\n        this.#syncTimePromise = null;\n        this.#shouldSyncTime = false;\n        // Public signature to help with type checking.\n        this._isAgent = true;\n        this.config = {};\n        this.log = new _observable_js__WEBPACK_IMPORTED_MODULE_3__.ObservableLog();\n        this.#queryPipeline = [];\n        this.#updatePipeline = [];\n        this.#subnetKeys = new _utils_expirableMap_js__WEBPACK_IMPORTED_MODULE_4__.ExpirableMap({\n            expirationTime: 5 * MINUTE_TO_MSECS,\n        });\n        this.#verifyQuerySignatures = true;\n        /**\n         * See https://internetcomputer.org/docs/current/references/ic-interface-spec/#http-query for details on validation\n         * @param queryResponse - The response from the query\n         * @param subnetStatus - The subnet status, including all node keys\n         * @returns ApiQueryResponse\n         */\n        this.#verifyQueryResponse = (queryResponse, subnetStatus) => {\n            if (this.#verifyQuerySignatures === false) {\n                // This should not be called if the user has disabled verification\n                return queryResponse;\n            }\n            const { status, signatures = [], requestId } = queryResponse;\n            for (const sig of signatures) {\n                const { timestamp, identity } = sig;\n                const nodeId = _dfinity_principal__WEBPACK_IMPORTED_MODULE_5__.Principal.fromUint8Array(identity).toText();\n                // Hash is constructed differently depending on the status\n                let hash;\n                if (status === _api_js__WEBPACK_IMPORTED_MODULE_6__.QueryResponseStatus.Replied) {\n                    const { reply } = queryResponse;\n                    hash = (0,_request_id_js__WEBPACK_IMPORTED_MODULE_7__.hashOfMap)({\n                        status: status,\n                        reply: reply,\n                        timestamp: BigInt(timestamp),\n                        request_id: requestId,\n                    });\n                }\n                else if (status === _api_js__WEBPACK_IMPORTED_MODULE_6__.QueryResponseStatus.Rejected) {\n                    const { reject_code, reject_message, error_code } = queryResponse;\n                    hash = (0,_request_id_js__WEBPACK_IMPORTED_MODULE_7__.hashOfMap)({\n                        status: status,\n                        reject_code: reject_code,\n                        reject_message: reject_message,\n                        error_code: error_code,\n                        timestamp: BigInt(timestamp),\n                        request_id: requestId,\n                    });\n                }\n                else {\n                    throw _errors_js__WEBPACK_IMPORTED_MODULE_2__.UnknownError.fromCode(new _errors_js__WEBPACK_IMPORTED_MODULE_2__.UnexpectedErrorCode(`Unknown status: ${status}`));\n                }\n                const separatorWithHash = (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_8__.concatBytes)(_constants_js__WEBPACK_IMPORTED_MODULE_9__.IC_RESPONSE_DOMAIN_SEPARATOR, hash);\n                // FIX: check for match without verifying N times\n                const pubKey = subnetStatus.nodeKeys.get(nodeId);\n                if (!pubKey) {\n                    throw _errors_js__WEBPACK_IMPORTED_MODULE_2__.ProtocolError.fromCode(new _errors_js__WEBPACK_IMPORTED_MODULE_2__.MalformedPublicKeyErrorCode());\n                }\n                const rawKey = _public_key_js__WEBPACK_IMPORTED_MODULE_10__.Ed25519PublicKey.fromDer(pubKey).rawKey;\n                const valid = _noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_11__.ed25519.verify(sig.signature, separatorWithHash, rawKey);\n                if (valid)\n                    return queryResponse;\n                throw _errors_js__WEBPACK_IMPORTED_MODULE_2__.TrustError.fromCode(new _errors_js__WEBPACK_IMPORTED_MODULE_2__.QuerySignatureVerificationFailedErrorCode(nodeId));\n            }\n            return queryResponse;\n        };\n        this.config = options;\n        this.#fetch = options.fetch || getDefaultFetch() || fetch.bind(global);\n        this.#fetchOptions = options.fetchOptions;\n        this.#callOptions = options.callOptions;\n        this.#shouldFetchRootKey = options.shouldFetchRootKey ?? false;\n        this.#shouldSyncTime = options.shouldSyncTime ?? false;\n        // Use provided root key, otherwise fall back to IC_ROOT_KEY for mainnet or null if the key needs to be fetched\n        if (options.rootKey) {\n            this.rootKey = options.rootKey;\n        }\n        else if (this.#shouldFetchRootKey) {\n            this.rootKey = null;\n        }\n        else {\n            this.rootKey = (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_8__.hexToBytes)(IC_ROOT_KEY);\n        }\n        const host = determineHost(options.host);\n        this.host = new URL(host);\n        if (options.verifyQuerySignatures !== undefined) {\n            this.#verifyQuerySignatures = options.verifyQuerySignatures;\n        }\n        // Default is 3\n        this.#retryTimes = options.retryTimes ?? 3;\n        // Delay strategy for retries. Default is exponential backoff\n        const defaultBackoffFactory = () => new _polling_backoff_js__WEBPACK_IMPORTED_MODULE_12__.ExponentialBackoff({\n            maxIterations: this.#retryTimes,\n        });\n        this.#backoffStrategy = options.backoffStrategy || defaultBackoffFactory;\n        // Rewrite to avoid redirects\n        if (this.host.hostname.endsWith(IC0_SUB_DOMAIN)) {\n            this.host.hostname = IC0_DOMAIN;\n        }\n        else if (this.host.hostname.endsWith(ICP0_SUB_DOMAIN)) {\n            this.host.hostname = ICP0_DOMAIN;\n        }\n        else if (this.host.hostname.endsWith(ICP_API_SUB_DOMAIN)) {\n            this.host.hostname = ICP_API_DOMAIN;\n        }\n        if (options.credentials) {\n            const { name, password } = options.credentials;\n            this.#credentials = `${name}${password ? ':' + password : ''}`;\n        }\n        this.#identity = Promise.resolve(options.identity || new _auth_js__WEBPACK_IMPORTED_MODULE_13__.AnonymousIdentity());\n        if (options.ingressExpiryInMinutes && options.ingressExpiryInMinutes > 5) {\n            throw _errors_js__WEBPACK_IMPORTED_MODULE_2__.InputError.fromCode(new _errors_js__WEBPACK_IMPORTED_MODULE_2__.IngressExpiryInvalidErrorCode('The maximum ingress expiry time is 5 minutes.', options.ingressExpiryInMinutes));\n        }\n        if (options.ingressExpiryInMinutes && options.ingressExpiryInMinutes <= 0) {\n            throw _errors_js__WEBPACK_IMPORTED_MODULE_2__.InputError.fromCode(new _errors_js__WEBPACK_IMPORTED_MODULE_2__.IngressExpiryInvalidErrorCode('Ingress expiry time must be greater than 0.', options.ingressExpiryInMinutes));\n        }\n        this.#maxIngressExpiryInMinutes = options.ingressExpiryInMinutes || 5;\n        // Add a nonce transform to ensure calls are unique\n        this.addTransform('update', (0,_transforms_js__WEBPACK_IMPORTED_MODULE_0__.makeNonceTransform)(_types_js__WEBPACK_IMPORTED_MODULE_1__.makeNonce));\n        if (options.useQueryNonces) {\n            this.addTransform('query', (0,_transforms_js__WEBPACK_IMPORTED_MODULE_0__.makeNonceTransform)(_types_js__WEBPACK_IMPORTED_MODULE_1__.makeNonce));\n        }\n        if (options.logToConsole) {\n            this.log.subscribe(log => {\n                if (log.level === 'error') {\n                    console.error(log.message);\n                }\n                else if (log.level === 'warn') {\n                    console.warn(log.message);\n                }\n                else {\n                    console.log(log.message);\n                }\n            });\n        }\n    }\n    static createSync(options = {}) {\n        return new this({ ...options });\n    }\n    static async create(options = {}) {\n        const agent = HttpAgent.createSync(options);\n        await agent.#asyncGuard();\n        return agent;\n    }\n    static async from(agent) {\n        try {\n            if ('config' in agent) {\n                return await HttpAgent.create(agent.config);\n            }\n            return await HttpAgent.create({\n                fetch: agent._fetch,\n                fetchOptions: agent._fetchOptions,\n                callOptions: agent._callOptions,\n                host: agent._host.toString(),\n                identity: agent._identity ?? undefined,\n            });\n        }\n        catch {\n            throw _errors_js__WEBPACK_IMPORTED_MODULE_2__.InputError.fromCode(new _errors_js__WEBPACK_IMPORTED_MODULE_2__.CreateHttpAgentErrorCode());\n        }\n    }\n    isLocal() {\n        const hostname = this.host.hostname;\n        return hostname === '127.0.0.1' || hostname.endsWith('127.0.0.1');\n    }\n    addTransform(type, fn, priority = fn.priority || 0) {\n        if (type === 'update') {\n            // Keep the pipeline sorted at all time, by priority.\n            const i = this.#updatePipeline.findIndex(x => (x.priority || 0) < priority);\n            this.#updatePipeline.splice(i >= 0 ? i : this.#updatePipeline.length, 0, Object.assign(fn, { priority }));\n        }\n        else if (type === 'query') {\n            // Keep the pipeline sorted at all time, by priority.\n            const i = this.#queryPipeline.findIndex(x => (x.priority || 0) < priority);\n            this.#queryPipeline.splice(i >= 0 ? i : this.#queryPipeline.length, 0, Object.assign(fn, { priority }));\n        }\n    }\n    async getPrincipal() {\n        if (!this.#identity) {\n            throw _errors_js__WEBPACK_IMPORTED_MODULE_2__.ExternalError.fromCode(new _errors_js__WEBPACK_IMPORTED_MODULE_2__.IdentityInvalidErrorCode());\n        }\n        return (await this.#identity).getPrincipal();\n    }\n    /**\n     * Makes a call to a canister method.\n     * @param canisterId - The ID of the canister to call. Can be a Principal or a string.\n     * @param options - Options for the call.\n     * @param options.methodName - The name of the method to call.\n     * @param options.arg - The argument to pass to the method, as a Uint8Array.\n     * @param options.effectiveCanisterId - (Optional) The effective canister ID, if different from the target canister ID.\n     * @param options.callSync - (Optional) Whether to use synchronous call mode. Defaults to true.\n     * @param options.nonce - (Optional) A unique nonce for the request. If provided, it will override any nonce set by transforms.\n     * @param identity - (Optional) The identity to use for the call. If not provided, the agent's current identity will be used.\n     * @returns A promise that resolves to the response of the call, including the request ID and response details.\n     */\n    async call(canisterId, options, identity) {\n        const callSync = options.callSync ?? true;\n        const id = await (identity ?? this.#identity);\n        if (!id) {\n            throw _errors_js__WEBPACK_IMPORTED_MODULE_2__.ExternalError.fromCode(new _errors_js__WEBPACK_IMPORTED_MODULE_2__.IdentityInvalidErrorCode());\n        }\n        const canister = _dfinity_principal__WEBPACK_IMPORTED_MODULE_5__.Principal.from(canisterId);\n        const ecid = options.effectiveCanisterId\n            ? _dfinity_principal__WEBPACK_IMPORTED_MODULE_5__.Principal.from(options.effectiveCanisterId)\n            : canister;\n        await this.#asyncGuard(ecid);\n        const sender = id.getPrincipal();\n        const ingress_expiry = calculateIngressExpiry(this.#maxIngressExpiryInMinutes, this.#timeDiffMsecs);\n        const submit = {\n            request_type: _types_js__WEBPACK_IMPORTED_MODULE_1__.SubmitRequestType.Call,\n            canister_id: canister,\n            method_name: options.methodName,\n            arg: options.arg,\n            sender,\n            ingress_expiry,\n        };\n        let transformedRequest = (await this._transform({\n            request: {\n                body: null,\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/cbor',\n                    ...(this.#credentials ? { Authorization: 'Basic ' + btoa(this.#credentials) } : {}),\n                },\n            },\n            endpoint: _types_js__WEBPACK_IMPORTED_MODULE_1__.Endpoint.Call,\n            body: submit,\n        }));\n        // Determine the nonce to use for the request\n        let nonce;\n        // Check if a nonce is provided in the options and convert it to the correct type\n        if (options?.nonce) {\n            nonce = toNonce(options.nonce);\n        }\n        // If no nonce is provided in the options, check the transformedRequest body\n        else if (transformedRequest.body.nonce) {\n            nonce = toNonce(transformedRequest.body.nonce);\n        }\n        // If no nonce is found, set it to undefined\n        else {\n            nonce = undefined;\n        }\n        // Assign the determined nonce to the submit object\n        submit.nonce = nonce;\n        /**\n         * Converts a Uint8Array to a Nonce type.\n         * @param buf - The buffer to convert.\n         * @returns The buffer as a Nonce.\n         */\n        function toNonce(buf) {\n            return Object.assign(buf, { __nonce__: undefined });\n        }\n        // Apply transform for identity.\n        transformedRequest = (await id.transformRequest(transformedRequest));\n        const body = _cbor_js__WEBPACK_IMPORTED_MODULE_14__.encode(transformedRequest.body);\n        const backoff = this.#backoffStrategy();\n        const requestId = (0,_request_id_js__WEBPACK_IMPORTED_MODULE_7__.requestIdOf)(submit);\n        try {\n            // Attempt v3 sync call\n            const requestSync = () => {\n                this.log.print(`fetching \"/api/v3/canister/${ecid.toText()}/call\" with request:`, transformedRequest);\n                return this.#fetch('' + new URL(`/api/v3/canister/${ecid.toText()}/call`, this.host), {\n                    ...this.#callOptions,\n                    ...transformedRequest.request,\n                    body,\n                });\n            };\n            const requestAsync = () => {\n                this.log.print(`fetching \"/api/v2/canister/${ecid.toText()}/call\" with request:`, transformedRequest);\n                return this.#fetch('' + new URL(`/api/v2/canister/${ecid.toText()}/call`, this.host), {\n                    ...this.#callOptions,\n                    ...transformedRequest.request,\n                    body,\n                });\n            };\n            const requestFn = callSync ? requestSync : requestAsync;\n            const { responseBodyBytes, ...response } = await this.#requestAndRetry({\n                requestFn,\n                backoff,\n                tries: 0,\n            });\n            const responseBody = (responseBodyBytes.byteLength > 0 ? _cbor_js__WEBPACK_IMPORTED_MODULE_14__.decode(responseBodyBytes) : null);\n            return {\n                requestId,\n                response: {\n                    ...response,\n                    body: responseBody,\n                },\n                requestDetails: submit,\n            };\n        }\n        catch (error) {\n            let callError;\n            if (error instanceof _errors_js__WEBPACK_IMPORTED_MODULE_2__.AgentError) {\n                // If the error is due to the v3 api not being supported, fall back to v2\n                if (error.hasCode(_errors_js__WEBPACK_IMPORTED_MODULE_2__.HttpV3ApiNotSupportedErrorCode)) {\n                    this.log.warn('v3 api not supported. Fall back to v2');\n                    return this.call(canisterId, {\n                        ...options,\n                        // disable v3 api\n                        callSync: false,\n                    }, identity);\n                }\n                else if (error.hasCode(_errors_js__WEBPACK_IMPORTED_MODULE_2__.IngressExpiryInvalidErrorCode) && !this.#hasSyncedTime) {\n                    // if there is an ingress expiry error and the time has not been synced yet,\n                    // sync time with the network and try again\n                    await this.syncTime(canister);\n                    return this.call(canister, options, identity);\n                }\n                else {\n                    // override the error code to include the request details\n                    error.code.requestContext = {\n                        requestId,\n                        senderPubKey: transformedRequest.body.sender_pubkey,\n                        senderSignature: transformedRequest.body.sender_sig,\n                        ingressExpiry: transformedRequest.body.content.ingress_expiry,\n                    };\n                    callError = error;\n                }\n            }\n            else {\n                callError = _errors_js__WEBPACK_IMPORTED_MODULE_2__.UnknownError.fromCode(new _errors_js__WEBPACK_IMPORTED_MODULE_2__.UnexpectedErrorCode(error));\n            }\n            this.log.error(`Error while making call: ${callError.message}`, callError);\n            throw callError;\n        }\n    }\n    async #requestAndRetryQuery(args) {\n        const { ecid, transformedRequest, body, requestId, backoff, tries } = args;\n        const delay = tries === 0 ? 0 : backoff.next();\n        this.log.print(`fetching \"/api/v2/canister/${ecid.toString()}/query\" with tries:`, {\n            tries,\n            backoff,\n            delay,\n        });\n        // If delay is null, the backoff strategy is exhausted due to a maximum number of retries, duration, or other reason\n        if (delay === null) {\n            throw _errors_js__WEBPACK_IMPORTED_MODULE_2__.UnknownError.fromCode(new _errors_js__WEBPACK_IMPORTED_MODULE_2__.TimeoutWaitingForResponseErrorCode(`Backoff strategy exhausted after ${tries} attempts.`, requestId));\n        }\n        if (delay > 0) {\n            await new Promise(resolve => setTimeout(resolve, delay));\n        }\n        let response;\n        // Make the request and retry if it throws an error\n        try {\n            this.log.print(`fetching \"/api/v2/canister/${ecid.toString()}/query\" with request:`, transformedRequest);\n            const fetchResponse = await this.#fetch('' + new URL(`/api/v2/canister/${ecid.toString()}/query`, this.host), {\n                ...this.#fetchOptions,\n                ...transformedRequest.request,\n                body,\n            });\n            if (fetchResponse.status === HTTP_STATUS_OK) {\n                const queryResponse = _cbor_js__WEBPACK_IMPORTED_MODULE_14__.decode((0,_utils_buffer_js__WEBPACK_IMPORTED_MODULE_15__.uint8FromBufLike)(await fetchResponse.arrayBuffer()));\n                response = {\n                    ...queryResponse,\n                    httpDetails: {\n                        ok: fetchResponse.ok,\n                        status: fetchResponse.status,\n                        statusText: fetchResponse.statusText,\n                        headers: (0,_transforms_js__WEBPACK_IMPORTED_MODULE_0__.httpHeadersTransform)(fetchResponse.headers),\n                    },\n                    requestId,\n                };\n            }\n            else {\n                throw _errors_js__WEBPACK_IMPORTED_MODULE_2__.ProtocolError.fromCode(new _errors_js__WEBPACK_IMPORTED_MODULE_2__.HttpErrorCode(fetchResponse.status, fetchResponse.statusText, (0,_transforms_js__WEBPACK_IMPORTED_MODULE_0__.httpHeadersTransform)(fetchResponse.headers), await fetchResponse.text()));\n            }\n        }\n        catch (error) {\n            if (tries < this.#retryTimes) {\n                this.log.warn(`Caught exception while attempting to make query:\\n` +\n                    `  ${error}\\n` +\n                    `  Retrying query.`);\n                return await this.#requestAndRetryQuery({ ...args, tries: tries + 1 });\n            }\n            if (error instanceof _errors_js__WEBPACK_IMPORTED_MODULE_2__.AgentError) {\n                // if it's an error that we have thrown, just throw it as is\n                throw error;\n            }\n            // if it's an error that we have not thrown, wrap it in a TransportError\n            throw _errors_js__WEBPACK_IMPORTED_MODULE_2__.TransportError.fromCode(new _errors_js__WEBPACK_IMPORTED_MODULE_2__.HttpFetchErrorCode(error));\n        }\n        // Skip timestamp verification if the user has set verifyQuerySignatures to false\n        if (!this.#verifyQuerySignatures) {\n            return response;\n        }\n        const signatureTimestampNs = response.signatures?.[0]?.timestamp;\n        if (!signatureTimestampNs) {\n            throw _errors_js__WEBPACK_IMPORTED_MODULE_2__.ProtocolError.fromCode(new _errors_js__WEBPACK_IMPORTED_MODULE_2__.MalformedSignatureErrorCode('Timestamp not found in query response. This suggests a malformed or malicious response.'));\n        }\n        const signatureTimestampMs = Number(BigInt(signatureTimestampNs) / BigInt(MSECS_TO_NANOSECONDS));\n        const currentTimestampInMs = Date.now() + this.#timeDiffMsecs;\n        // We don't need `Math.abs` here because we allow signatures in the future\n        if (currentTimestampInMs - signatureTimestampMs > this.#maxIngressExpiryInMs) {\n            if (tries < this.#retryTimes) {\n                this.log.warn('Timestamp is older than the max ingress expiry. Retrying query.', {\n                    requestId,\n                    signatureTimestampMs,\n                });\n                return await this.#requestAndRetryQuery({ ...args, tries: tries + 1 });\n            }\n            throw _errors_js__WEBPACK_IMPORTED_MODULE_2__.TrustError.fromCode(new _errors_js__WEBPACK_IMPORTED_MODULE_2__.CertificateOutdatedErrorCode(this.#maxIngressExpiryInMinutes, requestId, tries));\n        }\n        return response;\n    }\n    /**\n     * Makes a request and retries if it fails.\n     * @param args - The arguments for the request.\n     * @param args.requestFn - A function that returns a Promise resolving to a Response.\n     * @param args.backoff - The backoff strategy to use for retries.\n     * @param args.tries - The number of retry attempts made so far.\n     * @returns The response from the request, if the status is 200 or 202.\n     * See the https://internetcomputer.org/docs/references/ic-interface-spec#http-interface for details on the response statuses.\n     * @throws {ProtocolError} if the response status is not 200 or 202, and the retry limit has been reached.\n     * @throws {TransportError} if the request fails, and the retry limit has been reached.\n     */\n    async #requestAndRetry(args) {\n        const { requestFn, backoff, tries } = args;\n        const delay = tries === 0 ? 0 : backoff.next();\n        // If delay is null, the backoff strategy is exhausted due to a maximum number of retries, duration, or other reason\n        if (delay === null) {\n            throw _errors_js__WEBPACK_IMPORTED_MODULE_2__.ProtocolError.fromCode(new _errors_js__WEBPACK_IMPORTED_MODULE_2__.TimeoutWaitingForResponseErrorCode(`Retry strategy exhausted after ${tries} attempts.`));\n        }\n        if (delay > 0) {\n            await new Promise(resolve => setTimeout(resolve, delay));\n        }\n        let response;\n        let responseBodyBytes = new Uint8Array();\n        try {\n            response = await requestFn();\n            // According to the spec, only 200 responses have a non-empty body\n            if (response.status === HTTP_STATUS_OK) {\n                // Consume the response body, to ensure that the response is not closed unexpectedly\n                responseBodyBytes = (0,_utils_buffer_js__WEBPACK_IMPORTED_MODULE_15__.uint8FromBufLike)(await response.clone().arrayBuffer());\n            }\n        }\n        catch (error) {\n            if (tries < this.#retryTimes) {\n                this.log.warn(`Caught exception while attempting to make request:\\n` +\n                    `  ${error}\\n` +\n                    `  Retrying request.`);\n                // Delay the request by the configured backoff strategy\n                return await this.#requestAndRetry({ requestFn, backoff, tries: tries + 1 });\n            }\n            throw _errors_js__WEBPACK_IMPORTED_MODULE_2__.TransportError.fromCode(new _errors_js__WEBPACK_IMPORTED_MODULE_2__.HttpFetchErrorCode(error));\n        }\n        const headers = (0,_transforms_js__WEBPACK_IMPORTED_MODULE_0__.httpHeadersTransform)(response.headers);\n        if (response.status === HTTP_STATUS_OK || response.status === HTTP_STATUS_ACCEPTED) {\n            return {\n                ok: response.ok, // should always be true\n                status: response.status,\n                statusText: response.statusText,\n                responseBodyBytes,\n                headers,\n            };\n        }\n        const responseText = await response.text();\n        if (response.status === HTTP_STATUS_NOT_FOUND && response.url.includes('api/v3')) {\n            throw _errors_js__WEBPACK_IMPORTED_MODULE_2__.ProtocolError.fromCode(new _errors_js__WEBPACK_IMPORTED_MODULE_2__.HttpV3ApiNotSupportedErrorCode());\n        }\n        // The error message comes from https://github.com/dfinity/ic/blob/23d5990bfc5277c32e54f0087b5a38fa412171e1/rs/validator/src/ingress_validation.rs#L233\n        if (responseText.startsWith('Invalid request expiry: ')) {\n            throw _errors_js__WEBPACK_IMPORTED_MODULE_2__.InputError.fromCode(new _errors_js__WEBPACK_IMPORTED_MODULE_2__.IngressExpiryInvalidErrorCode(responseText, this.#maxIngressExpiryInMinutes));\n        }\n        if (tries < this.#retryTimes) {\n            return await this.#requestAndRetry({ requestFn, backoff, tries: tries + 1 });\n        }\n        throw _errors_js__WEBPACK_IMPORTED_MODULE_2__.ProtocolError.fromCode(new _errors_js__WEBPACK_IMPORTED_MODULE_2__.HttpErrorCode(response.status, response.statusText, headers, responseText));\n    }\n    async query(canisterId, fields, identity) {\n        const backoff = this.#backoffStrategy();\n        const ecid = fields.effectiveCanisterId\n            ? _dfinity_principal__WEBPACK_IMPORTED_MODULE_5__.Principal.from(fields.effectiveCanisterId)\n            : _dfinity_principal__WEBPACK_IMPORTED_MODULE_5__.Principal.from(canisterId);\n        await this.#asyncGuard(ecid);\n        this.log.print(`ecid ${ecid.toString()}`);\n        this.log.print(`canisterId ${canisterId.toString()}`);\n        let transformedRequest;\n        const id = await (identity ?? this.#identity);\n        if (!id) {\n            throw _errors_js__WEBPACK_IMPORTED_MODULE_2__.ExternalError.fromCode(new _errors_js__WEBPACK_IMPORTED_MODULE_2__.IdentityInvalidErrorCode());\n        }\n        const canister = _dfinity_principal__WEBPACK_IMPORTED_MODULE_5__.Principal.from(canisterId);\n        const sender = id.getPrincipal();\n        const ingressExpiry = calculateIngressExpiry(this.#maxIngressExpiryInMinutes, this.#timeDiffMsecs);\n        const request = {\n            request_type: _types_js__WEBPACK_IMPORTED_MODULE_1__.ReadRequestType.Query,\n            canister_id: canister,\n            method_name: fields.methodName,\n            arg: fields.arg,\n            sender,\n            ingress_expiry: ingressExpiry,\n        };\n        const requestId = (0,_request_id_js__WEBPACK_IMPORTED_MODULE_7__.requestIdOf)(request);\n        transformedRequest = await this._transform({\n            request: {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/cbor',\n                    ...(this.#credentials ? { Authorization: 'Basic ' + btoa(this.#credentials) } : {}),\n                },\n            },\n            endpoint: _types_js__WEBPACK_IMPORTED_MODULE_1__.Endpoint.Query,\n            body: request,\n        });\n        // Apply transform for identity.\n        transformedRequest = (await id.transformRequest(transformedRequest));\n        const body = _cbor_js__WEBPACK_IMPORTED_MODULE_14__.encode(transformedRequest.body);\n        const args = {\n            canister: canister.toText(),\n            ecid,\n            transformedRequest,\n            body,\n            requestId,\n            backoff,\n            tries: 0,\n        };\n        const makeQuery = async () => {\n            // Attempt to make the query i=retryTimes times\n            const query = await this.#requestAndRetryQuery(args);\n            return {\n                requestDetails: request,\n                ...query,\n            };\n        };\n        const getSubnetStatus = async () => {\n            const cachedSubnetStatus = this.#subnetKeys.get(ecid.toString());\n            if (cachedSubnetStatus) {\n                return cachedSubnetStatus;\n            }\n            await this.fetchSubnetKeys(ecid.toString());\n            const subnetStatus = this.#subnetKeys.get(ecid.toString());\n            if (!subnetStatus) {\n                throw _errors_js__WEBPACK_IMPORTED_MODULE_2__.TrustError.fromCode(new _errors_js__WEBPACK_IMPORTED_MODULE_2__.MissingSignatureErrorCode());\n            }\n            return subnetStatus;\n        };\n        try {\n            if (!this.#verifyQuerySignatures) {\n                // Skip verification if the user has disabled it\n                return await makeQuery();\n            }\n            // Make query and fetch subnet keys in parallel\n            const [queryWithDetails, subnetStatus] = await Promise.all([makeQuery(), getSubnetStatus()]);\n            try {\n                return this.#verifyQueryResponse(queryWithDetails, subnetStatus);\n            }\n            catch {\n                // In case the node signatures have changed, refresh the subnet keys and try again\n                this.log.warn('Query response verification failed. Retrying with fresh subnet keys.');\n                this.#subnetKeys.delete(ecid.toString());\n                const updatedSubnetStatus = await getSubnetStatus();\n                return this.#verifyQueryResponse(queryWithDetails, updatedSubnetStatus);\n            }\n        }\n        catch (error) {\n            let queryError;\n            if (error instanceof _errors_js__WEBPACK_IMPORTED_MODULE_2__.AgentError) {\n                // override the error code to include the request details\n                error.code.requestContext = {\n                    requestId,\n                    senderPubKey: transformedRequest.body.sender_pubkey,\n                    senderSignature: transformedRequest.body.sender_sig,\n                    ingressExpiry: transformedRequest.body.content.ingress_expiry,\n                };\n                queryError = error;\n            }\n            else {\n                queryError = _errors_js__WEBPACK_IMPORTED_MODULE_2__.UnknownError.fromCode(new _errors_js__WEBPACK_IMPORTED_MODULE_2__.UnexpectedErrorCode(error));\n            }\n            this.log.error(`Error while making query: ${queryError.message}`, queryError);\n            throw queryError;\n        }\n    }\n    /**\n     * See https://internetcomputer.org/docs/current/references/ic-interface-spec/#http-query for details on validation\n     * @param queryResponse - The response from the query\n     * @param subnetStatus - The subnet status, including all node keys\n     * @returns ApiQueryResponse\n     */\n    #verifyQueryResponse;\n    async createReadStateRequest(fields, identity) {\n        await this.#asyncGuard();\n        const id = await (identity ?? this.#identity);\n        if (!id) {\n            throw _errors_js__WEBPACK_IMPORTED_MODULE_2__.ExternalError.fromCode(new _errors_js__WEBPACK_IMPORTED_MODULE_2__.IdentityInvalidErrorCode());\n        }\n        const sender = id.getPrincipal();\n        const transformedRequest = await this._transform({\n            request: {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/cbor',\n                    ...(this.#credentials ? { Authorization: 'Basic ' + btoa(this.#credentials) } : {}),\n                },\n            },\n            endpoint: _types_js__WEBPACK_IMPORTED_MODULE_1__.Endpoint.ReadState,\n            body: {\n                request_type: _types_js__WEBPACK_IMPORTED_MODULE_1__.ReadRequestType.ReadState,\n                paths: fields.paths,\n                sender,\n                ingress_expiry: calculateIngressExpiry(this.#maxIngressExpiryInMinutes, this.#timeDiffMsecs),\n            },\n        });\n        // Apply transform for identity.\n        return id.transformRequest(transformedRequest);\n    }\n    async readState(canisterId, fields, _identity, \n    // eslint-disable-next-line\n    request) {\n        await this.#rootKeyGuard();\n        const canister = _dfinity_principal__WEBPACK_IMPORTED_MODULE_5__.Principal.from(canisterId);\n        function getRequestId(options) {\n            for (const path of options.paths) {\n                const [pathName, value] = path;\n                const request_status = new TextEncoder().encode('request_status');\n                if ((0,_utils_buffer_js__WEBPACK_IMPORTED_MODULE_15__.uint8Equals)(pathName, request_status)) {\n                    return value;\n                }\n            }\n        }\n        let transformedRequest;\n        let requestId;\n        // If a pre-signed request is provided, use it\n        if (request) {\n            // This is a pre-signed request\n            transformedRequest = request;\n            requestId = (0,_request_id_js__WEBPACK_IMPORTED_MODULE_7__.requestIdOf)(transformedRequest);\n        }\n        else {\n            // This is fields, we need to create a request\n            requestId = getRequestId(fields);\n            // Always create a fresh request with the current identity\n            const identity = await this.#identity;\n            if (!identity) {\n                throw _errors_js__WEBPACK_IMPORTED_MODULE_2__.ExternalError.fromCode(new _errors_js__WEBPACK_IMPORTED_MODULE_2__.IdentityInvalidErrorCode());\n            }\n            transformedRequest = await this.createReadStateRequest(fields, identity);\n        }\n        this.log.print(`fetching \"/api/v2/canister/${canister}/read_state\" with request:`, transformedRequest);\n        const backoff = this.#backoffStrategy();\n        try {\n            const { responseBodyBytes } = await this.#requestAndRetry({\n                requestFn: () => this.#fetch('' + new URL(`/api/v2/canister/${canister.toString()}/read_state`, this.host), {\n                    ...this.#fetchOptions,\n                    ...transformedRequest.request,\n                    body: _cbor_js__WEBPACK_IMPORTED_MODULE_14__.encode(transformedRequest.body),\n                }),\n                backoff,\n                tries: 0,\n            });\n            const decodedResponse = _cbor_js__WEBPACK_IMPORTED_MODULE_14__.decode(responseBodyBytes);\n            this.log.print('Read state response:', decodedResponse);\n            return decodedResponse;\n        }\n        catch (error) {\n            let readStateError;\n            if (error instanceof _errors_js__WEBPACK_IMPORTED_MODULE_2__.AgentError) {\n                // override the error code to include the request details\n                error.code.requestContext = {\n                    requestId,\n                    senderPubKey: transformedRequest.body.sender_pubkey,\n                    senderSignature: transformedRequest.body.sender_sig,\n                    ingressExpiry: transformedRequest.body.content.ingress_expiry,\n                };\n                readStateError = error;\n            }\n            else {\n                readStateError = _errors_js__WEBPACK_IMPORTED_MODULE_2__.UnknownError.fromCode(new _errors_js__WEBPACK_IMPORTED_MODULE_2__.UnexpectedErrorCode(error));\n            }\n            this.log.error(`Error while making read state: ${readStateError.message}`, readStateError);\n            throw readStateError;\n        }\n    }\n    parseTimeFromResponse(response) {\n        let tree;\n        if (response.certificate) {\n            const decoded = _cbor_js__WEBPACK_IMPORTED_MODULE_14__.decode(response.certificate);\n            if (decoded && 'tree' in decoded) {\n                tree = decoded.tree;\n            }\n            else {\n                throw _errors_js__WEBPACK_IMPORTED_MODULE_2__.ProtocolError.fromCode(new _errors_js__WEBPACK_IMPORTED_MODULE_2__.HashTreeDecodeErrorCode('Could not decode time from response'));\n            }\n            const timeLookup = (0,_certificate_js__WEBPACK_IMPORTED_MODULE_16__.lookup_path)(['time'], tree);\n            if (timeLookup.status !== _certificate_js__WEBPACK_IMPORTED_MODULE_16__.LookupPathStatus.Found) {\n                throw _errors_js__WEBPACK_IMPORTED_MODULE_2__.ProtocolError.fromCode(new _errors_js__WEBPACK_IMPORTED_MODULE_2__.LookupErrorCode('Time was not found in the response or was not in its expected format.', timeLookup.status));\n            }\n            if (!(timeLookup.value instanceof Uint8Array) && !ArrayBuffer.isView(timeLookup)) {\n                throw _errors_js__WEBPACK_IMPORTED_MODULE_2__.ProtocolError.fromCode(new _errors_js__WEBPACK_IMPORTED_MODULE_2__.MalformedLookupFoundValueErrorCode('Time was not in its expected format.'));\n            }\n            const date = (0,_utils_leb_js__WEBPACK_IMPORTED_MODULE_17__.decodeTime)(timeLookup.value);\n            this.log.print('Time from response:', date);\n            this.log.print('Time from response in milliseconds:', date.getTime());\n            return date.getTime();\n        }\n        else {\n            this.log.warn('No certificate found in response');\n        }\n        return 0;\n    }\n    /**\n     * Allows agent to sync its time with the network. Can be called during intialization or mid-lifecycle if the device's clock has drifted away from the network time. This is necessary to set the Expiry for a request\n     * @param {Principal} canisterIdOverride - Pass a canister ID if you need to sync the time with a particular subnet. Uses the ICP ledger canister by default.\n     */\n    async syncTime(canisterIdOverride) {\n        this.#syncTimePromise =\n            this.#syncTimePromise ??\n                (async () => {\n                    await this.#rootKeyGuard();\n                    const callTime = Date.now();\n                    try {\n                        if (!canisterIdOverride) {\n                            this.log.print('Syncing time with the IC. No canisterId provided, so falling back to ryjl3-tyaaa-aaaaa-aaaba-cai');\n                        }\n                        // Fall back with canisterId of the ICP Ledger\n                        const canisterId = canisterIdOverride ?? _dfinity_principal__WEBPACK_IMPORTED_MODULE_5__.Principal.from('ryjl3-tyaaa-aaaaa-aaaba-cai');\n                        const anonymousAgent = HttpAgent.createSync({\n                            identity: new _auth_js__WEBPACK_IMPORTED_MODULE_13__.AnonymousIdentity(),\n                            host: this.host.toString(),\n                            fetch: this.#fetch,\n                            retryTimes: 0,\n                            rootKey: this.rootKey ?? undefined,\n                            shouldSyncTime: false,\n                        });\n                        const replicaTimes = await Promise.all(Array(3)\n                            .fill(null)\n                            .map(async () => {\n                            const status = await (0,_canisterStatus_index_js__WEBPACK_IMPORTED_MODULE_18__.request)({\n                                canisterId,\n                                agent: anonymousAgent,\n                                paths: ['time'],\n                                disableCertificateTimeVerification: true, // avoid recursive calls to syncTime\n                            });\n                            const date = status.get('time');\n                            if (date instanceof Date) {\n                                return date.getTime();\n                            }\n                        }, []));\n                        const maxReplicaTime = replicaTimes.reduce((max, current) => {\n                            return typeof current === 'number' && current > max ? current : max;\n                        }, 0);\n                        if (maxReplicaTime > 0) {\n                            this.#timeDiffMsecs = maxReplicaTime - callTime;\n                            this.#hasSyncedTime = true;\n                            this.log.notify({\n                                message: `Syncing time: offset of ${this.#timeDiffMsecs}`,\n                                level: 'info',\n                            });\n                        }\n                    }\n                    catch (error) {\n                        const syncTimeError = error instanceof _errors_js__WEBPACK_IMPORTED_MODULE_2__.AgentError\n                            ? error\n                            : _errors_js__WEBPACK_IMPORTED_MODULE_2__.UnknownError.fromCode(new _errors_js__WEBPACK_IMPORTED_MODULE_2__.UnexpectedErrorCode(error));\n                        this.log.error('Caught exception while attempting to sync time', syncTimeError);\n                        throw syncTimeError;\n                    }\n                })();\n        await this.#syncTimePromise.finally(() => {\n            this.#syncTimePromise = null;\n        });\n    }\n    async status() {\n        const headers = this.#credentials\n            ? {\n                Authorization: 'Basic ' + btoa(this.#credentials),\n            }\n            : {};\n        this.log.print(`fetching \"/api/v2/status\"`);\n        const backoff = this.#backoffStrategy();\n        const { responseBodyBytes } = await this.#requestAndRetry({\n            backoff,\n            requestFn: () => this.#fetch('' + new URL(`/api/v2/status`, this.host), { headers, ...this.#fetchOptions }),\n            tries: 0,\n        });\n        return _cbor_js__WEBPACK_IMPORTED_MODULE_14__.decode(responseBodyBytes);\n    }\n    async fetchRootKey() {\n        // Wait for already pending promise to avoid duplicate calls\n        this.#rootKeyPromise =\n            this.#rootKeyPromise ??\n                (async () => {\n                    const value = await this.status();\n                    // Hex-encoded version of the replica root key\n                    this.rootKey = value.root_key;\n                    return this.rootKey;\n                })();\n        // clear rootkey promise and return result\n        return await this.#rootKeyPromise.finally(() => {\n            this.#rootKeyPromise = null;\n        });\n    }\n    async #asyncGuard(canisterIdOverride) {\n        await Promise.all([this.#rootKeyGuard(), this.#syncTimeGuard(canisterIdOverride)]);\n    }\n    async #rootKeyGuard() {\n        if (this.rootKey) {\n            return;\n        }\n        else if (this.rootKey === null &&\n            this.host.toString() !== 'https://icp-api.io' &&\n            this.#shouldFetchRootKey) {\n            await this.fetchRootKey();\n        }\n        else {\n            throw _errors_js__WEBPACK_IMPORTED_MODULE_2__.ExternalError.fromCode(new _errors_js__WEBPACK_IMPORTED_MODULE_2__.MissingRootKeyErrorCode(this.#shouldFetchRootKey));\n        }\n    }\n    async #syncTimeGuard(canisterIdOverride) {\n        if (this.#shouldSyncTime && !this.hasSyncedTime()) {\n            await this.syncTime(canisterIdOverride);\n        }\n    }\n    invalidateIdentity() {\n        this.#identity = null;\n    }\n    replaceIdentity(identity) {\n        this.#identity = Promise.resolve(identity);\n    }\n    async fetchSubnetKeys(canisterId) {\n        const effectiveCanisterId = _dfinity_principal__WEBPACK_IMPORTED_MODULE_5__.Principal.from(canisterId);\n        await this.#asyncGuard(effectiveCanisterId);\n        const response = await (0,_canisterStatus_index_js__WEBPACK_IMPORTED_MODULE_18__.request)({\n            canisterId: effectiveCanisterId,\n            paths: ['subnet'],\n            agent: this,\n        });\n        const subnetResponse = response.get('subnet');\n        if (subnetResponse && typeof subnetResponse === 'object' && 'nodeKeys' in subnetResponse) {\n            this.#subnetKeys.set(effectiveCanisterId.toText(), subnetResponse);\n            return subnetResponse;\n        }\n        // If the subnet status is not returned, return undefined\n        return undefined;\n    }\n    _transform(request) {\n        let p = Promise.resolve(request);\n        if (request.endpoint === _types_js__WEBPACK_IMPORTED_MODULE_1__.Endpoint.Call) {\n            for (const fn of this.#updatePipeline) {\n                p = p.then(r => fn(r).then(r2 => r2 || r));\n            }\n        }\n        else {\n            for (const fn of this.#queryPipeline) {\n                p = p.then(r => fn(r).then(r2 => r2 || r));\n            }\n        }\n        return p;\n    }\n    /**\n     * Returns the time difference in milliseconds between the IC network clock and the client's clock,\n     * after the clock has been synced.\n     *\n     * If the time has not been synced, returns `0`.\n     */\n    getTimeDiffMsecs() {\n        return this.#timeDiffMsecs;\n    }\n    /**\n     * Returns `true` if the time has been synced at least once with the IC network, `false` otherwise.\n     */\n    hasSyncedTime() {\n        return this.#hasSyncedTime;\n    }\n}\n/**\n * Calculates the ingress expiry time based on the maximum allowed expiry in minutes and the time difference in milliseconds.\n * The expiry is rounded down according to the {@link Expiry.fromDeltaInMilliseconds} method.\n * @param maxIngressExpiryInMinutes - The maximum ingress expiry time in minutes.\n * @param timeDiffMsecs - The time difference in milliseconds to adjust the expiry.\n * @returns The calculated ingress expiry as an Expiry object.\n */\nfunction calculateIngressExpiry(maxIngressExpiryInMinutes, timeDiffMsecs) {\n    const ingressExpiryMs = maxIngressExpiryInMinutes * MINUTE_TO_MSECS;\n    return _transforms_js__WEBPACK_IMPORTED_MODULE_0__.Expiry.fromDeltaInMilliseconds(ingressExpiryMs, timeDiffMsecs);\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vcGFja2FnZXMvc2RrLWpzL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL2FnZW50L2h0dHAvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQStDO0FBQ2trQjtBQUMvakI7QUFDWjtBQUN1QjtBQUNaO0FBQ2tDO0FBQ0c7QUFDTDtBQUNaO0FBQ3JCO0FBQ1c7QUFDSjtBQUNIO0FBQ1c7QUFDZjtBQUNjO0FBQ1E7QUFDSjtBQUNsQztBQUNPO0FBQ2hDO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGtFQUFrRTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IscURBQWEsY0FBYyxpRUFBeUI7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixxREFBYSxjQUFjLGlFQUF5QjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUscURBQWEsY0FBYyxpRUFBeUI7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0JBQWtCLElBQUksVUFBVSxFQUFFLHlDQUF5QztBQUN6RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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d2VicGFjazovL0BpcXViZS9vcHMtY29uc29sZS8uLi8uLi9wYWNrYWdlcy9zZGstanMvbm9kZV9tb2R1bGVzL0BkZmluaXR5L2FnZW50L2xpYi9lc20vYWdlbnQvaHR0cC9pbmRleC5qcz8xOGEyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFByaW5jaXBhbCB9IGZyb20gJ0BkZmluaXR5L3ByaW5jaXBhbCc7XG5pbXBvcnQgeyBIYXNoVHJlZURlY29kZUVycm9yQ29kZSwgQ3JlYXRlSHR0cEFnZW50RXJyb3JDb2RlLCBFeHRlcm5hbEVycm9yLCBIdHRwRGVmYXVsdEZldGNoRXJyb3JDb2RlLCBJZGVudGl0eUludmFsaWRFcnJvckNvZGUsIEluZ3Jlc3NFeHBpcnlJbnZhbGlkRXJyb3JDb2RlLCBJbnB1dEVycm9yLCBMb29rdXBFcnJvckNvZGUsIE1hbGZvcm1lZFB1YmxpY0tleUVycm9yQ29kZSwgTWFsZm9ybWVkU2lnbmF0dXJlRXJyb3JDb2RlLCBNaXNzaW5nUm9vdEtleUVycm9yQ29kZSwgTWlzc2luZ1NpZ25hdHVyZUVycm9yQ29kZSwgUHJvdG9jb2xFcnJvciwgUXVlcnlTaWduYXR1cmVWZXJpZmljYXRpb25GYWlsZWRFcnJvckNvZGUsIFRpbWVvdXRXYWl0aW5nRm9yUmVzcG9uc2VFcnJvckNvZGUsIFRydXN0RXJyb3IsIFVuZXhwZWN0ZWRFcnJvckNvZGUsIFVua25vd25FcnJvciwgSHR0cEVycm9yQ29kZSwgSHR0cFYzQXBpTm90U3VwcG9ydGVkRXJyb3JDb2RlLCBUcmFuc3BvcnRFcnJvciwgSHR0cEZldGNoRXJyb3JDb2RlLCBBZ2VudEVycm9yLCBNYWxmb3JtZWRMb29rdXBGb3VuZFZhbHVlRXJyb3JDb2RlLCBDZXJ0aWZpY2F0ZU91dGRhdGVkRXJyb3JDb2RlLCB9IGZyb20gXCIuLi8uLi9lcnJvcnMuanNcIjtcbmltcG9ydCB7IEFub255bW91c0lkZW50aXR5IH0gZnJvbSBcIi4uLy4uL2F1dGguanNcIjtcbmltcG9ydCAqIGFzIGNib3IgZnJvbSBcIi4uLy4uL2Nib3IuanNcIjtcbmltcG9ydCB7IGhhc2hPZk1hcCwgcmVxdWVzdElkT2YgfSBmcm9tIFwiLi4vLi4vcmVxdWVzdF9pZC5qc1wiO1xuaW1wb3J0IHsgUXVlcnlSZXNwb25zZVN0YXR1cywgfSBmcm9tIFwiLi4vYXBpLmpzXCI7XG5pbXBvcnQgeyBFeHBpcnksIGh0dHBIZWFkZXJzVHJhbnNmb3JtLCBtYWtlTm9uY2VUcmFuc2Zvcm0gfSBmcm9tIFwiLi90cmFuc2Zvcm1zLmpzXCI7XG5pbXBvcnQgeyBFbmRwb2ludCwgbWFrZU5vbmNlLCBSZWFkUmVxdWVzdFR5cGUsIFN1Ym1pdFJlcXVlc3RUeXBlLCB9IGZyb20gXCIuL3R5cGVzLmpzXCI7XG5pbXBvcnQgeyByZXF1ZXN0IGFzIGNhbmlzdGVyU3RhdHVzUmVxdWVzdCB9IGZyb20gXCIuLi8uLi9jYW5pc3RlclN0YXR1cy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgbG9va3VwX3BhdGgsIExvb2t1cFBhdGhTdGF0dXMgfSBmcm9tIFwiLi4vLi4vY2VydGlmaWNhdGUuanNcIjtcbmltcG9ydCB7IGVkMjU1MTkgfSBmcm9tICdAbm9ibGUvY3VydmVzL2VkMjU1MTknO1xuaW1wb3J0IHsgRXhwaXJhYmxlTWFwIH0gZnJvbSBcIi4uLy4uL3V0aWxzL2V4cGlyYWJsZU1hcC5qc1wiO1xuaW1wb3J0IHsgRWQyNTUxOVB1YmxpY0tleSB9IGZyb20gXCIuLi8uLi9wdWJsaWNfa2V5LmpzXCI7XG5pbXBvcnQgeyBPYnNlcnZhYmxlTG9nIH0gZnJvbSBcIi4uLy4uL29ic2VydmFibGUuanNcIjtcbmltcG9ydCB7IEV4cG9uZW50aWFsQmFja29mZiwgfSBmcm9tIFwiLi4vLi4vcG9sbGluZy9iYWNrb2ZmLmpzXCI7XG5pbXBvcnQgeyBkZWNvZGVUaW1lIH0gZnJvbSBcIi4uLy4uL3V0aWxzL2xlYi5qc1wiO1xuaW1wb3J0IHsgY29uY2F0Qnl0ZXMsIGhleFRvQnl0ZXMgfSBmcm9tICdAbm9ibGUvaGFzaGVzL3V0aWxzJztcbmltcG9ydCB7IHVpbnQ4RXF1YWxzLCB1aW50OEZyb21CdWZMaWtlIH0gZnJvbSBcIi4uLy4uL3V0aWxzL2J1ZmZlci5qc1wiO1xuaW1wb3J0IHsgSUNfUkVTUE9OU0VfRE9NQUlOX1NFUEFSQVRPUiB9IGZyb20gXCIuLi8uLi9jb25zdGFudHMuanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL3RyYW5zZm9ybXMuanNcIjtcbmV4cG9ydCB7IG1ha2VOb25jZSB9IGZyb20gXCIuL3R5cGVzLmpzXCI7XG5leHBvcnQgdmFyIFJlcXVlc3RTdGF0dXNSZXNwb25zZVN0YXR1cztcbihmdW5jdGlvbiAoUmVxdWVzdFN0YXR1c1Jlc3BvbnNlU3RhdHVzKSB7XG4gICAgUmVxdWVzdFN0YXR1c1Jlc3BvbnNlU3RhdHVzW1wiUmVjZWl2ZWRcIl0gPSBcInJlY2VpdmVkXCI7XG4gICAgUmVxdWVzdFN0YXR1c1Jlc3BvbnNlU3RhdHVzW1wiUHJvY2Vzc2luZ1wiXSA9IFwicHJvY2Vzc2luZ1wiO1xuICAgIFJlcXVlc3RTdGF0dXNSZXNwb25zZVN0YXR1c1tcIlJlcGxpZWRcIl0gPSBcInJlcGxpZWRcIjtcbiAgICBSZXF1ZXN0U3RhdHVzUmVzcG9uc2VTdGF0dXNbXCJSZWplY3RlZFwiXSA9IFwicmVqZWN0ZWRcIjtcbiAgICBSZXF1ZXN0U3RhdHVzUmVzcG9uc2VTdGF0dXNbXCJVbmtub3duXCJdID0gXCJ1bmtub3duXCI7XG4gICAgUmVxdWVzdFN0YXR1c1Jlc3BvbnNlU3RhdHVzW1wiRG9uZVwiXSA9IFwiZG9uZVwiO1xufSkoUmVxdWVzdFN0YXR1c1Jlc3BvbnNlU3RhdHVzIHx8IChSZXF1ZXN0U3RhdHVzUmVzcG9uc2VTdGF0dXMgPSB7fSkpO1xuY29uc3QgTUlOVVRFX1RPX01TRUNTID0gNjAgKiAxXzAwMDtcbmNvbnN0IE1TRUNTX1RPX05BTk9TRUNPTkRTID0gMV8wMDBfMDAwO1xuY29uc3QgREVGQVVMVF9USU1FX0RJRkZfTVNFQ1MgPSAwO1xuLy8gUm9vdCBwdWJsaWMga2V5IGZvciB0aGUgSUMsIGVuY29kZWQgYXMgaGV4XG5leHBvcnQgY29uc3QgSUNfUk9PVF9LRVkgPSAnMzA4MTgyMzAxZDA2MGQyYjA2MDEwNDAxODJkYzdjMDUwMzAxMDIwMTA2MGMyYjA2MDEwNDAxODJkYzdjMDUwMzAyMDEwMzYxMDA4MTQnICtcbiAgICAnYzBlNmVjNzFmYWI1ODNiMDhiZDgxMzczYzI1NWMzYzM3MWIyZTg0ODYzYzk4YTRmMWUwOGI3NDIzNWQxNGZiNWQ5YzBjZDU0NmQ5NjgnICtcbiAgICAnNWY5MTNhMGMwYjJjYzUzNDE1ODNiZjRiNDM5MmU0NjdkYjk2ZDY1YjliYjRjYjcxNzExMmY4NDcyZTBkNWE0ZDE0NTA1ZmZkNzQ4NCcgK1xuICAgICdiMDEyOTEwOTFjNWY4N2I5ODg4MzQ2M2Y5ODA5MWEwYmFhYWUnO1xuZXhwb3J0IGNvbnN0IE1BTkFHRU1FTlRfQ0FOSVNURVJfSUQgPSAnYWFhYWEtYWEnO1xuLy8gSUMwIGRvbWFpbiBpbmZvXG5jb25zdCBJQzBfRE9NQUlOID0gJ2ljMC5hcHAnO1xuY29uc3QgSUMwX1NVQl9ET01BSU4gPSAnLmljMC5hcHAnO1xuY29uc3QgSUNQMF9ET01BSU4gPSAnaWNwMC5pbyc7XG5jb25zdCBJQ1AwX1NVQl9ET01BSU4gPSAnLmljcDAuaW8nO1xuY29uc3QgSUNQX0FQSV9ET01BSU4gPSAnaWNwLWFwaS5pbyc7XG5jb25zdCBJQ1BfQVBJX1NVQl9ET01BSU4gPSAnLmljcC1hcGkuaW8nO1xuY29uc3QgSFRUUF9TVEFUVVNfT0sgPSAyMDA7XG5jb25zdCBIVFRQX1NUQVRVU19BQ0NFUFRFRCA9IDIwMjtcbmNvbnN0IEhUVFBfU1RBVFVTX05PVF9GT1VORCA9IDQwNDtcbmZ1bmN0aW9uIGdldERlZmF1bHRGZXRjaCgpIHtcbiAgICBsZXQgZGVmYXVsdEZldGNoO1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAvLyBCcm93c2VyIGNvbnRleHRcbiAgICAgICAgaWYgKHdpbmRvdy5mZXRjaCkge1xuICAgICAgICAgICAgZGVmYXVsdEZldGNoID0gd2luZG93LmZldGNoLmJpbmQod2luZG93KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IEV4dGVybmFsRXJyb3IuZnJvbUNvZGUobmV3IEh0dHBEZWZhdWx0RmV0Y2hFcnJvckNvZGUoJ0ZldGNoIGltcGxlbWVudGF0aW9uIHdhcyBub3QgYXZhaWxhYmxlLiBZb3UgYXBwZWFyIHRvIGJlIGluIGEgYnJvd3NlciBjb250ZXh0LCBidXQgd2luZG93LmZldGNoIHdhcyBub3QgcHJlc2VudC4nKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgLy8gTm9kZSBjb250ZXh0XG4gICAgICAgIGlmIChnbG9iYWwuZmV0Y2gpIHtcbiAgICAgICAgICAgIGRlZmF1bHRGZXRjaCA9IGdsb2JhbC5mZXRjaC5iaW5kKGdsb2JhbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBFeHRlcm5hbEVycm9yLmZyb21Db2RlKG5ldyBIdHRwRGVmYXVsdEZldGNoRXJyb3JDb2RlKCdGZXRjaCBpbXBsZW1lbnRhdGlvbiB3YXMgbm90IGF2YWlsYWJsZS4gWW91IGFwcGVhciB0byBiZSBpbiBhIE5vZGUuanMgY29udGV4dCwgYnV0IGdsb2JhbC5mZXRjaCB3YXMgbm90IGF2YWlsYWJsZS4nKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGlmIChzZWxmLmZldGNoKSB7XG4gICAgICAgICAgICBkZWZhdWx0RmV0Y2ggPSBzZWxmLmZldGNoLmJpbmQoc2VsZik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGRlZmF1bHRGZXRjaCkge1xuICAgICAgICByZXR1cm4gZGVmYXVsdEZldGNoO1xuICAgIH1cbiAgICB0aHJvdyBFeHRlcm5hbEVycm9yLmZyb21Db2RlKG5ldyBIdHRwRGVmYXVsdEZldGNoRXJyb3JDb2RlKCdGZXRjaCBpbXBsZW1lbnRhdGlvbiB3YXMgbm90IGF2YWlsYWJsZS4gUGxlYXNlIHByb3ZpZGUgZmV0Y2ggdG8gdGhlIEh0dHBBZ2VudCBjb25zdHJ1Y3Rvciwgb3IgZW5zdXJlIGl0IGlzIGF2YWlsYWJsZSBpbiB0aGUgd2luZG93IG9yIGdsb2JhbCBjb250ZXh0LicpKTtcbn1cbmZ1bmN0aW9uIGRldGVybWluZUhvc3QoY29uZmlndXJlZEhvc3QpIHtcbiAgICBsZXQgaG9zdDtcbiAgICBpZiAoY29uZmlndXJlZEhvc3QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoIWNvbmZpZ3VyZWRIb3N0Lm1hdGNoKC9eW2Etel0rOi8pICYmIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBob3N0ID0gbmV3IFVSTCh3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wgKyAnLy8nICsgY29uZmlndXJlZEhvc3QpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaG9zdCA9IG5ldyBVUkwoY29uZmlndXJlZEhvc3QpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBNYWlubmV0LCBsb2NhbCwgYW5kIHJlbW90ZSBlbnZpcm9ubWVudHMgd2lsbCBoYXZlIHRoZSBhcGkgcm91dGUgYXZhaWxhYmxlXG4gICAgICAgIGNvbnN0IGtub3duSG9zdHMgPSBbJ2ljMC5hcHAnLCAnaWNwMC5pbycsICcxMjcuMC4wLjEnLCAnbG9jYWxob3N0J107XG4gICAgICAgIGNvbnN0IHJlbW90ZUhvc3RzID0gWycuZ2l0aHViLmRldicsICcuZ2l0cG9kLmlvJ107XG4gICAgICAgIGNvbnN0IGxvY2F0aW9uID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cubG9jYXRpb24gOiB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IGhvc3RuYW1lID0gbG9jYXRpb24/Lmhvc3RuYW1lO1xuICAgICAgICBsZXQga25vd25Ib3N0O1xuICAgICAgICBpZiAoaG9zdG5hbWUgJiYgdHlwZW9mIGhvc3RuYW1lID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWYgKHJlbW90ZUhvc3RzLnNvbWUoaG9zdCA9PiBob3N0bmFtZS5lbmRzV2l0aChob3N0KSkpIHtcbiAgICAgICAgICAgICAgICBrbm93bkhvc3QgPSBob3N0bmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGtub3duSG9zdCA9IGtub3duSG9zdHMuZmluZChob3N0ID0+IGhvc3RuYW1lLmVuZHNXaXRoKGhvc3QpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobG9jYXRpb24gJiYga25vd25Ib3N0KSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgdXNlciBpcyBvbiBhIGJvdW5kYXJ5LW5vZGUgcHJvdmlkZWQgaG9zdCwgd2UgY2FuIHVzZSB0aGUgc2FtZSBob3N0IGZvciB0aGUgYWdlbnRcbiAgICAgICAgICAgIGhvc3QgPSBuZXcgVVJMKGAke2xvY2F0aW9uLnByb3RvY29sfS8vJHtrbm93bkhvc3R9JHtsb2NhdGlvbi5wb3J0ID8gJzonICsgbG9jYXRpb24ucG9ydCA6ICcnfWApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaG9zdCA9IG5ldyBVUkwoJ2h0dHBzOi8vaWNwLWFwaS5pbycpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBob3N0LnRvU3RyaW5nKCk7XG59XG4vKipcbiAqIEEgSFRUUCBhZ2VudCBhbGxvd3MgdXNlcnMgdG8gaW50ZXJhY3Qgd2l0aCBhIGNsaWVudCBvZiB0aGUgaW50ZXJuZXQgY29tcHV0ZXJcbnVzaW5nIHRoZSBhdmFpbGFibGUgbWV0aG9kcy4gSXQgZXhwb3NlcyBhbiBBUEkgdGhhdCBjbG9zZWx5IGZvbGxvd3MgdGhlXG5wdWJsaWMgdmlldyBvZiB0aGUgaW50ZXJuZXQgY29tcHV0ZXIsIGFuZCBpcyBub3QgaW50ZW5kZWQgdG8gYmUgZXhwb3NlZFxuZGlyZWN0bHkgdG8gdGhlIG1ham9yaXR5IG9mIHVzZXJzIGR1ZSB0byBpdHMgbG93LWxldmVsIGludGVyZmFjZS5cbiAqIFRoZXJlIGlzIGEgcGlwZWxpbmUgdG8gYXBwbHkgdHJhbnNmb3JtYXRpb25zIHRvIHRoZSByZXF1ZXN0IGJlZm9yZSBzZW5kaW5nXG5pdCB0byB0aGUgY2xpZW50LiBUaGlzIGlzIHRvIGRlY291cGxlIHNpZ25hdHVyZSwgbm9uY2UgZ2VuZXJhdGlvbiBhbmRcbm90aGVyIGNvbXB1dGF0aW9ucyBzbyB0aGF0IHRoaXMgY2xhc3MgY2FuIHN0YXkgYXMgc2ltcGxlIGFzIHBvc3NpYmxlIHdoaWxlXG5hbGxvd2luZyBleHRlbnNpb25zLlxuICovXG5leHBvcnQgY2xhc3MgSHR0cEFnZW50IHtcbiAgICAjcm9vdEtleVByb21pc2U7XG4gICAgI3Nob3VsZEZldGNoUm9vdEtleTtcbiAgICAjdGltZURpZmZNc2VjcztcbiAgICAjaGFzU3luY2VkVGltZTtcbiAgICAjc3luY1RpbWVQcm9taXNlO1xuICAgICNzaG91bGRTeW5jVGltZTtcbiAgICAjaWRlbnRpdHk7XG4gICAgI2ZldGNoO1xuICAgICNmZXRjaE9wdGlvbnM7XG4gICAgI2NhbGxPcHRpb25zO1xuICAgICNjcmVkZW50aWFscztcbiAgICAjcmV0cnlUaW1lczsgLy8gUmV0cnkgcmVxdWVzdHMgTiB0aW1lcyBiZWZvcmUgZXJyb3JpbmcgYnkgZGVmYXVsdFxuICAgICNiYWNrb2ZmU3RyYXRlZ3k7XG4gICAgI21heEluZ3Jlc3NFeHBpcnlJbk1pbnV0ZXM7XG4gICAgZ2V0ICNtYXhJbmdyZXNzRXhwaXJ5SW5NcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI21heEluZ3Jlc3NFeHBpcnlJbk1pbnV0ZXMgKiBNSU5VVEVfVE9fTVNFQ1M7XG4gICAgfVxuICAgICNxdWVyeVBpcGVsaW5lO1xuICAgICN1cGRhdGVQaXBlbGluZTtcbiAgICAjc3VibmV0S2V5cztcbiAgICAjdmVyaWZ5UXVlcnlTaWduYXR1cmVzO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyBmb3IgdGhlIEh0dHBBZ2VudFxuICAgICAqIEBkZXByZWNhdGVkIFVzZSBgSHR0cEFnZW50LmNyZWF0ZWAgb3IgYEh0dHBBZ2VudC5jcmVhdGVTeW5jYCBpbnN0ZWFkXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHRoaXMuI3Jvb3RLZXlQcm9taXNlID0gbnVsbDtcbiAgICAgICAgdGhpcy4jc2hvdWxkRmV0Y2hSb290S2V5ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuI3RpbWVEaWZmTXNlY3MgPSBERUZBVUxUX1RJTUVfRElGRl9NU0VDUztcbiAgICAgICAgdGhpcy4jaGFzU3luY2VkVGltZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLiNzeW5jVGltZVByb21pc2UgPSBudWxsO1xuICAgICAgICB0aGlzLiNzaG91bGRTeW5jVGltZSA9IGZhbHNlO1xuICAgICAgICAvLyBQdWJsaWMgc2lnbmF0dXJlIHRvIGhlbHAgd2l0aCB0eXBlIGNoZWNraW5nLlxuICAgICAgICB0aGlzLl9pc0FnZW50ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jb25maWcgPSB7fTtcbiAgICAgICAgdGhpcy5sb2cgPSBuZXcgT2JzZXJ2YWJsZUxvZygpO1xuICAgICAgICB0aGlzLiNxdWVyeVBpcGVsaW5lID0gW107XG4gICAgICAgIHRoaXMuI3VwZGF0ZVBpcGVsaW5lID0gW107XG4gICAgICAgIHRoaXMuI3N1Ym5ldEtleXMgPSBuZXcgRXhwaXJhYmxlTWFwKHtcbiAgICAgICAgICAgIGV4cGlyYXRpb25UaW1lOiA1ICogTUlOVVRFX1RPX01TRUNTLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy4jdmVyaWZ5UXVlcnlTaWduYXR1cmVzID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNlZSBodHRwczovL2ludGVybmV0Y29tcHV0ZXIub3JnL2RvY3MvY3VycmVudC9yZWZlcmVuY2VzL2ljLWludGVyZmFjZS1zcGVjLyNodHRwLXF1ZXJ5IGZvciBkZXRhaWxzIG9uIHZhbGlkYXRpb25cbiAgICAgICAgICogQHBhcmFtIHF1ZXJ5UmVzcG9uc2UgLSBUaGUgcmVzcG9uc2UgZnJvbSB0aGUgcXVlcnlcbiAgICAgICAgICogQHBhcmFtIHN1Ym5ldFN0YXR1cyAtIFRoZSBzdWJuZXQgc3RhdHVzLCBpbmNsdWRpbmcgYWxsIG5vZGUga2V5c1xuICAgICAgICAgKiBAcmV0dXJucyBBcGlRdWVyeVJlc3BvbnNlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLiN2ZXJpZnlRdWVyeVJlc3BvbnNlID0gKHF1ZXJ5UmVzcG9uc2UsIHN1Ym5ldFN0YXR1cykgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuI3ZlcmlmeVF1ZXJ5U2lnbmF0dXJlcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIHNob3VsZCBub3QgYmUgY2FsbGVkIGlmIHRoZSB1c2VyIGhhcyBkaXNhYmxlZCB2ZXJpZmljYXRpb25cbiAgICAgICAgICAgICAgICByZXR1cm4gcXVlcnlSZXNwb25zZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgc3RhdHVzLCBzaWduYXR1cmVzID0gW10sIHJlcXVlc3RJZCB9ID0gcXVlcnlSZXNwb25zZTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgc2lnIG9mIHNpZ25hdHVyZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHRpbWVzdGFtcCwgaWRlbnRpdHkgfSA9IHNpZztcbiAgICAgICAgICAgICAgICBjb25zdCBub2RlSWQgPSBQcmluY2lwYWwuZnJvbVVpbnQ4QXJyYXkoaWRlbnRpdHkpLnRvVGV4dCgpO1xuICAgICAgICAgICAgICAgIC8vIEhhc2ggaXMgY29uc3RydWN0ZWQgZGlmZmVyZW50bHkgZGVwZW5kaW5nIG9uIHRoZSBzdGF0dXNcbiAgICAgICAgICAgICAgICBsZXQgaGFzaDtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzID09PSBRdWVyeVJlc3BvbnNlU3RhdHVzLlJlcGxpZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyByZXBseSB9ID0gcXVlcnlSZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgaGFzaCA9IGhhc2hPZk1hcCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IHN0YXR1cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcGx5OiByZXBseSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogQmlnSW50KHRpbWVzdGFtcCksXG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0X2lkOiByZXF1ZXN0SWQsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzdGF0dXMgPT09IFF1ZXJ5UmVzcG9uc2VTdGF0dXMuUmVqZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyByZWplY3RfY29kZSwgcmVqZWN0X21lc3NhZ2UsIGVycm9yX2NvZGUgfSA9IHF1ZXJ5UmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIGhhc2ggPSBoYXNoT2ZNYXAoe1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBzdGF0dXMsXG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3RfY29kZTogcmVqZWN0X2NvZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3RfbWVzc2FnZTogcmVqZWN0X21lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcl9jb2RlOiBlcnJvcl9jb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZXN0YW1wOiBCaWdJbnQodGltZXN0YW1wKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RfaWQ6IHJlcXVlc3RJZCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBVbmtub3duRXJyb3IuZnJvbUNvZGUobmV3IFVuZXhwZWN0ZWRFcnJvckNvZGUoYFVua25vd24gc3RhdHVzOiAke3N0YXR1c31gKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHNlcGFyYXRvcldpdGhIYXNoID0gY29uY2F0Qnl0ZXMoSUNfUkVTUE9OU0VfRE9NQUlOX1NFUEFSQVRPUiwgaGFzaCk7XG4gICAgICAgICAgICAgICAgLy8gRklYOiBjaGVjayBmb3IgbWF0Y2ggd2l0aG91dCB2ZXJpZnlpbmcgTiB0aW1lc1xuICAgICAgICAgICAgICAgIGNvbnN0IHB1YktleSA9IHN1Ym5ldFN0YXR1cy5ub2RlS2V5cy5nZXQobm9kZUlkKTtcbiAgICAgICAgICAgICAgICBpZiAoIXB1YktleSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBQcm90b2NvbEVycm9yLmZyb21Db2RlKG5ldyBNYWxmb3JtZWRQdWJsaWNLZXlFcnJvckNvZGUoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHJhd0tleSA9IEVkMjU1MTlQdWJsaWNLZXkuZnJvbURlcihwdWJLZXkpLnJhd0tleTtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWxpZCA9IGVkMjU1MTkudmVyaWZ5KHNpZy5zaWduYXR1cmUsIHNlcGFyYXRvcldpdGhIYXNoLCByYXdLZXkpO1xuICAgICAgICAgICAgICAgIGlmICh2YWxpZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHF1ZXJ5UmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgdGhyb3cgVHJ1c3RFcnJvci5mcm9tQ29kZShuZXcgUXVlcnlTaWduYXR1cmVWZXJpZmljYXRpb25GYWlsZWRFcnJvckNvZGUobm9kZUlkKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcXVlcnlSZXNwb25zZTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jb25maWcgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLiNmZXRjaCA9IG9wdGlvbnMuZmV0Y2ggfHwgZ2V0RGVmYXVsdEZldGNoKCkgfHwgZmV0Y2guYmluZChnbG9iYWwpO1xuICAgICAgICB0aGlzLiNmZXRjaE9wdGlvbnMgPSBvcHRpb25zLmZldGNoT3B0aW9ucztcbiAgICAgICAgdGhpcy4jY2FsbE9wdGlvbnMgPSBvcHRpb25zLmNhbGxPcHRpb25zO1xuICAgICAgICB0aGlzLiNzaG91bGRGZXRjaFJvb3RLZXkgPSBvcHRpb25zLnNob3VsZEZldGNoUm9vdEtleSA/PyBmYWxzZTtcbiAgICAgICAgdGhpcy4jc2hvdWxkU3luY1RpbWUgPSBvcHRpb25zLnNob3VsZFN5bmNUaW1lID8/IGZhbHNlO1xuICAgICAgICAvLyBVc2UgcHJvdmlkZWQgcm9vdCBrZXksIG90aGVyd2lzZSBmYWxsIGJhY2sgdG8gSUNfUk9PVF9LRVkgZm9yIG1haW5uZXQgb3IgbnVsbCBpZiB0aGUga2V5IG5lZWRzIHRvIGJlIGZldGNoZWRcbiAgICAgICAgaWYgKG9wdGlvbnMucm9vdEtleSkge1xuICAgICAgICAgICAgdGhpcy5yb290S2V5ID0gb3B0aW9ucy5yb290S2V5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuI3Nob3VsZEZldGNoUm9vdEtleSkge1xuICAgICAgICAgICAgdGhpcy5yb290S2V5ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucm9vdEtleSA9IGhleFRvQnl0ZXMoSUNfUk9PVF9LRVkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhvc3QgPSBkZXRlcm1pbmVIb3N0KG9wdGlvbnMuaG9zdCk7XG4gICAgICAgIHRoaXMuaG9zdCA9IG5ldyBVUkwoaG9zdCk7XG4gICAgICAgIGlmIChvcHRpb25zLnZlcmlmeVF1ZXJ5U2lnbmF0dXJlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLiN2ZXJpZnlRdWVyeVNpZ25hdHVyZXMgPSBvcHRpb25zLnZlcmlmeVF1ZXJ5U2lnbmF0dXJlcztcbiAgICAgICAgfVxuICAgICAgICAvLyBEZWZhdWx0IGlzIDNcbiAgICAgICAgdGhpcy4jcmV0cnlUaW1lcyA9IG9wdGlvbnMucmV0cnlUaW1lcyA/PyAzO1xuICAgICAgICAvLyBEZWxheSBzdHJhdGVneSBmb3IgcmV0cmllcy4gRGVmYXVsdCBpcyBleHBvbmVudGlhbCBiYWNrb2ZmXG4gICAgICAgIGNvbnN0IGRlZmF1bHRCYWNrb2ZmRmFjdG9yeSA9ICgpID0+IG5ldyBFeHBvbmVudGlhbEJhY2tvZmYoe1xuICAgICAgICAgICAgbWF4SXRlcmF0aW9uczogdGhpcy4jcmV0cnlUaW1lcyxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuI2JhY2tvZmZTdHJhdGVneSA9IG9wdGlvbnMuYmFja29mZlN0cmF0ZWd5IHx8IGRlZmF1bHRCYWNrb2ZmRmFjdG9yeTtcbiAgICAgICAgLy8gUmV3cml0ZSB0byBhdm9pZCByZWRpcmVjdHNcbiAgICAgICAgaWYgKHRoaXMuaG9zdC5ob3N0bmFtZS5lbmRzV2l0aChJQzBfU1VCX0RPTUFJTikpIHtcbiAgICAgICAgICAgIHRoaXMuaG9zdC5ob3N0bmFtZSA9IElDMF9ET01BSU47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5ob3N0Lmhvc3RuYW1lLmVuZHNXaXRoKElDUDBfU1VCX0RPTUFJTikpIHtcbiAgICAgICAgICAgIHRoaXMuaG9zdC5ob3N0bmFtZSA9IElDUDBfRE9NQUlOO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuaG9zdC5ob3N0bmFtZS5lbmRzV2l0aChJQ1BfQVBJX1NVQl9ET01BSU4pKSB7XG4gICAgICAgICAgICB0aGlzLmhvc3QuaG9zdG5hbWUgPSBJQ1BfQVBJX0RPTUFJTjtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5jcmVkZW50aWFscykge1xuICAgICAgICAgICAgY29uc3QgeyBuYW1lLCBwYXNzd29yZCB9ID0gb3B0aW9ucy5jcmVkZW50aWFscztcbiAgICAgICAgICAgIHRoaXMuI2NyZWRlbnRpYWxzID0gYCR7bmFtZX0ke3Bhc3N3b3JkID8gJzonICsgcGFzc3dvcmQgOiAnJ31gO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI2lkZW50aXR5ID0gUHJvbWlzZS5yZXNvbHZlKG9wdGlvbnMuaWRlbnRpdHkgfHwgbmV3IEFub255bW91c0lkZW50aXR5KCkpO1xuICAgICAgICBpZiAob3B0aW9ucy5pbmdyZXNzRXhwaXJ5SW5NaW51dGVzICYmIG9wdGlvbnMuaW5ncmVzc0V4cGlyeUluTWludXRlcyA+IDUpIHtcbiAgICAgICAgICAgIHRocm93IElucHV0RXJyb3IuZnJvbUNvZGUobmV3IEluZ3Jlc3NFeHBpcnlJbnZhbGlkRXJyb3JDb2RlKCdUaGUgbWF4aW11bSBpbmdyZXNzIGV4cGlyeSB0aW1lIGlzIDUgbWludXRlcy4nLCBvcHRpb25zLmluZ3Jlc3NFeHBpcnlJbk1pbnV0ZXMpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5pbmdyZXNzRXhwaXJ5SW5NaW51dGVzICYmIG9wdGlvbnMuaW5ncmVzc0V4cGlyeUluTWludXRlcyA8PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBJbnB1dEVycm9yLmZyb21Db2RlKG5ldyBJbmdyZXNzRXhwaXJ5SW52YWxpZEVycm9yQ29kZSgnSW5ncmVzcyBleHBpcnkgdGltZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwLicsIG9wdGlvbnMuaW5ncmVzc0V4cGlyeUluTWludXRlcykpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI21heEluZ3Jlc3NFeHBpcnlJbk1pbnV0ZXMgPSBvcHRpb25zLmluZ3Jlc3NFeHBpcnlJbk1pbnV0ZXMgfHwgNTtcbiAgICAgICAgLy8gQWRkIGEgbm9uY2UgdHJhbnNmb3JtIHRvIGVuc3VyZSBjYWxscyBhcmUgdW5pcXVlXG4gICAgICAgIHRoaXMuYWRkVHJhbnNmb3JtKCd1cGRhdGUnLCBtYWtlTm9uY2VUcmFuc2Zvcm0obWFrZU5vbmNlKSk7XG4gICAgICAgIGlmIChvcHRpb25zLnVzZVF1ZXJ5Tm9uY2VzKSB7XG4gICAgICAgICAgICB0aGlzLmFkZFRyYW5zZm9ybSgncXVlcnknLCBtYWtlTm9uY2VUcmFuc2Zvcm0obWFrZU5vbmNlKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMubG9nVG9Db25zb2xlKSB7XG4gICAgICAgICAgICB0aGlzLmxvZy5zdWJzY3JpYmUobG9nID0+IHtcbiAgICAgICAgICAgICAgICBpZiAobG9nLmxldmVsID09PSAnZXJyb3InKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IobG9nLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChsb2cubGV2ZWwgPT09ICd3YXJuJykge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4obG9nLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2cobG9nLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGVTeW5jKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICByZXR1cm4gbmV3IHRoaXMoeyAuLi5vcHRpb25zIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgYXN5bmMgY3JlYXRlKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCBhZ2VudCA9IEh0dHBBZ2VudC5jcmVhdGVTeW5jKG9wdGlvbnMpO1xuICAgICAgICBhd2FpdCBhZ2VudC4jYXN5bmNHdWFyZCgpO1xuICAgICAgICByZXR1cm4gYWdlbnQ7XG4gICAgfVxuICAgIHN0YXRpYyBhc3luYyBmcm9tKGFnZW50KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoJ2NvbmZpZycgaW4gYWdlbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgSHR0cEFnZW50LmNyZWF0ZShhZ2VudC5jb25maWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IEh0dHBBZ2VudC5jcmVhdGUoe1xuICAgICAgICAgICAgICAgIGZldGNoOiBhZ2VudC5fZmV0Y2gsXG4gICAgICAgICAgICAgICAgZmV0Y2hPcHRpb25zOiBhZ2VudC5fZmV0Y2hPcHRpb25zLFxuICAgICAgICAgICAgICAgIGNhbGxPcHRpb25zOiBhZ2VudC5fY2FsbE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgaG9zdDogYWdlbnQuX2hvc3QudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICBpZGVudGl0eTogYWdlbnQuX2lkZW50aXR5ID8/IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIHtcbiAgICAgICAgICAgIHRocm93IElucHV0RXJyb3IuZnJvbUNvZGUobmV3IENyZWF0ZUh0dHBBZ2VudEVycm9yQ29kZSgpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpc0xvY2FsKCkge1xuICAgICAgICBjb25zdCBob3N0bmFtZSA9IHRoaXMuaG9zdC5ob3N0bmFtZTtcbiAgICAgICAgcmV0dXJuIGhvc3RuYW1lID09PSAnMTI3LjAuMC4xJyB8fCBob3N0bmFtZS5lbmRzV2l0aCgnMTI3LjAuMC4xJyk7XG4gICAgfVxuICAgIGFkZFRyYW5zZm9ybSh0eXBlLCBmbiwgcHJpb3JpdHkgPSBmbi5wcmlvcml0eSB8fCAwKSB7XG4gICAgICAgIGlmICh0eXBlID09PSAndXBkYXRlJykge1xuICAgICAgICAgICAgLy8gS2VlcCB0aGUgcGlwZWxpbmUgc29ydGVkIGF0IGFsbCB0aW1lLCBieSBwcmlvcml0eS5cbiAgICAgICAgICAgIGNvbnN0IGkgPSB0aGlzLiN1cGRhdGVQaXBlbGluZS5maW5kSW5kZXgoeCA9PiAoeC5wcmlvcml0eSB8fCAwKSA8IHByaW9yaXR5KTtcbiAgICAgICAgICAgIHRoaXMuI3VwZGF0ZVBpcGVsaW5lLnNwbGljZShpID49IDAgPyBpIDogdGhpcy4jdXBkYXRlUGlwZWxpbmUubGVuZ3RoLCAwLCBPYmplY3QuYXNzaWduKGZuLCB7IHByaW9yaXR5IH0pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlID09PSAncXVlcnknKSB7XG4gICAgICAgICAgICAvLyBLZWVwIHRoZSBwaXBlbGluZSBzb3J0ZWQgYXQgYWxsIHRpbWUsIGJ5IHByaW9yaXR5LlxuICAgICAgICAgICAgY29uc3QgaSA9IHRoaXMuI3F1ZXJ5UGlwZWxpbmUuZmluZEluZGV4KHggPT4gKHgucHJpb3JpdHkgfHwgMCkgPCBwcmlvcml0eSk7XG4gICAgICAgICAgICB0aGlzLiNxdWVyeVBpcGVsaW5lLnNwbGljZShpID49IDAgPyBpIDogdGhpcy4jcXVlcnlQaXBlbGluZS5sZW5ndGgsIDAsIE9iamVjdC5hc3NpZ24oZm4sIHsgcHJpb3JpdHkgfSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGdldFByaW5jaXBhbCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLiNpZGVudGl0eSkge1xuICAgICAgICAgICAgdGhyb3cgRXh0ZXJuYWxFcnJvci5mcm9tQ29kZShuZXcgSWRlbnRpdHlJbnZhbGlkRXJyb3JDb2RlKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoYXdhaXQgdGhpcy4jaWRlbnRpdHkpLmdldFByaW5jaXBhbCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYWtlcyBhIGNhbGwgdG8gYSBjYW5pc3RlciBtZXRob2QuXG4gICAgICogQHBhcmFtIGNhbmlzdGVySWQgLSBUaGUgSUQgb2YgdGhlIGNhbmlzdGVyIHRvIGNhbGwuIENhbiBiZSBhIFByaW5jaXBhbCBvciBhIHN0cmluZy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgZm9yIHRoZSBjYWxsLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLm1ldGhvZE5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgbWV0aG9kIHRvIGNhbGwuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuYXJnIC0gVGhlIGFyZ3VtZW50IHRvIHBhc3MgdG8gdGhlIG1ldGhvZCwgYXMgYSBVaW50OEFycmF5LlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmVmZmVjdGl2ZUNhbmlzdGVySWQgLSAoT3B0aW9uYWwpIFRoZSBlZmZlY3RpdmUgY2FuaXN0ZXIgSUQsIGlmIGRpZmZlcmVudCBmcm9tIHRoZSB0YXJnZXQgY2FuaXN0ZXIgSUQuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuY2FsbFN5bmMgLSAoT3B0aW9uYWwpIFdoZXRoZXIgdG8gdXNlIHN5bmNocm9ub3VzIGNhbGwgbW9kZS4gRGVmYXVsdHMgdG8gdHJ1ZS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5ub25jZSAtIChPcHRpb25hbCkgQSB1bmlxdWUgbm9uY2UgZm9yIHRoZSByZXF1ZXN0LiBJZiBwcm92aWRlZCwgaXQgd2lsbCBvdmVycmlkZSBhbnkgbm9uY2Ugc2V0IGJ5IHRyYW5zZm9ybXMuXG4gICAgICogQHBhcmFtIGlkZW50aXR5IC0gKE9wdGlvbmFsKSBUaGUgaWRlbnRpdHkgdG8gdXNlIGZvciB0aGUgY2FsbC4gSWYgbm90IHByb3ZpZGVkLCB0aGUgYWdlbnQncyBjdXJyZW50IGlkZW50aXR5IHdpbGwgYmUgdXNlZC5cbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgcmVzcG9uc2Ugb2YgdGhlIGNhbGwsIGluY2x1ZGluZyB0aGUgcmVxdWVzdCBJRCBhbmQgcmVzcG9uc2UgZGV0YWlscy5cbiAgICAgKi9cbiAgICBhc3luYyBjYWxsKGNhbmlzdGVySWQsIG9wdGlvbnMsIGlkZW50aXR5KSB7XG4gICAgICAgIGNvbnN0IGNhbGxTeW5jID0gb3B0aW9ucy5jYWxsU3luYyA/PyB0cnVlO1xuICAgICAgICBjb25zdCBpZCA9IGF3YWl0IChpZGVudGl0eSA/PyB0aGlzLiNpZGVudGl0eSk7XG4gICAgICAgIGlmICghaWQpIHtcbiAgICAgICAgICAgIHRocm93IEV4dGVybmFsRXJyb3IuZnJvbUNvZGUobmV3IElkZW50aXR5SW52YWxpZEVycm9yQ29kZSgpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjYW5pc3RlciA9IFByaW5jaXBhbC5mcm9tKGNhbmlzdGVySWQpO1xuICAgICAgICBjb25zdCBlY2lkID0gb3B0aW9ucy5lZmZlY3RpdmVDYW5pc3RlcklkXG4gICAgICAgICAgICA/IFByaW5jaXBhbC5mcm9tKG9wdGlvbnMuZWZmZWN0aXZlQ2FuaXN0ZXJJZClcbiAgICAgICAgICAgIDogY2FuaXN0ZXI7XG4gICAgICAgIGF3YWl0IHRoaXMuI2FzeW5jR3VhcmQoZWNpZCk7XG4gICAgICAgIGNvbnN0IHNlbmRlciA9IGlkLmdldFByaW5jaXBhbCgpO1xuICAgICAgICBjb25zdCBpbmdyZXNzX2V4cGlyeSA9IGNhbGN1bGF0ZUluZ3Jlc3NFeHBpcnkodGhpcy4jbWF4SW5ncmVzc0V4cGlyeUluTWludXRlcywgdGhpcy4jdGltZURpZmZNc2Vjcyk7XG4gICAgICAgIGNvbnN0IHN1Ym1pdCA9IHtcbiAgICAgICAgICAgIHJlcXVlc3RfdHlwZTogU3VibWl0UmVxdWVzdFR5cGUuQ2FsbCxcbiAgICAgICAgICAgIGNhbmlzdGVyX2lkOiBjYW5pc3RlcixcbiAgICAgICAgICAgIG1ldGhvZF9uYW1lOiBvcHRpb25zLm1ldGhvZE5hbWUsXG4gICAgICAgICAgICBhcmc6IG9wdGlvbnMuYXJnLFxuICAgICAgICAgICAgc2VuZGVyLFxuICAgICAgICAgICAgaW5ncmVzc19leHBpcnksXG4gICAgICAgIH07XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZFJlcXVlc3QgPSAoYXdhaXQgdGhpcy5fdHJhbnNmb3JtKHtcbiAgICAgICAgICAgIHJlcXVlc3Q6IHtcbiAgICAgICAgICAgICAgICBib2R5OiBudWxsLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9jYm9yJyxcbiAgICAgICAgICAgICAgICAgICAgLi4uKHRoaXMuI2NyZWRlbnRpYWxzID8geyBBdXRob3JpemF0aW9uOiAnQmFzaWMgJyArIGJ0b2EodGhpcy4jY3JlZGVudGlhbHMpIH0gOiB7fSksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbmRwb2ludDogRW5kcG9pbnQuQ2FsbCxcbiAgICAgICAgICAgIGJvZHk6IHN1Ym1pdCxcbiAgICAgICAgfSkpO1xuICAgICAgICAvLyBEZXRlcm1pbmUgdGhlIG5vbmNlIHRvIHVzZSBmb3IgdGhlIHJlcXVlc3RcbiAgICAgICAgbGV0IG5vbmNlO1xuICAgICAgICAvLyBDaGVjayBpZiBhIG5vbmNlIGlzIHByb3ZpZGVkIGluIHRoZSBvcHRpb25zIGFuZCBjb252ZXJ0IGl0IHRvIHRoZSBjb3JyZWN0IHR5cGVcbiAgICAgICAgaWYgKG9wdGlvbnM/Lm5vbmNlKSB7XG4gICAgICAgICAgICBub25jZSA9IHRvTm9uY2Uob3B0aW9ucy5ub25jZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgbm8gbm9uY2UgaXMgcHJvdmlkZWQgaW4gdGhlIG9wdGlvbnMsIGNoZWNrIHRoZSB0cmFuc2Zvcm1lZFJlcXVlc3QgYm9keVxuICAgICAgICBlbHNlIGlmICh0cmFuc2Zvcm1lZFJlcXVlc3QuYm9keS5ub25jZSkge1xuICAgICAgICAgICAgbm9uY2UgPSB0b05vbmNlKHRyYW5zZm9ybWVkUmVxdWVzdC5ib2R5Lm5vbmNlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBubyBub25jZSBpcyBmb3VuZCwgc2V0IGl0IHRvIHVuZGVmaW5lZFxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5vbmNlID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFzc2lnbiB0aGUgZGV0ZXJtaW5lZCBub25jZSB0byB0aGUgc3VibWl0IG9iamVjdFxuICAgICAgICBzdWJtaXQubm9uY2UgPSBub25jZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnRzIGEgVWludDhBcnJheSB0byBhIE5vbmNlIHR5cGUuXG4gICAgICAgICAqIEBwYXJhbSBidWYgLSBUaGUgYnVmZmVyIHRvIGNvbnZlcnQuXG4gICAgICAgICAqIEByZXR1cm5zIFRoZSBidWZmZXIgYXMgYSBOb25jZS5cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIHRvTm9uY2UoYnVmKSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihidWYsIHsgX19ub25jZV9fOiB1bmRlZmluZWQgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXBwbHkgdHJhbnNmb3JtIGZvciBpZGVudGl0eS5cbiAgICAgICAgdHJhbnNmb3JtZWRSZXF1ZXN0ID0gKGF3YWl0IGlkLnRyYW5zZm9ybVJlcXVlc3QodHJhbnNmb3JtZWRSZXF1ZXN0KSk7XG4gICAgICAgIGNvbnN0IGJvZHkgPSBjYm9yLmVuY29kZSh0cmFuc2Zvcm1lZFJlcXVlc3QuYm9keSk7XG4gICAgICAgIGNvbnN0IGJhY2tvZmYgPSB0aGlzLiNiYWNrb2ZmU3RyYXRlZ3koKTtcbiAgICAgICAgY29uc3QgcmVxdWVzdElkID0gcmVxdWVzdElkT2Yoc3VibWl0KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIEF0dGVtcHQgdjMgc3luYyBjYWxsXG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0U3luYyA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZy5wcmludChgZmV0Y2hpbmcgXCIvYXBpL3YzL2NhbmlzdGVyLyR7ZWNpZC50b1RleHQoKX0vY2FsbFwiIHdpdGggcmVxdWVzdDpgLCB0cmFuc2Zvcm1lZFJlcXVlc3QpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiNmZXRjaCgnJyArIG5ldyBVUkwoYC9hcGkvdjMvY2FuaXN0ZXIvJHtlY2lkLnRvVGV4dCgpfS9jYWxsYCwgdGhpcy5ob3N0KSwge1xuICAgICAgICAgICAgICAgICAgICAuLi50aGlzLiNjYWxsT3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgLi4udHJhbnNmb3JtZWRSZXF1ZXN0LnJlcXVlc3QsXG4gICAgICAgICAgICAgICAgICAgIGJvZHksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgcmVxdWVzdEFzeW5jID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nLnByaW50KGBmZXRjaGluZyBcIi9hcGkvdjIvY2FuaXN0ZXIvJHtlY2lkLnRvVGV4dCgpfS9jYWxsXCIgd2l0aCByZXF1ZXN0OmAsIHRyYW5zZm9ybWVkUmVxdWVzdCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuI2ZldGNoKCcnICsgbmV3IFVSTChgL2FwaS92Mi9jYW5pc3Rlci8ke2VjaWQudG9UZXh0KCl9L2NhbGxgLCB0aGlzLmhvc3QpLCB7XG4gICAgICAgICAgICAgICAgICAgIC4uLnRoaXMuI2NhbGxPcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICAuLi50cmFuc2Zvcm1lZFJlcXVlc3QucmVxdWVzdCxcbiAgICAgICAgICAgICAgICAgICAgYm9keSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0Rm4gPSBjYWxsU3luYyA/IHJlcXVlc3RTeW5jIDogcmVxdWVzdEFzeW5jO1xuICAgICAgICAgICAgY29uc3QgeyByZXNwb25zZUJvZHlCeXRlcywgLi4ucmVzcG9uc2UgfSA9IGF3YWl0IHRoaXMuI3JlcXVlc3RBbmRSZXRyeSh7XG4gICAgICAgICAgICAgICAgcmVxdWVzdEZuLFxuICAgICAgICAgICAgICAgIGJhY2tvZmYsXG4gICAgICAgICAgICAgICAgdHJpZXM6IDAsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlQm9keSA9IChyZXNwb25zZUJvZHlCeXRlcy5ieXRlTGVuZ3RoID4gMCA/IGNib3IuZGVjb2RlKHJlc3BvbnNlQm9keUJ5dGVzKSA6IG51bGwpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0SWQsXG4gICAgICAgICAgICAgICAgcmVzcG9uc2U6IHtcbiAgICAgICAgICAgICAgICAgICAgLi4ucmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICAgIGJvZHk6IHJlc3BvbnNlQm9keSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHJlcXVlc3REZXRhaWxzOiBzdWJtaXQsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgbGV0IGNhbGxFcnJvcjtcbiAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEFnZW50RXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgZXJyb3IgaXMgZHVlIHRvIHRoZSB2MyBhcGkgbm90IGJlaW5nIHN1cHBvcnRlZCwgZmFsbCBiYWNrIHRvIHYyXG4gICAgICAgICAgICAgICAgaWYgKGVycm9yLmhhc0NvZGUoSHR0cFYzQXBpTm90U3VwcG9ydGVkRXJyb3JDb2RlKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZy53YXJuKCd2MyBhcGkgbm90IHN1cHBvcnRlZC4gRmFsbCBiYWNrIHRvIHYyJyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNhbGwoY2FuaXN0ZXJJZCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRpc2FibGUgdjMgYXBpXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsU3luYzogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIH0sIGlkZW50aXR5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZXJyb3IuaGFzQ29kZShJbmdyZXNzRXhwaXJ5SW52YWxpZEVycm9yQ29kZSkgJiYgIXRoaXMuI2hhc1N5bmNlZFRpbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgYW4gaW5ncmVzcyBleHBpcnkgZXJyb3IgYW5kIHRoZSB0aW1lIGhhcyBub3QgYmVlbiBzeW5jZWQgeWV0LFxuICAgICAgICAgICAgICAgICAgICAvLyBzeW5jIHRpbWUgd2l0aCB0aGUgbmV0d29yayBhbmQgdHJ5IGFnYWluXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuc3luY1RpbWUoY2FuaXN0ZXIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jYWxsKGNhbmlzdGVyLCBvcHRpb25zLCBpZGVudGl0eSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBvdmVycmlkZSB0aGUgZXJyb3IgY29kZSB0byBpbmNsdWRlIHRoZSByZXF1ZXN0IGRldGFpbHNcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IuY29kZS5yZXF1ZXN0Q29udGV4dCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbmRlclB1YktleTogdHJhbnNmb3JtZWRSZXF1ZXN0LmJvZHkuc2VuZGVyX3B1YmtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbmRlclNpZ25hdHVyZTogdHJhbnNmb3JtZWRSZXF1ZXN0LmJvZHkuc2VuZGVyX3NpZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZ3Jlc3NFeHBpcnk6IHRyYW5zZm9ybWVkUmVxdWVzdC5ib2R5LmNvbnRlbnQuaW5ncmVzc19leHBpcnksXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGNhbGxFcnJvciA9IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNhbGxFcnJvciA9IFVua25vd25FcnJvci5mcm9tQ29kZShuZXcgVW5leHBlY3RlZEVycm9yQ29kZShlcnJvcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5sb2cuZXJyb3IoYEVycm9yIHdoaWxlIG1ha2luZyBjYWxsOiAke2NhbGxFcnJvci5tZXNzYWdlfWAsIGNhbGxFcnJvcik7XG4gICAgICAgICAgICB0aHJvdyBjYWxsRXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgI3JlcXVlc3RBbmRSZXRyeVF1ZXJ5KGFyZ3MpIHtcbiAgICAgICAgY29uc3QgeyBlY2lkLCB0cmFuc2Zvcm1lZFJlcXVlc3QsIGJvZHksIHJlcXVlc3RJZCwgYmFja29mZiwgdHJpZXMgfSA9IGFyZ3M7XG4gICAgICAgIGNvbnN0IGRlbGF5ID0gdHJpZXMgPT09IDAgPyAwIDogYmFja29mZi5uZXh0KCk7XG4gICAgICAgIHRoaXMubG9nLnByaW50KGBmZXRjaGluZyBcIi9hcGkvdjIvY2FuaXN0ZXIvJHtlY2lkLnRvU3RyaW5nKCl9L3F1ZXJ5XCIgd2l0aCB0cmllczpgLCB7XG4gICAgICAgICAgICB0cmllcyxcbiAgICAgICAgICAgIGJhY2tvZmYsXG4gICAgICAgICAgICBkZWxheSxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIElmIGRlbGF5IGlzIG51bGwsIHRoZSBiYWNrb2ZmIHN0cmF0ZWd5IGlzIGV4aGF1c3RlZCBkdWUgdG8gYSBtYXhpbXVtIG51bWJlciBvZiByZXRyaWVzLCBkdXJhdGlvbiwgb3Igb3RoZXIgcmVhc29uXG4gICAgICAgIGlmIChkZWxheSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgVW5rbm93bkVycm9yLmZyb21Db2RlKG5ldyBUaW1lb3V0V2FpdGluZ0ZvclJlc3BvbnNlRXJyb3JDb2RlKGBCYWNrb2ZmIHN0cmF0ZWd5IGV4aGF1c3RlZCBhZnRlciAke3RyaWVzfSBhdHRlbXB0cy5gLCByZXF1ZXN0SWQpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVsYXkgPiAwKSB7XG4gICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgZGVsYXkpKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIC8vIE1ha2UgdGhlIHJlcXVlc3QgYW5kIHJldHJ5IGlmIGl0IHRocm93cyBhbiBlcnJvclxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5sb2cucHJpbnQoYGZldGNoaW5nIFwiL2FwaS92Mi9jYW5pc3Rlci8ke2VjaWQudG9TdHJpbmcoKX0vcXVlcnlcIiB3aXRoIHJlcXVlc3Q6YCwgdHJhbnNmb3JtZWRSZXF1ZXN0KTtcbiAgICAgICAgICAgIGNvbnN0IGZldGNoUmVzcG9uc2UgPSBhd2FpdCB0aGlzLiNmZXRjaCgnJyArIG5ldyBVUkwoYC9hcGkvdjIvY2FuaXN0ZXIvJHtlY2lkLnRvU3RyaW5nKCl9L3F1ZXJ5YCwgdGhpcy5ob3N0KSwge1xuICAgICAgICAgICAgICAgIC4uLnRoaXMuI2ZldGNoT3B0aW9ucyxcbiAgICAgICAgICAgICAgICAuLi50cmFuc2Zvcm1lZFJlcXVlc3QucmVxdWVzdCxcbiAgICAgICAgICAgICAgICBib2R5LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoZmV0Y2hSZXNwb25zZS5zdGF0dXMgPT09IEhUVFBfU1RBVFVTX09LKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcXVlcnlSZXNwb25zZSA9IGNib3IuZGVjb2RlKHVpbnQ4RnJvbUJ1Zkxpa2UoYXdhaXQgZmV0Y2hSZXNwb25zZS5hcnJheUJ1ZmZlcigpKSk7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgIC4uLnF1ZXJ5UmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICAgIGh0dHBEZXRhaWxzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvazogZmV0Y2hSZXNwb25zZS5vayxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogZmV0Y2hSZXNwb25zZS5zdGF0dXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXNUZXh0OiBmZXRjaFJlc3BvbnNlLnN0YXR1c1RleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBodHRwSGVhZGVyc1RyYW5zZm9ybShmZXRjaFJlc3BvbnNlLmhlYWRlcnMpLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0SWQsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IFByb3RvY29sRXJyb3IuZnJvbUNvZGUobmV3IEh0dHBFcnJvckNvZGUoZmV0Y2hSZXNwb25zZS5zdGF0dXMsIGZldGNoUmVzcG9uc2Uuc3RhdHVzVGV4dCwgaHR0cEhlYWRlcnNUcmFuc2Zvcm0oZmV0Y2hSZXNwb25zZS5oZWFkZXJzKSwgYXdhaXQgZmV0Y2hSZXNwb25zZS50ZXh0KCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmICh0cmllcyA8IHRoaXMuI3JldHJ5VGltZXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZy53YXJuKGBDYXVnaHQgZXhjZXB0aW9uIHdoaWxlIGF0dGVtcHRpbmcgdG8gbWFrZSBxdWVyeTpcXG5gICtcbiAgICAgICAgICAgICAgICAgICAgYCAgJHtlcnJvcn1cXG5gICtcbiAgICAgICAgICAgICAgICAgICAgYCAgUmV0cnlpbmcgcXVlcnkuYCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuI3JlcXVlc3RBbmRSZXRyeVF1ZXJ5KHsgLi4uYXJncywgdHJpZXM6IHRyaWVzICsgMSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEFnZW50RXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiBpdCdzIGFuIGVycm9yIHRoYXQgd2UgaGF2ZSB0aHJvd24sIGp1c3QgdGhyb3cgaXQgYXMgaXNcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmIGl0J3MgYW4gZXJyb3IgdGhhdCB3ZSBoYXZlIG5vdCB0aHJvd24sIHdyYXAgaXQgaW4gYSBUcmFuc3BvcnRFcnJvclxuICAgICAgICAgICAgdGhyb3cgVHJhbnNwb3J0RXJyb3IuZnJvbUNvZGUobmV3IEh0dHBGZXRjaEVycm9yQ29kZShlcnJvcikpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNraXAgdGltZXN0YW1wIHZlcmlmaWNhdGlvbiBpZiB0aGUgdXNlciBoYXMgc2V0IHZlcmlmeVF1ZXJ5U2lnbmF0dXJlcyB0byBmYWxzZVxuICAgICAgICBpZiAoIXRoaXMuI3ZlcmlmeVF1ZXJ5U2lnbmF0dXJlcykge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNpZ25hdHVyZVRpbWVzdGFtcE5zID0gcmVzcG9uc2Uuc2lnbmF0dXJlcz8uWzBdPy50aW1lc3RhbXA7XG4gICAgICAgIGlmICghc2lnbmF0dXJlVGltZXN0YW1wTnMpIHtcbiAgICAgICAgICAgIHRocm93IFByb3RvY29sRXJyb3IuZnJvbUNvZGUobmV3IE1hbGZvcm1lZFNpZ25hdHVyZUVycm9yQ29kZSgnVGltZXN0YW1wIG5vdCBmb3VuZCBpbiBxdWVyeSByZXNwb25zZS4gVGhpcyBzdWdnZXN0cyBhIG1hbGZvcm1lZCBvciBtYWxpY2lvdXMgcmVzcG9uc2UuJykpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNpZ25hdHVyZVRpbWVzdGFtcE1zID0gTnVtYmVyKEJpZ0ludChzaWduYXR1cmVUaW1lc3RhbXBOcykgLyBCaWdJbnQoTVNFQ1NfVE9fTkFOT1NFQ09ORFMpKTtcbiAgICAgICAgY29uc3QgY3VycmVudFRpbWVzdGFtcEluTXMgPSBEYXRlLm5vdygpICsgdGhpcy4jdGltZURpZmZNc2VjcztcbiAgICAgICAgLy8gV2UgZG9uJ3QgbmVlZCBgTWF0aC5hYnNgIGhlcmUgYmVjYXVzZSB3ZSBhbGxvdyBzaWduYXR1cmVzIGluIHRoZSBmdXR1cmVcbiAgICAgICAgaWYgKGN1cnJlbnRUaW1lc3RhbXBJbk1zIC0gc2lnbmF0dXJlVGltZXN0YW1wTXMgPiB0aGlzLiNtYXhJbmdyZXNzRXhwaXJ5SW5Ncykge1xuICAgICAgICAgICAgaWYgKHRyaWVzIDwgdGhpcy4jcmV0cnlUaW1lcykge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nLndhcm4oJ1RpbWVzdGFtcCBpcyBvbGRlciB0aGFuIHRoZSBtYXggaW5ncmVzcyBleHBpcnkuIFJldHJ5aW5nIHF1ZXJ5LicsIHtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICAgICAgICAgICAgICBzaWduYXR1cmVUaW1lc3RhbXBNcyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy4jcmVxdWVzdEFuZFJldHJ5UXVlcnkoeyAuLi5hcmdzLCB0cmllczogdHJpZXMgKyAxIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgVHJ1c3RFcnJvci5mcm9tQ29kZShuZXcgQ2VydGlmaWNhdGVPdXRkYXRlZEVycm9yQ29kZSh0aGlzLiNtYXhJbmdyZXNzRXhwaXJ5SW5NaW51dGVzLCByZXF1ZXN0SWQsIHRyaWVzKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYWtlcyBhIHJlcXVlc3QgYW5kIHJldHJpZXMgaWYgaXQgZmFpbHMuXG4gICAgICogQHBhcmFtIGFyZ3MgLSBUaGUgYXJndW1lbnRzIGZvciB0aGUgcmVxdWVzdC5cbiAgICAgKiBAcGFyYW0gYXJncy5yZXF1ZXN0Rm4gLSBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIFByb21pc2UgcmVzb2x2aW5nIHRvIGEgUmVzcG9uc2UuXG4gICAgICogQHBhcmFtIGFyZ3MuYmFja29mZiAtIFRoZSBiYWNrb2ZmIHN0cmF0ZWd5IHRvIHVzZSBmb3IgcmV0cmllcy5cbiAgICAgKiBAcGFyYW0gYXJncy50cmllcyAtIFRoZSBudW1iZXIgb2YgcmV0cnkgYXR0ZW1wdHMgbWFkZSBzbyBmYXIuXG4gICAgICogQHJldHVybnMgVGhlIHJlc3BvbnNlIGZyb20gdGhlIHJlcXVlc3QsIGlmIHRoZSBzdGF0dXMgaXMgMjAwIG9yIDIwMi5cbiAgICAgKiBTZWUgdGhlIGh0dHBzOi8vaW50ZXJuZXRjb21wdXRlci5vcmcvZG9jcy9yZWZlcmVuY2VzL2ljLWludGVyZmFjZS1zcGVjI2h0dHAtaW50ZXJmYWNlIGZvciBkZXRhaWxzIG9uIHRoZSByZXNwb25zZSBzdGF0dXNlcy5cbiAgICAgKiBAdGhyb3dzIHtQcm90b2NvbEVycm9yfSBpZiB0aGUgcmVzcG9uc2Ugc3RhdHVzIGlzIG5vdCAyMDAgb3IgMjAyLCBhbmQgdGhlIHJldHJ5IGxpbWl0IGhhcyBiZWVuIHJlYWNoZWQuXG4gICAgICogQHRocm93cyB7VHJhbnNwb3J0RXJyb3J9IGlmIHRoZSByZXF1ZXN0IGZhaWxzLCBhbmQgdGhlIHJldHJ5IGxpbWl0IGhhcyBiZWVuIHJlYWNoZWQuXG4gICAgICovXG4gICAgYXN5bmMgI3JlcXVlc3RBbmRSZXRyeShhcmdzKSB7XG4gICAgICAgIGNvbnN0IHsgcmVxdWVzdEZuLCBiYWNrb2ZmLCB0cmllcyB9ID0gYXJncztcbiAgICAgICAgY29uc3QgZGVsYXkgPSB0cmllcyA9PT0gMCA/IDAgOiBiYWNrb2ZmLm5leHQoKTtcbiAgICAgICAgLy8gSWYgZGVsYXkgaXMgbnVsbCwgdGhlIGJhY2tvZmYgc3RyYXRlZ3kgaXMgZXhoYXVzdGVkIGR1ZSB0byBhIG1heGltdW0gbnVtYmVyIG9mIHJldHJpZXMsIGR1cmF0aW9uLCBvciBvdGhlciByZWFzb25cbiAgICAgICAgaWYgKGRlbGF5ID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBQcm90b2NvbEVycm9yLmZyb21Db2RlKG5ldyBUaW1lb3V0V2FpdGluZ0ZvclJlc3BvbnNlRXJyb3JDb2RlKGBSZXRyeSBzdHJhdGVneSBleGhhdXN0ZWQgYWZ0ZXIgJHt0cmllc30gYXR0ZW1wdHMuYCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZWxheSA+IDApIHtcbiAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCBkZWxheSkpO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHJlc3BvbnNlQm9keUJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgcmVxdWVzdEZuKCk7XG4gICAgICAgICAgICAvLyBBY2NvcmRpbmcgdG8gdGhlIHNwZWMsIG9ubHkgMjAwIHJlc3BvbnNlcyBoYXZlIGEgbm9uLWVtcHR5IGJvZHlcbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IEhUVFBfU1RBVFVTX09LKSB7XG4gICAgICAgICAgICAgICAgLy8gQ29uc3VtZSB0aGUgcmVzcG9uc2UgYm9keSwgdG8gZW5zdXJlIHRoYXQgdGhlIHJlc3BvbnNlIGlzIG5vdCBjbG9zZWQgdW5leHBlY3RlZGx5XG4gICAgICAgICAgICAgICAgcmVzcG9uc2VCb2R5Qnl0ZXMgPSB1aW50OEZyb21CdWZMaWtlKGF3YWl0IHJlc3BvbnNlLmNsb25lKCkuYXJyYXlCdWZmZXIoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAodHJpZXMgPCB0aGlzLiNyZXRyeVRpbWVzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2cud2FybihgQ2F1Z2h0IGV4Y2VwdGlvbiB3aGlsZSBhdHRlbXB0aW5nIHRvIG1ha2UgcmVxdWVzdDpcXG5gICtcbiAgICAgICAgICAgICAgICAgICAgYCAgJHtlcnJvcn1cXG5gICtcbiAgICAgICAgICAgICAgICAgICAgYCAgUmV0cnlpbmcgcmVxdWVzdC5gKTtcbiAgICAgICAgICAgICAgICAvLyBEZWxheSB0aGUgcmVxdWVzdCBieSB0aGUgY29uZmlndXJlZCBiYWNrb2ZmIHN0cmF0ZWd5XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuI3JlcXVlc3RBbmRSZXRyeSh7IHJlcXVlc3RGbiwgYmFja29mZiwgdHJpZXM6IHRyaWVzICsgMSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IFRyYW5zcG9ydEVycm9yLmZyb21Db2RlKG5ldyBIdHRwRmV0Y2hFcnJvckNvZGUoZXJyb3IpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoZWFkZXJzID0gaHR0cEhlYWRlcnNUcmFuc2Zvcm0ocmVzcG9uc2UuaGVhZGVycyk7XG4gICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IEhUVFBfU1RBVFVTX09LIHx8IHJlc3BvbnNlLnN0YXR1cyA9PT0gSFRUUF9TVEFUVVNfQUNDRVBURUQpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgb2s6IHJlc3BvbnNlLm9rLCAvLyBzaG91bGQgYWx3YXlzIGJlIHRydWVcbiAgICAgICAgICAgICAgICBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgICAgICAgICBzdGF0dXNUZXh0OiByZXNwb25zZS5zdGF0dXNUZXh0LFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlQm9keUJ5dGVzLFxuICAgICAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlVGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gSFRUUF9TVEFUVVNfTk9UX0ZPVU5EICYmIHJlc3BvbnNlLnVybC5pbmNsdWRlcygnYXBpL3YzJykpIHtcbiAgICAgICAgICAgIHRocm93IFByb3RvY29sRXJyb3IuZnJvbUNvZGUobmV3IEh0dHBWM0FwaU5vdFN1cHBvcnRlZEVycm9yQ29kZSgpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGUgZXJyb3IgbWVzc2FnZSBjb21lcyBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9kZmluaXR5L2ljL2Jsb2IvMjNkNTk5MGJmYzUyNzdjMzJlNTRmMDA4N2I1YTM4ZmE0MTIxNzFlMS9ycy92YWxpZGF0b3Ivc3JjL2luZ3Jlc3NfdmFsaWRhdGlvbi5ycyNMMjMzXG4gICAgICAgIGlmIChyZXNwb25zZVRleHQuc3RhcnRzV2l0aCgnSW52YWxpZCByZXF1ZXN0IGV4cGlyeTogJykpIHtcbiAgICAgICAgICAgIHRocm93IElucHV0RXJyb3IuZnJvbUNvZGUobmV3IEluZ3Jlc3NFeHBpcnlJbnZhbGlkRXJyb3JDb2RlKHJlc3BvbnNlVGV4dCwgdGhpcy4jbWF4SW5ncmVzc0V4cGlyeUluTWludXRlcykpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0cmllcyA8IHRoaXMuI3JldHJ5VGltZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNyZXF1ZXN0QW5kUmV0cnkoeyByZXF1ZXN0Rm4sIGJhY2tvZmYsIHRyaWVzOiB0cmllcyArIDEgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgUHJvdG9jb2xFcnJvci5mcm9tQ29kZShuZXcgSHR0cEVycm9yQ29kZShyZXNwb25zZS5zdGF0dXMsIHJlc3BvbnNlLnN0YXR1c1RleHQsIGhlYWRlcnMsIHJlc3BvbnNlVGV4dCkpO1xuICAgIH1cbiAgICBhc3luYyBxdWVyeShjYW5pc3RlcklkLCBmaWVsZHMsIGlkZW50aXR5KSB7XG4gICAgICAgIGNvbnN0IGJhY2tvZmYgPSB0aGlzLiNiYWNrb2ZmU3RyYXRlZ3koKTtcbiAgICAgICAgY29uc3QgZWNpZCA9IGZpZWxkcy5lZmZlY3RpdmVDYW5pc3RlcklkXG4gICAgICAgICAgICA/IFByaW5jaXBhbC5mcm9tKGZpZWxkcy5lZmZlY3RpdmVDYW5pc3RlcklkKVxuICAgICAgICAgICAgOiBQcmluY2lwYWwuZnJvbShjYW5pc3RlcklkKTtcbiAgICAgICAgYXdhaXQgdGhpcy4jYXN5bmNHdWFyZChlY2lkKTtcbiAgICAgICAgdGhpcy5sb2cucHJpbnQoYGVjaWQgJHtlY2lkLnRvU3RyaW5nKCl9YCk7XG4gICAgICAgIHRoaXMubG9nLnByaW50KGBjYW5pc3RlcklkICR7Y2FuaXN0ZXJJZC50b1N0cmluZygpfWApO1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRSZXF1ZXN0O1xuICAgICAgICBjb25zdCBpZCA9IGF3YWl0IChpZGVudGl0eSA/PyB0aGlzLiNpZGVudGl0eSk7XG4gICAgICAgIGlmICghaWQpIHtcbiAgICAgICAgICAgIHRocm93IEV4dGVybmFsRXJyb3IuZnJvbUNvZGUobmV3IElkZW50aXR5SW52YWxpZEVycm9yQ29kZSgpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjYW5pc3RlciA9IFByaW5jaXBhbC5mcm9tKGNhbmlzdGVySWQpO1xuICAgICAgICBjb25zdCBzZW5kZXIgPSBpZC5nZXRQcmluY2lwYWwoKTtcbiAgICAgICAgY29uc3QgaW5ncmVzc0V4cGlyeSA9IGNhbGN1bGF0ZUluZ3Jlc3NFeHBpcnkodGhpcy4jbWF4SW5ncmVzc0V4cGlyeUluTWludXRlcywgdGhpcy4jdGltZURpZmZNc2Vjcyk7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB7XG4gICAgICAgICAgICByZXF1ZXN0X3R5cGU6IFJlYWRSZXF1ZXN0VHlwZS5RdWVyeSxcbiAgICAgICAgICAgIGNhbmlzdGVyX2lkOiBjYW5pc3RlcixcbiAgICAgICAgICAgIG1ldGhvZF9uYW1lOiBmaWVsZHMubWV0aG9kTmFtZSxcbiAgICAgICAgICAgIGFyZzogZmllbGRzLmFyZyxcbiAgICAgICAgICAgIHNlbmRlcixcbiAgICAgICAgICAgIGluZ3Jlc3NfZXhwaXJ5OiBpbmdyZXNzRXhwaXJ5LFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZXF1ZXN0SWQgPSByZXF1ZXN0SWRPZihyZXF1ZXN0KTtcbiAgICAgICAgdHJhbnNmb3JtZWRSZXF1ZXN0ID0gYXdhaXQgdGhpcy5fdHJhbnNmb3JtKHtcbiAgICAgICAgICAgIHJlcXVlc3Q6IHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vY2JvcicsXG4gICAgICAgICAgICAgICAgICAgIC4uLih0aGlzLiNjcmVkZW50aWFscyA/IHsgQXV0aG9yaXphdGlvbjogJ0Jhc2ljICcgKyBidG9hKHRoaXMuI2NyZWRlbnRpYWxzKSB9IDoge30pLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW5kcG9pbnQ6IEVuZHBvaW50LlF1ZXJ5LFxuICAgICAgICAgICAgYm9keTogcmVxdWVzdCxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEFwcGx5IHRyYW5zZm9ybSBmb3IgaWRlbnRpdHkuXG4gICAgICAgIHRyYW5zZm9ybWVkUmVxdWVzdCA9IChhd2FpdCBpZC50cmFuc2Zvcm1SZXF1ZXN0KHRyYW5zZm9ybWVkUmVxdWVzdCkpO1xuICAgICAgICBjb25zdCBib2R5ID0gY2Jvci5lbmNvZGUodHJhbnNmb3JtZWRSZXF1ZXN0LmJvZHkpO1xuICAgICAgICBjb25zdCBhcmdzID0ge1xuICAgICAgICAgICAgY2FuaXN0ZXI6IGNhbmlzdGVyLnRvVGV4dCgpLFxuICAgICAgICAgICAgZWNpZCxcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkUmVxdWVzdCxcbiAgICAgICAgICAgIGJvZHksXG4gICAgICAgICAgICByZXF1ZXN0SWQsXG4gICAgICAgICAgICBiYWNrb2ZmLFxuICAgICAgICAgICAgdHJpZXM6IDAsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG1ha2VRdWVyeSA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIC8vIEF0dGVtcHQgdG8gbWFrZSB0aGUgcXVlcnkgaT1yZXRyeVRpbWVzIHRpbWVzXG4gICAgICAgICAgICBjb25zdCBxdWVyeSA9IGF3YWl0IHRoaXMuI3JlcXVlc3RBbmRSZXRyeVF1ZXJ5KGFyZ3MpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0RGV0YWlsczogcmVxdWVzdCxcbiAgICAgICAgICAgICAgICAuLi5xdWVyeSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGdldFN1Ym5ldFN0YXR1cyA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNhY2hlZFN1Ym5ldFN0YXR1cyA9IHRoaXMuI3N1Ym5ldEtleXMuZ2V0KGVjaWQudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICBpZiAoY2FjaGVkU3VibmV0U3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFN1Ym5ldFN0YXR1cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0IHRoaXMuZmV0Y2hTdWJuZXRLZXlzKGVjaWQudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICBjb25zdCBzdWJuZXRTdGF0dXMgPSB0aGlzLiNzdWJuZXRLZXlzLmdldChlY2lkLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgaWYgKCFzdWJuZXRTdGF0dXMpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBUcnVzdEVycm9yLmZyb21Db2RlKG5ldyBNaXNzaW5nU2lnbmF0dXJlRXJyb3JDb2RlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN1Ym5ldFN0YXR1cztcbiAgICAgICAgfTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghdGhpcy4jdmVyaWZ5UXVlcnlTaWduYXR1cmVzKSB7XG4gICAgICAgICAgICAgICAgLy8gU2tpcCB2ZXJpZmljYXRpb24gaWYgdGhlIHVzZXIgaGFzIGRpc2FibGVkIGl0XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IG1ha2VRdWVyeSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTWFrZSBxdWVyeSBhbmQgZmV0Y2ggc3VibmV0IGtleXMgaW4gcGFyYWxsZWxcbiAgICAgICAgICAgIGNvbnN0IFtxdWVyeVdpdGhEZXRhaWxzLCBzdWJuZXRTdGF0dXNdID0gYXdhaXQgUHJvbWlzZS5hbGwoW21ha2VRdWVyeSgpLCBnZXRTdWJuZXRTdGF0dXMoKV0pO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4jdmVyaWZ5UXVlcnlSZXNwb25zZShxdWVyeVdpdGhEZXRhaWxzLCBzdWJuZXRTdGF0dXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2gge1xuICAgICAgICAgICAgICAgIC8vIEluIGNhc2UgdGhlIG5vZGUgc2lnbmF0dXJlcyBoYXZlIGNoYW5nZWQsIHJlZnJlc2ggdGhlIHN1Ym5ldCBrZXlzIGFuZCB0cnkgYWdhaW5cbiAgICAgICAgICAgICAgICB0aGlzLmxvZy53YXJuKCdRdWVyeSByZXNwb25zZSB2ZXJpZmljYXRpb24gZmFpbGVkLiBSZXRyeWluZyB3aXRoIGZyZXNoIHN1Ym5ldCBrZXlzLicpO1xuICAgICAgICAgICAgICAgIHRoaXMuI3N1Ym5ldEtleXMuZGVsZXRlKGVjaWQudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdXBkYXRlZFN1Ym5ldFN0YXR1cyA9IGF3YWl0IGdldFN1Ym5ldFN0YXR1cygpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiN2ZXJpZnlRdWVyeVJlc3BvbnNlKHF1ZXJ5V2l0aERldGFpbHMsIHVwZGF0ZWRTdWJuZXRTdGF0dXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgbGV0IHF1ZXJ5RXJyb3I7XG4gICAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBBZ2VudEVycm9yKSB7XG4gICAgICAgICAgICAgICAgLy8gb3ZlcnJpZGUgdGhlIGVycm9yIGNvZGUgdG8gaW5jbHVkZSB0aGUgcmVxdWVzdCBkZXRhaWxzXG4gICAgICAgICAgICAgICAgZXJyb3IuY29kZS5yZXF1ZXN0Q29udGV4dCA9IHtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICAgICAgICAgICAgICBzZW5kZXJQdWJLZXk6IHRyYW5zZm9ybWVkUmVxdWVzdC5ib2R5LnNlbmRlcl9wdWJrZXksXG4gICAgICAgICAgICAgICAgICAgIHNlbmRlclNpZ25hdHVyZTogdHJhbnNmb3JtZWRSZXF1ZXN0LmJvZHkuc2VuZGVyX3NpZyxcbiAgICAgICAgICAgICAgICAgICAgaW5ncmVzc0V4cGlyeTogdHJhbnNmb3JtZWRSZXF1ZXN0LmJvZHkuY29udGVudC5pbmdyZXNzX2V4cGlyeSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHF1ZXJ5RXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHF1ZXJ5RXJyb3IgPSBVbmtub3duRXJyb3IuZnJvbUNvZGUobmV3IFVuZXhwZWN0ZWRFcnJvckNvZGUoZXJyb3IpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubG9nLmVycm9yKGBFcnJvciB3aGlsZSBtYWtpbmcgcXVlcnk6ICR7cXVlcnlFcnJvci5tZXNzYWdlfWAsIHF1ZXJ5RXJyb3IpO1xuICAgICAgICAgICAgdGhyb3cgcXVlcnlFcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZWUgaHR0cHM6Ly9pbnRlcm5ldGNvbXB1dGVyLm9yZy9kb2NzL2N1cnJlbnQvcmVmZXJlbmNlcy9pYy1pbnRlcmZhY2Utc3BlYy8jaHR0cC1xdWVyeSBmb3IgZGV0YWlscyBvbiB2YWxpZGF0aW9uXG4gICAgICogQHBhcmFtIHF1ZXJ5UmVzcG9uc2UgLSBUaGUgcmVzcG9uc2UgZnJvbSB0aGUgcXVlcnlcbiAgICAgKiBAcGFyYW0gc3VibmV0U3RhdHVzIC0gVGhlIHN1Ym5ldCBzdGF0dXMsIGluY2x1ZGluZyBhbGwgbm9kZSBrZXlzXG4gICAgICogQHJldHVybnMgQXBpUXVlcnlSZXNwb25zZVxuICAgICAqL1xuICAgICN2ZXJpZnlRdWVyeVJlc3BvbnNlO1xuICAgIGFzeW5jIGNyZWF0ZVJlYWRTdGF0ZVJlcXVlc3QoZmllbGRzLCBpZGVudGl0eSkge1xuICAgICAgICBhd2FpdCB0aGlzLiNhc3luY0d1YXJkKCk7XG4gICAgICAgIGNvbnN0IGlkID0gYXdhaXQgKGlkZW50aXR5ID8/IHRoaXMuI2lkZW50aXR5KTtcbiAgICAgICAgaWYgKCFpZCkge1xuICAgICAgICAgICAgdGhyb3cgRXh0ZXJuYWxFcnJvci5mcm9tQ29kZShuZXcgSWRlbnRpdHlJbnZhbGlkRXJyb3JDb2RlKCkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlbmRlciA9IGlkLmdldFByaW5jaXBhbCgpO1xuICAgICAgICBjb25zdCB0cmFuc2Zvcm1lZFJlcXVlc3QgPSBhd2FpdCB0aGlzLl90cmFuc2Zvcm0oe1xuICAgICAgICAgICAgcmVxdWVzdDoge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9jYm9yJyxcbiAgICAgICAgICAgICAgICAgICAgLi4uKHRoaXMuI2NyZWRlbnRpYWxzID8geyBBdXRob3JpemF0aW9uOiAnQmFzaWMgJyArIGJ0b2EodGhpcy4jY3JlZGVudGlhbHMpIH0gOiB7fSksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbmRwb2ludDogRW5kcG9pbnQuUmVhZFN0YXRlLFxuICAgICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgICAgIHJlcXVlc3RfdHlwZTogUmVhZFJlcXVlc3RUeXBlLlJlYWRTdGF0ZSxcbiAgICAgICAgICAgICAgICBwYXRoczogZmllbGRzLnBhdGhzLFxuICAgICAgICAgICAgICAgIHNlbmRlcixcbiAgICAgICAgICAgICAgICBpbmdyZXNzX2V4cGlyeTogY2FsY3VsYXRlSW5ncmVzc0V4cGlyeSh0aGlzLiNtYXhJbmdyZXNzRXhwaXJ5SW5NaW51dGVzLCB0aGlzLiN0aW1lRGlmZk1zZWNzKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBBcHBseSB0cmFuc2Zvcm0gZm9yIGlkZW50aXR5LlxuICAgICAgICByZXR1cm4gaWQudHJhbnNmb3JtUmVxdWVzdCh0cmFuc2Zvcm1lZFJlcXVlc3QpO1xuICAgIH1cbiAgICBhc3luYyByZWFkU3RhdGUoY2FuaXN0ZXJJZCwgZmllbGRzLCBfaWRlbnRpdHksIFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgIHJlcXVlc3QpIHtcbiAgICAgICAgYXdhaXQgdGhpcy4jcm9vdEtleUd1YXJkKCk7XG4gICAgICAgIGNvbnN0IGNhbmlzdGVyID0gUHJpbmNpcGFsLmZyb20oY2FuaXN0ZXJJZCk7XG4gICAgICAgIGZ1bmN0aW9uIGdldFJlcXVlc3RJZChvcHRpb25zKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHBhdGggb2Ygb3B0aW9ucy5wYXRocykge1xuICAgICAgICAgICAgICAgIGNvbnN0IFtwYXRoTmFtZSwgdmFsdWVdID0gcGF0aDtcbiAgICAgICAgICAgICAgICBjb25zdCByZXF1ZXN0X3N0YXR1cyA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZSgncmVxdWVzdF9zdGF0dXMnKTtcbiAgICAgICAgICAgICAgICBpZiAodWludDhFcXVhbHMocGF0aE5hbWUsIHJlcXVlc3Rfc3RhdHVzKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZFJlcXVlc3Q7XG4gICAgICAgIGxldCByZXF1ZXN0SWQ7XG4gICAgICAgIC8vIElmIGEgcHJlLXNpZ25lZCByZXF1ZXN0IGlzIHByb3ZpZGVkLCB1c2UgaXRcbiAgICAgICAgaWYgKHJlcXVlc3QpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBwcmUtc2lnbmVkIHJlcXVlc3RcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkUmVxdWVzdCA9IHJlcXVlc3Q7XG4gICAgICAgICAgICByZXF1ZXN0SWQgPSByZXF1ZXN0SWRPZih0cmFuc2Zvcm1lZFJlcXVlc3QpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gVGhpcyBpcyBmaWVsZHMsIHdlIG5lZWQgdG8gY3JlYXRlIGEgcmVxdWVzdFxuICAgICAgICAgICAgcmVxdWVzdElkID0gZ2V0UmVxdWVzdElkKGZpZWxkcyk7XG4gICAgICAgICAgICAvLyBBbHdheXMgY3JlYXRlIGEgZnJlc2ggcmVxdWVzdCB3aXRoIHRoZSBjdXJyZW50IGlkZW50aXR5XG4gICAgICAgICAgICBjb25zdCBpZGVudGl0eSA9IGF3YWl0IHRoaXMuI2lkZW50aXR5O1xuICAgICAgICAgICAgaWYgKCFpZGVudGl0eSkge1xuICAgICAgICAgICAgICAgIHRocm93IEV4dGVybmFsRXJyb3IuZnJvbUNvZGUobmV3IElkZW50aXR5SW52YWxpZEVycm9yQ29kZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyYW5zZm9ybWVkUmVxdWVzdCA9IGF3YWl0IHRoaXMuY3JlYXRlUmVhZFN0YXRlUmVxdWVzdChmaWVsZHMsIGlkZW50aXR5KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxvZy5wcmludChgZmV0Y2hpbmcgXCIvYXBpL3YyL2NhbmlzdGVyLyR7Y2FuaXN0ZXJ9L3JlYWRfc3RhdGVcIiB3aXRoIHJlcXVlc3Q6YCwgdHJhbnNmb3JtZWRSZXF1ZXN0KTtcbiAgICAgICAgY29uc3QgYmFja29mZiA9IHRoaXMuI2JhY2tvZmZTdHJhdGVneSgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgeyByZXNwb25zZUJvZHlCeXRlcyB9ID0gYXdhaXQgdGhpcy4jcmVxdWVzdEFuZFJldHJ5KHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0Rm46ICgpID0+IHRoaXMuI2ZldGNoKCcnICsgbmV3IFVSTChgL2FwaS92Mi9jYW5pc3Rlci8ke2NhbmlzdGVyLnRvU3RyaW5nKCl9L3JlYWRfc3RhdGVgLCB0aGlzLmhvc3QpLCB7XG4gICAgICAgICAgICAgICAgICAgIC4uLnRoaXMuI2ZldGNoT3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgLi4udHJhbnNmb3JtZWRSZXF1ZXN0LnJlcXVlc3QsXG4gICAgICAgICAgICAgICAgICAgIGJvZHk6IGNib3IuZW5jb2RlKHRyYW5zZm9ybWVkUmVxdWVzdC5ib2R5KSxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBiYWNrb2ZmLFxuICAgICAgICAgICAgICAgIHRyaWVzOiAwLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBkZWNvZGVkUmVzcG9uc2UgPSBjYm9yLmRlY29kZShyZXNwb25zZUJvZHlCeXRlcyk7XG4gICAgICAgICAgICB0aGlzLmxvZy5wcmludCgnUmVhZCBzdGF0ZSByZXNwb25zZTonLCBkZWNvZGVkUmVzcG9uc2UpO1xuICAgICAgICAgICAgcmV0dXJuIGRlY29kZWRSZXNwb25zZTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGxldCByZWFkU3RhdGVFcnJvcjtcbiAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEFnZW50RXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBvdmVycmlkZSB0aGUgZXJyb3IgY29kZSB0byBpbmNsdWRlIHRoZSByZXF1ZXN0IGRldGFpbHNcbiAgICAgICAgICAgICAgICBlcnJvci5jb2RlLnJlcXVlc3RDb250ZXh0ID0ge1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0SWQsXG4gICAgICAgICAgICAgICAgICAgIHNlbmRlclB1YktleTogdHJhbnNmb3JtZWRSZXF1ZXN0LmJvZHkuc2VuZGVyX3B1YmtleSxcbiAgICAgICAgICAgICAgICAgICAgc2VuZGVyU2lnbmF0dXJlOiB0cmFuc2Zvcm1lZFJlcXVlc3QuYm9keS5zZW5kZXJfc2lnLFxuICAgICAgICAgICAgICAgICAgICBpbmdyZXNzRXhwaXJ5OiB0cmFuc2Zvcm1lZFJlcXVlc3QuYm9keS5jb250ZW50LmluZ3Jlc3NfZXhwaXJ5LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmVhZFN0YXRlRXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlYWRTdGF0ZUVycm9yID0gVW5rbm93bkVycm9yLmZyb21Db2RlKG5ldyBVbmV4cGVjdGVkRXJyb3JDb2RlKGVycm9yKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmxvZy5lcnJvcihgRXJyb3Igd2hpbGUgbWFraW5nIHJlYWQgc3RhdGU6ICR7cmVhZFN0YXRlRXJyb3IubWVzc2FnZX1gLCByZWFkU3RhdGVFcnJvcik7XG4gICAgICAgICAgICB0aHJvdyByZWFkU3RhdGVFcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwYXJzZVRpbWVGcm9tUmVzcG9uc2UocmVzcG9uc2UpIHtcbiAgICAgICAgbGV0IHRyZWU7XG4gICAgICAgIGlmIChyZXNwb25zZS5jZXJ0aWZpY2F0ZSkge1xuICAgICAgICAgICAgY29uc3QgZGVjb2RlZCA9IGNib3IuZGVjb2RlKHJlc3BvbnNlLmNlcnRpZmljYXRlKTtcbiAgICAgICAgICAgIGlmIChkZWNvZGVkICYmICd0cmVlJyBpbiBkZWNvZGVkKSB7XG4gICAgICAgICAgICAgICAgdHJlZSA9IGRlY29kZWQudHJlZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IFByb3RvY29sRXJyb3IuZnJvbUNvZGUobmV3IEhhc2hUcmVlRGVjb2RlRXJyb3JDb2RlKCdDb3VsZCBub3QgZGVjb2RlIHRpbWUgZnJvbSByZXNwb25zZScpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHRpbWVMb29rdXAgPSBsb29rdXBfcGF0aChbJ3RpbWUnXSwgdHJlZSk7XG4gICAgICAgICAgICBpZiAodGltZUxvb2t1cC5zdGF0dXMgIT09IExvb2t1cFBhdGhTdGF0dXMuRm91bmQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBQcm90b2NvbEVycm9yLmZyb21Db2RlKG5ldyBMb29rdXBFcnJvckNvZGUoJ1RpbWUgd2FzIG5vdCBmb3VuZCBpbiB0aGUgcmVzcG9uc2Ugb3Igd2FzIG5vdCBpbiBpdHMgZXhwZWN0ZWQgZm9ybWF0LicsIHRpbWVMb29rdXAuc3RhdHVzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoISh0aW1lTG9va3VwLnZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSkgJiYgIUFycmF5QnVmZmVyLmlzVmlldyh0aW1lTG9va3VwKSkge1xuICAgICAgICAgICAgICAgIHRocm93IFByb3RvY29sRXJyb3IuZnJvbUNvZGUobmV3IE1hbGZvcm1lZExvb2t1cEZvdW5kVmFsdWVFcnJvckNvZGUoJ1RpbWUgd2FzIG5vdCBpbiBpdHMgZXhwZWN0ZWQgZm9ybWF0LicpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGRhdGUgPSBkZWNvZGVUaW1lKHRpbWVMb29rdXAudmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5sb2cucHJpbnQoJ1RpbWUgZnJvbSByZXNwb25zZTonLCBkYXRlKTtcbiAgICAgICAgICAgIHRoaXMubG9nLnByaW50KCdUaW1lIGZyb20gcmVzcG9uc2UgaW4gbWlsbGlzZWNvbmRzOicsIGRhdGUuZ2V0VGltZSgpKTtcbiAgICAgICAgICAgIHJldHVybiBkYXRlLmdldFRpbWUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubG9nLndhcm4oJ05vIGNlcnRpZmljYXRlIGZvdW5kIGluIHJlc3BvbnNlJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFsbG93cyBhZ2VudCB0byBzeW5jIGl0cyB0aW1lIHdpdGggdGhlIG5ldHdvcmsuIENhbiBiZSBjYWxsZWQgZHVyaW5nIGludGlhbGl6YXRpb24gb3IgbWlkLWxpZmVjeWNsZSBpZiB0aGUgZGV2aWNlJ3MgY2xvY2sgaGFzIGRyaWZ0ZWQgYXdheSBmcm9tIHRoZSBuZXR3b3JrIHRpbWUuIFRoaXMgaXMgbmVjZXNzYXJ5IHRvIHNldCB0aGUgRXhwaXJ5IGZvciBhIHJlcXVlc3RcbiAgICAgKiBAcGFyYW0ge1ByaW5jaXBhbH0gY2FuaXN0ZXJJZE92ZXJyaWRlIC0gUGFzcyBhIGNhbmlzdGVyIElEIGlmIHlvdSBuZWVkIHRvIHN5bmMgdGhlIHRpbWUgd2l0aCBhIHBhcnRpY3VsYXIgc3VibmV0LiBVc2VzIHRoZSBJQ1AgbGVkZ2VyIGNhbmlzdGVyIGJ5IGRlZmF1bHQuXG4gICAgICovXG4gICAgYXN5bmMgc3luY1RpbWUoY2FuaXN0ZXJJZE92ZXJyaWRlKSB7XG4gICAgICAgIHRoaXMuI3N5bmNUaW1lUHJvbWlzZSA9XG4gICAgICAgICAgICB0aGlzLiNzeW5jVGltZVByb21pc2UgPz9cbiAgICAgICAgICAgICAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLiNyb290S2V5R3VhcmQoKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FsbFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjYW5pc3RlcklkT3ZlcnJpZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZy5wcmludCgnU3luY2luZyB0aW1lIHdpdGggdGhlIElDLiBObyBjYW5pc3RlcklkIHByb3ZpZGVkLCBzbyBmYWxsaW5nIGJhY2sgdG8gcnlqbDMtdHlhYWEtYWFhYWEtYWFhYmEtY2FpJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGYWxsIGJhY2sgd2l0aCBjYW5pc3RlcklkIG9mIHRoZSBJQ1AgTGVkZ2VyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjYW5pc3RlcklkID0gY2FuaXN0ZXJJZE92ZXJyaWRlID8/IFByaW5jaXBhbC5mcm9tKCdyeWpsMy10eWFhYS1hYWFhYS1hYWFiYS1jYWknKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGFub255bW91c0FnZW50ID0gSHR0cEFnZW50LmNyZWF0ZVN5bmMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkZW50aXR5OiBuZXcgQW5vbnltb3VzSWRlbnRpdHkoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBob3N0OiB0aGlzLmhvc3QudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmZXRjaDogdGhpcy4jZmV0Y2gsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0cnlUaW1lczogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb290S2V5OiB0aGlzLnJvb3RLZXkgPz8gdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3VsZFN5bmNUaW1lOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVwbGljYVRpbWVzID0gYXdhaXQgUHJvbWlzZS5hbGwoQXJyYXkoMylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZmlsbChudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0YXR1cyA9IGF3YWl0IGNhbmlzdGVyU3RhdHVzUmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbmlzdGVySWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFnZW50OiBhbm9ueW1vdXNBZ2VudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aHM6IFsndGltZSddLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNhYmxlQ2VydGlmaWNhdGVUaW1lVmVyaWZpY2F0aW9uOiB0cnVlLCAvLyBhdm9pZCByZWN1cnNpdmUgY2FsbHMgdG8gc3luY1RpbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRlID0gc3RhdHVzLmdldCgndGltZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0ZS5nZXRUaW1lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgW10pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1heFJlcGxpY2FUaW1lID0gcmVwbGljYVRpbWVzLnJlZHVjZSgobWF4LCBjdXJyZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBjdXJyZW50ID09PSAnbnVtYmVyJyAmJiBjdXJyZW50ID4gbWF4ID8gY3VycmVudCA6IG1heDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1heFJlcGxpY2FUaW1lID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuI3RpbWVEaWZmTXNlY3MgPSBtYXhSZXBsaWNhVGltZSAtIGNhbGxUaW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuI2hhc1N5bmNlZFRpbWUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubG9nLm5vdGlmeSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGBTeW5jaW5nIHRpbWU6IG9mZnNldCBvZiAke3RoaXMuI3RpbWVEaWZmTXNlY3N9YCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV2ZWw6ICdpbmZvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHN5bmNUaW1lRXJyb3IgPSBlcnJvciBpbnN0YW5jZW9mIEFnZW50RXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBVbmtub3duRXJyb3IuZnJvbUNvZGUobmV3IFVuZXhwZWN0ZWRFcnJvckNvZGUoZXJyb3IpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubG9nLmVycm9yKCdDYXVnaHQgZXhjZXB0aW9uIHdoaWxlIGF0dGVtcHRpbmcgdG8gc3luYyB0aW1lJywgc3luY1RpbWVFcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBzeW5jVGltZUVycm9yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgYXdhaXQgdGhpcy4jc3luY1RpbWVQcm9taXNlLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy4jc3luY1RpbWVQcm9taXNlID0gbnVsbDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIHN0YXR1cygpIHtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHRoaXMuI2NyZWRlbnRpYWxzXG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICBBdXRob3JpemF0aW9uOiAnQmFzaWMgJyArIGJ0b2EodGhpcy4jY3JlZGVudGlhbHMpLFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiB7fTtcbiAgICAgICAgdGhpcy5sb2cucHJpbnQoYGZldGNoaW5nIFwiL2FwaS92Mi9zdGF0dXNcImApO1xuICAgICAgICBjb25zdCBiYWNrb2ZmID0gdGhpcy4jYmFja29mZlN0cmF0ZWd5KCk7XG4gICAgICAgIGNvbnN0IHsgcmVzcG9uc2VCb2R5Qnl0ZXMgfSA9IGF3YWl0IHRoaXMuI3JlcXVlc3RBbmRSZXRyeSh7XG4gICAgICAgICAgICBiYWNrb2ZmLFxuICAgICAgICAgICAgcmVxdWVzdEZuOiAoKSA9PiB0aGlzLiNmZXRjaCgnJyArIG5ldyBVUkwoYC9hcGkvdjIvc3RhdHVzYCwgdGhpcy5ob3N0KSwgeyBoZWFkZXJzLCAuLi50aGlzLiNmZXRjaE9wdGlvbnMgfSksXG4gICAgICAgICAgICB0cmllczogMCxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjYm9yLmRlY29kZShyZXNwb25zZUJvZHlCeXRlcyk7XG4gICAgfVxuICAgIGFzeW5jIGZldGNoUm9vdEtleSgpIHtcbiAgICAgICAgLy8gV2FpdCBmb3IgYWxyZWFkeSBwZW5kaW5nIHByb21pc2UgdG8gYXZvaWQgZHVwbGljYXRlIGNhbGxzXG4gICAgICAgIHRoaXMuI3Jvb3RLZXlQcm9taXNlID1cbiAgICAgICAgICAgIHRoaXMuI3Jvb3RLZXlQcm9taXNlID8/XG4gICAgICAgICAgICAgICAgKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBhd2FpdCB0aGlzLnN0YXR1cygpO1xuICAgICAgICAgICAgICAgICAgICAvLyBIZXgtZW5jb2RlZCB2ZXJzaW9uIG9mIHRoZSByZXBsaWNhIHJvb3Qga2V5XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucm9vdEtleSA9IHZhbHVlLnJvb3Rfa2V5O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yb290S2V5O1xuICAgICAgICAgICAgICAgIH0pKCk7XG4gICAgICAgIC8vIGNsZWFyIHJvb3RrZXkgcHJvbWlzZSBhbmQgcmV0dXJuIHJlc3VsdFxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy4jcm9vdEtleVByb21pc2UuZmluYWxseSgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLiNyb290S2V5UHJvbWlzZSA9IG51bGw7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyAjYXN5bmNHdWFyZChjYW5pc3RlcklkT3ZlcnJpZGUpIHtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoW3RoaXMuI3Jvb3RLZXlHdWFyZCgpLCB0aGlzLiNzeW5jVGltZUd1YXJkKGNhbmlzdGVySWRPdmVycmlkZSldKTtcbiAgICB9XG4gICAgYXN5bmMgI3Jvb3RLZXlHdWFyZCgpIHtcbiAgICAgICAgaWYgKHRoaXMucm9vdEtleSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMucm9vdEtleSA9PT0gbnVsbCAmJlxuICAgICAgICAgICAgdGhpcy5ob3N0LnRvU3RyaW5nKCkgIT09ICdodHRwczovL2ljcC1hcGkuaW8nICYmXG4gICAgICAgICAgICB0aGlzLiNzaG91bGRGZXRjaFJvb3RLZXkpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuZmV0Y2hSb290S2V5KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBFeHRlcm5hbEVycm9yLmZyb21Db2RlKG5ldyBNaXNzaW5nUm9vdEtleUVycm9yQ29kZSh0aGlzLiNzaG91bGRGZXRjaFJvb3RLZXkpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyAjc3luY1RpbWVHdWFyZChjYW5pc3RlcklkT3ZlcnJpZGUpIHtcbiAgICAgICAgaWYgKHRoaXMuI3Nob3VsZFN5bmNUaW1lICYmICF0aGlzLmhhc1N5bmNlZFRpbWUoKSkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5zeW5jVGltZShjYW5pc3RlcklkT3ZlcnJpZGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGludmFsaWRhdGVJZGVudGl0eSgpIHtcbiAgICAgICAgdGhpcy4jaWRlbnRpdHkgPSBudWxsO1xuICAgIH1cbiAgICByZXBsYWNlSWRlbnRpdHkoaWRlbnRpdHkpIHtcbiAgICAgICAgdGhpcy4jaWRlbnRpdHkgPSBQcm9taXNlLnJlc29sdmUoaWRlbnRpdHkpO1xuICAgIH1cbiAgICBhc3luYyBmZXRjaFN1Ym5ldEtleXMoY2FuaXN0ZXJJZCkge1xuICAgICAgICBjb25zdCBlZmZlY3RpdmVDYW5pc3RlcklkID0gUHJpbmNpcGFsLmZyb20oY2FuaXN0ZXJJZCk7XG4gICAgICAgIGF3YWl0IHRoaXMuI2FzeW5jR3VhcmQoZWZmZWN0aXZlQ2FuaXN0ZXJJZCk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY2FuaXN0ZXJTdGF0dXNSZXF1ZXN0KHtcbiAgICAgICAgICAgIGNhbmlzdGVySWQ6IGVmZmVjdGl2ZUNhbmlzdGVySWQsXG4gICAgICAgICAgICBwYXRoczogWydzdWJuZXQnXSxcbiAgICAgICAgICAgIGFnZW50OiB0aGlzLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3Qgc3VibmV0UmVzcG9uc2UgPSByZXNwb25zZS5nZXQoJ3N1Ym5ldCcpO1xuICAgICAgICBpZiAoc3VibmV0UmVzcG9uc2UgJiYgdHlwZW9mIHN1Ym5ldFJlc3BvbnNlID09PSAnb2JqZWN0JyAmJiAnbm9kZUtleXMnIGluIHN1Ym5ldFJlc3BvbnNlKSB7XG4gICAgICAgICAgICB0aGlzLiNzdWJuZXRLZXlzLnNldChlZmZlY3RpdmVDYW5pc3RlcklkLnRvVGV4dCgpLCBzdWJuZXRSZXNwb25zZSk7XG4gICAgICAgICAgICByZXR1cm4gc3VibmV0UmVzcG9uc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIHN1Ym5ldCBzdGF0dXMgaXMgbm90IHJldHVybmVkLCByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIF90cmFuc2Zvcm0ocmVxdWVzdCkge1xuICAgICAgICBsZXQgcCA9IFByb21pc2UucmVzb2x2ZShyZXF1ZXN0KTtcbiAgICAgICAgaWYgKHJlcXVlc3QuZW5kcG9pbnQgPT09IEVuZHBvaW50LkNhbGwpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZm4gb2YgdGhpcy4jdXBkYXRlUGlwZWxpbmUpIHtcbiAgICAgICAgICAgICAgICBwID0gcC50aGVuKHIgPT4gZm4ocikudGhlbihyMiA9PiByMiB8fCByKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGZuIG9mIHRoaXMuI3F1ZXJ5UGlwZWxpbmUpIHtcbiAgICAgICAgICAgICAgICBwID0gcC50aGVuKHIgPT4gZm4ocikudGhlbihyMiA9PiByMiB8fCByKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHRpbWUgZGlmZmVyZW5jZSBpbiBtaWxsaXNlY29uZHMgYmV0d2VlbiB0aGUgSUMgbmV0d29yayBjbG9jayBhbmQgdGhlIGNsaWVudCdzIGNsb2NrLFxuICAgICAqIGFmdGVyIHRoZSBjbG9jayBoYXMgYmVlbiBzeW5jZWQuXG4gICAgICpcbiAgICAgKiBJZiB0aGUgdGltZSBoYXMgbm90IGJlZW4gc3luY2VkLCByZXR1cm5zIGAwYC5cbiAgICAgKi9cbiAgICBnZXRUaW1lRGlmZk1zZWNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jdGltZURpZmZNc2VjcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHRpbWUgaGFzIGJlZW4gc3luY2VkIGF0IGxlYXN0IG9uY2Ugd2l0aCB0aGUgSUMgbmV0d29yaywgYGZhbHNlYCBvdGhlcndpc2UuXG4gICAgICovXG4gICAgaGFzU3luY2VkVGltZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2hhc1N5bmNlZFRpbWU7XG4gICAgfVxufVxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBpbmdyZXNzIGV4cGlyeSB0aW1lIGJhc2VkIG9uIHRoZSBtYXhpbXVtIGFsbG93ZWQgZXhwaXJ5IGluIG1pbnV0ZXMgYW5kIHRoZSB0aW1lIGRpZmZlcmVuY2UgaW4gbWlsbGlzZWNvbmRzLlxuICogVGhlIGV4cGlyeSBpcyByb3VuZGVkIGRvd24gYWNjb3JkaW5nIHRvIHRoZSB7QGxpbmsgRXhwaXJ5LmZyb21EZWx0YUluTWlsbGlzZWNvbmRzfSBtZXRob2QuXG4gKiBAcGFyYW0gbWF4SW5ncmVzc0V4cGlyeUluTWludXRlcyAtIFRoZSBtYXhpbXVtIGluZ3Jlc3MgZXhwaXJ5IHRpbWUgaW4gbWludXRlcy5cbiAqIEBwYXJhbSB0aW1lRGlmZk1zZWNzIC0gVGhlIHRpbWUgZGlmZmVyZW5jZSBpbiBtaWxsaXNlY29uZHMgdG8gYWRqdXN0IHRoZSBleHBpcnkuXG4gKiBAcmV0dXJucyBUaGUgY2FsY3VsYXRlZCBpbmdyZXNzIGV4cGlyeSBhcyBhbiBFeHBpcnkgb2JqZWN0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlSW5ncmVzc0V4cGlyeShtYXhJbmdyZXNzRXhwaXJ5SW5NaW51dGVzLCB0aW1lRGlmZk1zZWNzKSB7XG4gICAgY29uc3QgaW5ncmVzc0V4cGlyeU1zID0gbWF4SW5ncmVzc0V4cGlyeUluTWludXRlcyAqIE1JTlVURV9UT19NU0VDUztcbiAgICByZXR1cm4gRXhwaXJ5LmZyb21EZWx0YUluTWlsbGlzZWNvbmRzKGluZ3Jlc3NFeHBpcnlNcywgdGltZURpZmZNc2Vjcyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/agent/http/index.js\n");

/***/ }),

/***/ "(ssr)/../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/agent/http/transforms.js":
/*!******************************************************************************************!*\
  !*** ../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/agent/http/transforms.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Expiry: () => (/* binding */ Expiry),\n/* harmony export */   JSON_KEY_EXPIRY: () => (/* binding */ JSON_KEY_EXPIRY),\n/* harmony export */   httpHeadersTransform: () => (/* binding */ httpHeadersTransform),\n/* harmony export */   makeExpiryTransform: () => (/* binding */ makeExpiryTransform),\n/* harmony export */   makeNonceTransform: () => (/* binding */ makeNonceTransform)\n/* harmony export */ });\n/* harmony import */ var _dfinity_candid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @dfinity/candid */ \"(ssr)/../../packages/sdk-js/node_modules/@dfinity/candid/lib/esm/utils/leb128.js\");\n/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./types.js */ \"(ssr)/../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/agent/http/types.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../errors.js */ \"(ssr)/../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/errors.js\");\n\n\n\nconst JSON_KEY_EXPIRY = '__expiry__';\nconst SECONDS_TO_MILLISECONDS = BigInt(1_000);\nconst MILLISECONDS_TO_NANOSECONDS = BigInt(1_000_000);\nconst MINUTES_TO_SECONDS = BigInt(60);\nconst EXPIRY_DELTA_THRESHOLD_MILLISECONDS = BigInt(90) * SECONDS_TO_MILLISECONDS;\nfunction roundMillisToSeconds(millis) {\n    return millis / SECONDS_TO_MILLISECONDS;\n}\nfunction roundMillisToMinutes(millis) {\n    return roundMillisToSeconds(millis) / MINUTES_TO_SECONDS;\n}\nclass Expiry {\n    constructor(__expiry__) {\n        this.__expiry__ = __expiry__;\n        this._isExpiry = true;\n    }\n    /**\n     * Creates an Expiry object from a delta in milliseconds.\n     * If the delta is less than 90 seconds, the expiry is rounded down to the nearest second.\n     * Otherwise, the expiry is rounded down to the nearest minute.\n     * @param deltaInMs The milliseconds to add to the current time.\n     * @param clockDriftMs The milliseconds to add to the current time, typically the clock drift between IC network clock and the client's clock. Defaults to `0` if not provided.\n     * @returns {Expiry} The constructed Expiry object.\n     */\n    static fromDeltaInMilliseconds(deltaInMs, clockDriftMs = 0) {\n        const deltaMs = BigInt(deltaInMs);\n        const expiryMs = BigInt(Date.now()) + deltaMs + BigInt(clockDriftMs);\n        let roundedExpirySeconds;\n        if (deltaMs < EXPIRY_DELTA_THRESHOLD_MILLISECONDS) {\n            roundedExpirySeconds = roundMillisToSeconds(expiryMs);\n        }\n        else {\n            const roundedExpiryMinutes = roundMillisToMinutes(expiryMs);\n            roundedExpirySeconds = roundedExpiryMinutes * MINUTES_TO_SECONDS;\n        }\n        return new Expiry(roundedExpirySeconds * SECONDS_TO_MILLISECONDS * MILLISECONDS_TO_NANOSECONDS);\n    }\n    toBigInt() {\n        return this.__expiry__;\n    }\n    toHash() {\n        return (0,_dfinity_candid__WEBPACK_IMPORTED_MODULE_0__.lebEncode)(this.__expiry__);\n    }\n    toString() {\n        return this.__expiry__.toString();\n    }\n    /**\n     * Serializes to JSON\n     * @returns {JsonnableExpiry} a JSON object with a single key, {@link JSON_KEY_EXPIRY}, whose value is the expiry as a string\n     */\n    toJSON() {\n        return { [JSON_KEY_EXPIRY]: this.toString() };\n    }\n    /**\n     * Deserializes a {@link JsonnableExpiry} object from a JSON string.\n     * @param input The JSON string to deserialize.\n     * @returns {Expiry} The deserialized Expiry object.\n     */\n    static fromJSON(input) {\n        const obj = JSON.parse(input);\n        if (obj[JSON_KEY_EXPIRY]) {\n            try {\n                const expiry = BigInt(obj[JSON_KEY_EXPIRY]);\n                return new Expiry(expiry);\n            }\n            catch (error) {\n                throw new _errors_js__WEBPACK_IMPORTED_MODULE_1__.InputError(new _errors_js__WEBPACK_IMPORTED_MODULE_1__.ExpiryJsonDeserializeErrorCode(`Not a valid BigInt: ${error}`));\n            }\n        }\n        throw new _errors_js__WEBPACK_IMPORTED_MODULE_1__.InputError(new _errors_js__WEBPACK_IMPORTED_MODULE_1__.ExpiryJsonDeserializeErrorCode(`The input does not contain the key ${JSON_KEY_EXPIRY}`));\n    }\n    static isExpiry(other) {\n        return (other instanceof Expiry ||\n            (typeof other === 'object' &&\n                other !== null &&\n                '_isExpiry' in other &&\n                other['_isExpiry'] === true &&\n                '__expiry__' in other &&\n                typeof other['__expiry__'] === 'bigint'));\n    }\n}\n/**\n * Create a Nonce transform, which takes a function that returns a Buffer, and adds it\n * as the nonce to every call requests.\n * @param nonceFn A function that returns a buffer. By default uses a semi-random method.\n */\nfunction makeNonceTransform(nonceFn = _types_js__WEBPACK_IMPORTED_MODULE_2__.makeNonce) {\n    return async (request) => {\n        // Nonce needs to be inserted into the header for all requests, to enable logs to be correlated with requests.\n        const headers = request.request.headers;\n        // TODO: uncomment this when the http proxy supports it.\n        // headers.set('X-IC-Request-ID', toHex(new Uint8Array(nonce)));\n        request.request.headers = headers;\n        // Nonce only needs to be inserted into the body for async calls, to prevent replay attacks.\n        if (request.endpoint === _types_js__WEBPACK_IMPORTED_MODULE_2__.Endpoint.Call) {\n            request.body.nonce = nonceFn();\n        }\n    };\n}\n/**\n * Create a transform that adds a delay (by default 5 minutes) to the expiry.\n * @param delayInMilliseconds The delay to add to the call time, in milliseconds.\n */\nfunction makeExpiryTransform(delayInMilliseconds) {\n    return async (request) => {\n        request.body.ingress_expiry = Expiry.fromDeltaInMilliseconds(delayInMilliseconds);\n    };\n}\n/**\n * Maps the default fetch headers field to the serializable HttpHeaderField.\n * @param headers Fetch definition of the headers type\n * @returns array of header fields\n */\nfunction httpHeadersTransform(headers) {\n    const headerFields = [];\n    headers.forEach((value, key) => {\n        headerFields.push([key, value]);\n    });\n    return headerFields;\n}\n//# sourceMappingURL=transforms.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vcGFja2FnZXMvc2RrLWpzL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL2FnZW50L2h0dHAvdHJhbnNmb3Jtcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUE0QztBQUNNO0FBQzJCO0FBQ3RFO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwwREFBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsaUJBQWlCLGtDQUFrQyxzQkFBc0I7QUFDMUY7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsdUJBQXVCLHVCQUF1QjtBQUM5QztBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixrREFBVSxLQUFLLHNFQUE4Qix3QkFBd0IsTUFBTTtBQUNyRztBQUNBO0FBQ0Esa0JBQWtCLGtEQUFVLEtBQUssc0VBQThCLHVDQUF1QyxnQkFBZ0I7QUFDdEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxzQ0FBc0MsZ0RBQVM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsK0NBQVE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGlxdWJlL29wcy1jb25zb2xlLy4uLy4uL3BhY2thZ2VzL3Nkay1qcy9ub2RlX21vZHVsZXMvQGRmaW5pdHkvYWdlbnQvbGliL2VzbS9hZ2VudC9odHRwL3RyYW5zZm9ybXMuanM/ZTQ5YiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBsZWJFbmNvZGUgfSBmcm9tICdAZGZpbml0eS9jYW5kaWQnO1xuaW1wb3J0IHsgRW5kcG9pbnQsIG1ha2VOb25jZSwgfSBmcm9tIFwiLi90eXBlcy5qc1wiO1xuaW1wb3J0IHsgRXhwaXJ5SnNvbkRlc2VyaWFsaXplRXJyb3JDb2RlLCBJbnB1dEVycm9yIH0gZnJvbSBcIi4uLy4uL2Vycm9ycy5qc1wiO1xuZXhwb3J0IGNvbnN0IEpTT05fS0VZX0VYUElSWSA9ICdfX2V4cGlyeV9fJztcbmNvbnN0IFNFQ09ORFNfVE9fTUlMTElTRUNPTkRTID0gQmlnSW50KDFfMDAwKTtcbmNvbnN0IE1JTExJU0VDT05EU19UT19OQU5PU0VDT05EUyA9IEJpZ0ludCgxXzAwMF8wMDApO1xuY29uc3QgTUlOVVRFU19UT19TRUNPTkRTID0gQmlnSW50KDYwKTtcbmNvbnN0IEVYUElSWV9ERUxUQV9USFJFU0hPTERfTUlMTElTRUNPTkRTID0gQmlnSW50KDkwKSAqIFNFQ09ORFNfVE9fTUlMTElTRUNPTkRTO1xuZnVuY3Rpb24gcm91bmRNaWxsaXNUb1NlY29uZHMobWlsbGlzKSB7XG4gICAgcmV0dXJuIG1pbGxpcyAvIFNFQ09ORFNfVE9fTUlMTElTRUNPTkRTO1xufVxuZnVuY3Rpb24gcm91bmRNaWxsaXNUb01pbnV0ZXMobWlsbGlzKSB7XG4gICAgcmV0dXJuIHJvdW5kTWlsbGlzVG9TZWNvbmRzKG1pbGxpcykgLyBNSU5VVEVTX1RPX1NFQ09ORFM7XG59XG5leHBvcnQgY2xhc3MgRXhwaXJ5IHtcbiAgICBjb25zdHJ1Y3RvcihfX2V4cGlyeV9fKSB7XG4gICAgICAgIHRoaXMuX19leHBpcnlfXyA9IF9fZXhwaXJ5X187XG4gICAgICAgIHRoaXMuX2lzRXhwaXJ5ID0gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBFeHBpcnkgb2JqZWN0IGZyb20gYSBkZWx0YSBpbiBtaWxsaXNlY29uZHMuXG4gICAgICogSWYgdGhlIGRlbHRhIGlzIGxlc3MgdGhhbiA5MCBzZWNvbmRzLCB0aGUgZXhwaXJ5IGlzIHJvdW5kZWQgZG93biB0byB0aGUgbmVhcmVzdCBzZWNvbmQuXG4gICAgICogT3RoZXJ3aXNlLCB0aGUgZXhwaXJ5IGlzIHJvdW5kZWQgZG93biB0byB0aGUgbmVhcmVzdCBtaW51dGUuXG4gICAgICogQHBhcmFtIGRlbHRhSW5NcyBUaGUgbWlsbGlzZWNvbmRzIHRvIGFkZCB0byB0aGUgY3VycmVudCB0aW1lLlxuICAgICAqIEBwYXJhbSBjbG9ja0RyaWZ0TXMgVGhlIG1pbGxpc2Vjb25kcyB0byBhZGQgdG8gdGhlIGN1cnJlbnQgdGltZSwgdHlwaWNhbGx5IHRoZSBjbG9jayBkcmlmdCBiZXR3ZWVuIElDIG5ldHdvcmsgY2xvY2sgYW5kIHRoZSBjbGllbnQncyBjbG9jay4gRGVmYXVsdHMgdG8gYDBgIGlmIG5vdCBwcm92aWRlZC5cbiAgICAgKiBAcmV0dXJucyB7RXhwaXJ5fSBUaGUgY29uc3RydWN0ZWQgRXhwaXJ5IG9iamVjdC5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbURlbHRhSW5NaWxsaXNlY29uZHMoZGVsdGFJbk1zLCBjbG9ja0RyaWZ0TXMgPSAwKSB7XG4gICAgICAgIGNvbnN0IGRlbHRhTXMgPSBCaWdJbnQoZGVsdGFJbk1zKTtcbiAgICAgICAgY29uc3QgZXhwaXJ5TXMgPSBCaWdJbnQoRGF0ZS5ub3coKSkgKyBkZWx0YU1zICsgQmlnSW50KGNsb2NrRHJpZnRNcyk7XG4gICAgICAgIGxldCByb3VuZGVkRXhwaXJ5U2Vjb25kcztcbiAgICAgICAgaWYgKGRlbHRhTXMgPCBFWFBJUllfREVMVEFfVEhSRVNIT0xEX01JTExJU0VDT05EUykge1xuICAgICAgICAgICAgcm91bmRlZEV4cGlyeVNlY29uZHMgPSByb3VuZE1pbGxpc1RvU2Vjb25kcyhleHBpcnlNcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCByb3VuZGVkRXhwaXJ5TWludXRlcyA9IHJvdW5kTWlsbGlzVG9NaW51dGVzKGV4cGlyeU1zKTtcbiAgICAgICAgICAgIHJvdW5kZWRFeHBpcnlTZWNvbmRzID0gcm91bmRlZEV4cGlyeU1pbnV0ZXMgKiBNSU5VVEVTX1RPX1NFQ09ORFM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBFeHBpcnkocm91bmRlZEV4cGlyeVNlY29uZHMgKiBTRUNPTkRTX1RPX01JTExJU0VDT05EUyAqIE1JTExJU0VDT05EU19UT19OQU5PU0VDT05EUyk7XG4gICAgfVxuICAgIHRvQmlnSW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX2V4cGlyeV9fO1xuICAgIH1cbiAgICB0b0hhc2goKSB7XG4gICAgICAgIHJldHVybiBsZWJFbmNvZGUodGhpcy5fX2V4cGlyeV9fKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fZXhwaXJ5X18udG9TdHJpbmcoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VyaWFsaXplcyB0byBKU09OXG4gICAgICogQHJldHVybnMge0pzb25uYWJsZUV4cGlyeX0gYSBKU09OIG9iamVjdCB3aXRoIGEgc2luZ2xlIGtleSwge0BsaW5rIEpTT05fS0VZX0VYUElSWX0sIHdob3NlIHZhbHVlIGlzIHRoZSBleHBpcnkgYXMgYSBzdHJpbmdcbiAgICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7IFtKU09OX0tFWV9FWFBJUlldOiB0aGlzLnRvU3RyaW5nKCkgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVzZXJpYWxpemVzIGEge0BsaW5rIEpzb25uYWJsZUV4cGlyeX0gb2JqZWN0IGZyb20gYSBKU09OIHN0cmluZy5cbiAgICAgKiBAcGFyYW0gaW5wdXQgVGhlIEpTT04gc3RyaW5nIHRvIGRlc2VyaWFsaXplLlxuICAgICAqIEByZXR1cm5zIHtFeHBpcnl9IFRoZSBkZXNlcmlhbGl6ZWQgRXhwaXJ5IG9iamVjdC5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oaW5wdXQpIHtcbiAgICAgICAgY29uc3Qgb2JqID0gSlNPTi5wYXJzZShpbnB1dCk7XG4gICAgICAgIGlmIChvYmpbSlNPTl9LRVlfRVhQSVJZXSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBleHBpcnkgPSBCaWdJbnQob2JqW0pTT05fS0VZX0VYUElSWV0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRXhwaXJ5KGV4cGlyeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW5wdXRFcnJvcihuZXcgRXhwaXJ5SnNvbkRlc2VyaWFsaXplRXJyb3JDb2RlKGBOb3QgYSB2YWxpZCBCaWdJbnQ6ICR7ZXJyb3J9YCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBJbnB1dEVycm9yKG5ldyBFeHBpcnlKc29uRGVzZXJpYWxpemVFcnJvckNvZGUoYFRoZSBpbnB1dCBkb2VzIG5vdCBjb250YWluIHRoZSBrZXkgJHtKU09OX0tFWV9FWFBJUll9YCkpO1xuICAgIH1cbiAgICBzdGF0aWMgaXNFeHBpcnkob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIChvdGhlciBpbnN0YW5jZW9mIEV4cGlyeSB8fFxuICAgICAgICAgICAgKHR5cGVvZiBvdGhlciA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgICAgICBvdGhlciAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgICdfaXNFeHBpcnknIGluIG90aGVyICYmXG4gICAgICAgICAgICAgICAgb3RoZXJbJ19pc0V4cGlyeSddID09PSB0cnVlICYmXG4gICAgICAgICAgICAgICAgJ19fZXhwaXJ5X18nIGluIG90aGVyICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIG90aGVyWydfX2V4cGlyeV9fJ10gPT09ICdiaWdpbnQnKSk7XG4gICAgfVxufVxuLyoqXG4gKiBDcmVhdGUgYSBOb25jZSB0cmFuc2Zvcm0sIHdoaWNoIHRha2VzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgQnVmZmVyLCBhbmQgYWRkcyBpdFxuICogYXMgdGhlIG5vbmNlIHRvIGV2ZXJ5IGNhbGwgcmVxdWVzdHMuXG4gKiBAcGFyYW0gbm9uY2VGbiBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIGJ1ZmZlci4gQnkgZGVmYXVsdCB1c2VzIGEgc2VtaS1yYW5kb20gbWV0aG9kLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWFrZU5vbmNlVHJhbnNmb3JtKG5vbmNlRm4gPSBtYWtlTm9uY2UpIHtcbiAgICByZXR1cm4gYXN5bmMgKHJlcXVlc3QpID0+IHtcbiAgICAgICAgLy8gTm9uY2UgbmVlZHMgdG8gYmUgaW5zZXJ0ZWQgaW50byB0aGUgaGVhZGVyIGZvciBhbGwgcmVxdWVzdHMsIHRvIGVuYWJsZSBsb2dzIHRvIGJlIGNvcnJlbGF0ZWQgd2l0aCByZXF1ZXN0cy5cbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHJlcXVlc3QucmVxdWVzdC5oZWFkZXJzO1xuICAgICAgICAvLyBUT0RPOiB1bmNvbW1lbnQgdGhpcyB3aGVuIHRoZSBodHRwIHByb3h5IHN1cHBvcnRzIGl0LlxuICAgICAgICAvLyBoZWFkZXJzLnNldCgnWC1JQy1SZXF1ZXN0LUlEJywgdG9IZXgobmV3IFVpbnQ4QXJyYXkobm9uY2UpKSk7XG4gICAgICAgIHJlcXVlc3QucmVxdWVzdC5oZWFkZXJzID0gaGVhZGVycztcbiAgICAgICAgLy8gTm9uY2Ugb25seSBuZWVkcyB0byBiZSBpbnNlcnRlZCBpbnRvIHRoZSBib2R5IGZvciBhc3luYyBjYWxscywgdG8gcHJldmVudCByZXBsYXkgYXR0YWNrcy5cbiAgICAgICAgaWYgKHJlcXVlc3QuZW5kcG9pbnQgPT09IEVuZHBvaW50LkNhbGwpIHtcbiAgICAgICAgICAgIHJlcXVlc3QuYm9keS5ub25jZSA9IG5vbmNlRm4oKTtcbiAgICAgICAgfVxuICAgIH07XG59XG4vKipcbiAqIENyZWF0ZSBhIHRyYW5zZm9ybSB0aGF0IGFkZHMgYSBkZWxheSAoYnkgZGVmYXVsdCA1IG1pbnV0ZXMpIHRvIHRoZSBleHBpcnkuXG4gKiBAcGFyYW0gZGVsYXlJbk1pbGxpc2Vjb25kcyBUaGUgZGVsYXkgdG8gYWRkIHRvIHRoZSBjYWxsIHRpbWUsIGluIG1pbGxpc2Vjb25kcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1ha2VFeHBpcnlUcmFuc2Zvcm0oZGVsYXlJbk1pbGxpc2Vjb25kcykge1xuICAgIHJldHVybiBhc3luYyAocmVxdWVzdCkgPT4ge1xuICAgICAgICByZXF1ZXN0LmJvZHkuaW5ncmVzc19leHBpcnkgPSBFeHBpcnkuZnJvbURlbHRhSW5NaWxsaXNlY29uZHMoZGVsYXlJbk1pbGxpc2Vjb25kcyk7XG4gICAgfTtcbn1cbi8qKlxuICogTWFwcyB0aGUgZGVmYXVsdCBmZXRjaCBoZWFkZXJzIGZpZWxkIHRvIHRoZSBzZXJpYWxpemFibGUgSHR0cEhlYWRlckZpZWxkLlxuICogQHBhcmFtIGhlYWRlcnMgRmV0Y2ggZGVmaW5pdGlvbiBvZiB0aGUgaGVhZGVycyB0eXBlXG4gKiBAcmV0dXJucyBhcnJheSBvZiBoZWFkZXIgZmllbGRzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBodHRwSGVhZGVyc1RyYW5zZm9ybShoZWFkZXJzKSB7XG4gICAgY29uc3QgaGVhZGVyRmllbGRzID0gW107XG4gICAgaGVhZGVycy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgIGhlYWRlckZpZWxkcy5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGhlYWRlckZpZWxkcztcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRyYW5zZm9ybXMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/agent/http/transforms.js\n");

/***/ }),

/***/ "(ssr)/../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/agent/http/types.js":
/*!*************************************************************************************!*\
  !*** ../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/agent/http/types.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Endpoint: () => (/* binding */ Endpoint),\n/* harmony export */   ReadRequestType: () => (/* binding */ ReadRequestType),\n/* harmony export */   SubmitRequestType: () => (/* binding */ SubmitRequestType),\n/* harmony export */   makeNonce: () => (/* binding */ makeNonce)\n/* harmony export */ });\n/* harmony import */ var _utils_random_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/random.js */ \"(ssr)/../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/utils/random.js\");\n\n/**\n * @internal\n */\nvar Endpoint;\n(function (Endpoint) {\n    Endpoint[\"Query\"] = \"read\";\n    Endpoint[\"ReadState\"] = \"read_state\";\n    Endpoint[\"Call\"] = \"call\";\n})(Endpoint || (Endpoint = {}));\n// The types of values allowed in the `request_type` field for submit requests.\nvar SubmitRequestType;\n(function (SubmitRequestType) {\n    SubmitRequestType[\"Call\"] = \"call\";\n})(SubmitRequestType || (SubmitRequestType = {}));\n// The types of values allowed in the `request_type` field for read requests.\nvar ReadRequestType;\n(function (ReadRequestType) {\n    ReadRequestType[\"Query\"] = \"query\";\n    ReadRequestType[\"ReadState\"] = \"read_state\";\n})(ReadRequestType || (ReadRequestType = {}));\n/**\n * Create a random Nonce, based on random values\n */\nfunction makeNonce() {\n    // Encode 128 bits.\n    const buffer = new ArrayBuffer(16);\n    const view = new DataView(buffer);\n    const rand1 = (0,_utils_random_js__WEBPACK_IMPORTED_MODULE_0__.randomNumber)();\n    const rand2 = (0,_utils_random_js__WEBPACK_IMPORTED_MODULE_0__.randomNumber)();\n    const rand3 = (0,_utils_random_js__WEBPACK_IMPORTED_MODULE_0__.randomNumber)();\n    const rand4 = (0,_utils_random_js__WEBPACK_IMPORTED_MODULE_0__.randomNumber)();\n    view.setUint32(0, rand1);\n    view.setUint32(4, rand2);\n    view.setUint32(8, rand3);\n    view.setUint32(12, rand4);\n    return Object.assign(new Uint8Array(buffer), { __nonce__: undefined });\n}\n//# sourceMappingURL=types.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vcGFja2FnZXMvc2RrLWpzL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL2FnZW50L2h0dHAvdHlwZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNEJBQTRCO0FBQzdCO0FBQ087QUFDUDtBQUNBO0FBQ0EsQ0FBQyw4Q0FBOEM7QUFDL0M7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLENBQUMsMENBQTBDO0FBQzNDO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDhEQUFZO0FBQzlCLGtCQUFrQiw4REFBWTtBQUM5QixrQkFBa0IsOERBQVk7QUFDOUIsa0JBQWtCLDhEQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELHNCQUFzQjtBQUN6RTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGlxdWJlL29wcy1jb25zb2xlLy4uLy4uL3BhY2thZ2VzL3Nkay1qcy9ub2RlX21vZHVsZXMvQGRmaW5pdHkvYWdlbnQvbGliL2VzbS9hZ2VudC9odHRwL3R5cGVzLmpzPzNiZDQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcmFuZG9tTnVtYmVyIH0gZnJvbSBcIi4uLy4uL3V0aWxzL3JhbmRvbS5qc1wiO1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IHZhciBFbmRwb2ludDtcbihmdW5jdGlvbiAoRW5kcG9pbnQpIHtcbiAgICBFbmRwb2ludFtcIlF1ZXJ5XCJdID0gXCJyZWFkXCI7XG4gICAgRW5kcG9pbnRbXCJSZWFkU3RhdGVcIl0gPSBcInJlYWRfc3RhdGVcIjtcbiAgICBFbmRwb2ludFtcIkNhbGxcIl0gPSBcImNhbGxcIjtcbn0pKEVuZHBvaW50IHx8IChFbmRwb2ludCA9IHt9KSk7XG4vLyBUaGUgdHlwZXMgb2YgdmFsdWVzIGFsbG93ZWQgaW4gdGhlIGByZXF1ZXN0X3R5cGVgIGZpZWxkIGZvciBzdWJtaXQgcmVxdWVzdHMuXG5leHBvcnQgdmFyIFN1Ym1pdFJlcXVlc3RUeXBlO1xuKGZ1bmN0aW9uIChTdWJtaXRSZXF1ZXN0VHlwZSkge1xuICAgIFN1Ym1pdFJlcXVlc3RUeXBlW1wiQ2FsbFwiXSA9IFwiY2FsbFwiO1xufSkoU3VibWl0UmVxdWVzdFR5cGUgfHwgKFN1Ym1pdFJlcXVlc3RUeXBlID0ge30pKTtcbi8vIFRoZSB0eXBlcyBvZiB2YWx1ZXMgYWxsb3dlZCBpbiB0aGUgYHJlcXVlc3RfdHlwZWAgZmllbGQgZm9yIHJlYWQgcmVxdWVzdHMuXG5leHBvcnQgdmFyIFJlYWRSZXF1ZXN0VHlwZTtcbihmdW5jdGlvbiAoUmVhZFJlcXVlc3RUeXBlKSB7XG4gICAgUmVhZFJlcXVlc3RUeXBlW1wiUXVlcnlcIl0gPSBcInF1ZXJ5XCI7XG4gICAgUmVhZFJlcXVlc3RUeXBlW1wiUmVhZFN0YXRlXCJdID0gXCJyZWFkX3N0YXRlXCI7XG59KShSZWFkUmVxdWVzdFR5cGUgfHwgKFJlYWRSZXF1ZXN0VHlwZSA9IHt9KSk7XG4vKipcbiAqIENyZWF0ZSBhIHJhbmRvbSBOb25jZSwgYmFzZWQgb24gcmFuZG9tIHZhbHVlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gbWFrZU5vbmNlKCkge1xuICAgIC8vIEVuY29kZSAxMjggYml0cy5cbiAgICBjb25zdCBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoMTYpO1xuICAgIGNvbnN0IHZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmZmVyKTtcbiAgICBjb25zdCByYW5kMSA9IHJhbmRvbU51bWJlcigpO1xuICAgIGNvbnN0IHJhbmQyID0gcmFuZG9tTnVtYmVyKCk7XG4gICAgY29uc3QgcmFuZDMgPSByYW5kb21OdW1iZXIoKTtcbiAgICBjb25zdCByYW5kNCA9IHJhbmRvbU51bWJlcigpO1xuICAgIHZpZXcuc2V0VWludDMyKDAsIHJhbmQxKTtcbiAgICB2aWV3LnNldFVpbnQzMig0LCByYW5kMik7XG4gICAgdmlldy5zZXRVaW50MzIoOCwgcmFuZDMpO1xuICAgIHZpZXcuc2V0VWludDMyKDEyLCByYW5kNCk7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24obmV3IFVpbnQ4QXJyYXkoYnVmZmVyKSwgeyBfX25vbmNlX186IHVuZGVmaW5lZCB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR5cGVzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/agent/http/types.js\n");

/***/ }),

/***/ "(ssr)/../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/auth.js":
/*!*************************************************************************!*\
  !*** ../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/auth.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AnonymousIdentity: () => (/* binding */ AnonymousIdentity),\n/* harmony export */   SignIdentity: () => (/* binding */ SignIdentity),\n/* harmony export */   createIdentityDescriptor: () => (/* binding */ createIdentityDescriptor)\n/* harmony export */ });\n/* harmony import */ var _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @dfinity/principal */ \"(ssr)/../../packages/sdk-js/node_modules/@dfinity/principal/lib/esm/principal.js\");\n/* harmony import */ var _request_id_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./request_id.js */ \"(ssr)/../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/request_id.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @noble/hashes/utils */ \"(ssr)/../../packages/sdk-js/node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./constants.js */ \"(ssr)/../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/constants.js\");\n\n\n\n\n/**\n * An Identity that can sign blobs.\n */\nclass SignIdentity {\n    /**\n     * Get the principal represented by this identity. Normally should be a\n     * `Principal.selfAuthenticating()`.\n     */\n    getPrincipal() {\n        if (!this._principal) {\n            this._principal = _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.selfAuthenticating(new Uint8Array(this.getPublicKey().toDer()));\n        }\n        return this._principal;\n    }\n    /**\n     * Transform a request into a signed version of the request. This is done last\n     * after the transforms on the body of a request. The returned object can be\n     * anything, but must be serializable to CBOR.\n     * @param request - internet computer request to transform\n     */\n    async transformRequest(request) {\n        const { body, ...fields } = request;\n        const requestId = (0,_request_id_js__WEBPACK_IMPORTED_MODULE_1__.requestIdOf)(body);\n        return {\n            ...fields,\n            body: {\n                content: body,\n                sender_pubkey: this.getPublicKey().toDer(),\n                sender_sig: await this.sign((0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_2__.concatBytes)(_constants_js__WEBPACK_IMPORTED_MODULE_3__.IC_REQUEST_DOMAIN_SEPARATOR, requestId)),\n            },\n        };\n    }\n}\nclass AnonymousIdentity {\n    getPrincipal() {\n        return _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.anonymous();\n    }\n    async transformRequest(request) {\n        return {\n            ...request,\n            body: { content: request.body },\n        };\n    }\n}\n/**\n * Create an IdentityDescriptor from a @dfinity/identity Identity\n * @param identity - identity describe in returned descriptor\n */\nfunction createIdentityDescriptor(identity) {\n    const identityIndicator = 'getPublicKey' in identity\n        ? { type: 'PublicKeyIdentity', publicKey: (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_2__.bytesToHex)(identity.getPublicKey().toDer()) }\n        : { type: 'AnonymousIdentity' };\n    return identityIndicator;\n}\n//# sourceMappingURL=auth.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vcGFja2FnZXMvc2RrLWpzL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL2F1dGguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUErQztBQUNEO0FBQ2dCO0FBQ0Q7QUFDN0Q7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIseURBQVM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0JBQWtCO0FBQ2xDLDBCQUEwQiwyREFBVztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLGdFQUFXLENBQUMsc0VBQTJCO0FBQ25GLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsZUFBZSx5REFBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsWUFBWSxzQ0FBc0MsK0RBQVU7QUFDNUQsWUFBWTtBQUNaO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BpcXViZS9vcHMtY29uc29sZS8uLi8uLi9wYWNrYWdlcy9zZGstanMvbm9kZV9tb2R1bGVzL0BkZmluaXR5L2FnZW50L2xpYi9lc20vYXV0aC5qcz84ZjY4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFByaW5jaXBhbCB9IGZyb20gJ0BkZmluaXR5L3ByaW5jaXBhbCc7XG5pbXBvcnQgeyByZXF1ZXN0SWRPZiB9IGZyb20gXCIuL3JlcXVlc3RfaWQuanNcIjtcbmltcG9ydCB7IGJ5dGVzVG9IZXgsIGNvbmNhdEJ5dGVzIH0gZnJvbSAnQG5vYmxlL2hhc2hlcy91dGlscyc7XG5pbXBvcnQgeyBJQ19SRVFVRVNUX0RPTUFJTl9TRVBBUkFUT1IgfSBmcm9tIFwiLi9jb25zdGFudHMuanNcIjtcbi8qKlxuICogQW4gSWRlbnRpdHkgdGhhdCBjYW4gc2lnbiBibG9icy5cbiAqL1xuZXhwb3J0IGNsYXNzIFNpZ25JZGVudGl0eSB7XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBwcmluY2lwYWwgcmVwcmVzZW50ZWQgYnkgdGhpcyBpZGVudGl0eS4gTm9ybWFsbHkgc2hvdWxkIGJlIGFcbiAgICAgKiBgUHJpbmNpcGFsLnNlbGZBdXRoZW50aWNhdGluZygpYC5cbiAgICAgKi9cbiAgICBnZXRQcmluY2lwYWwoKSB7XG4gICAgICAgIGlmICghdGhpcy5fcHJpbmNpcGFsKSB7XG4gICAgICAgICAgICB0aGlzLl9wcmluY2lwYWwgPSBQcmluY2lwYWwuc2VsZkF1dGhlbnRpY2F0aW5nKG5ldyBVaW50OEFycmF5KHRoaXMuZ2V0UHVibGljS2V5KCkudG9EZXIoKSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9wcmluY2lwYWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybSBhIHJlcXVlc3QgaW50byBhIHNpZ25lZCB2ZXJzaW9uIG9mIHRoZSByZXF1ZXN0LiBUaGlzIGlzIGRvbmUgbGFzdFxuICAgICAqIGFmdGVyIHRoZSB0cmFuc2Zvcm1zIG9uIHRoZSBib2R5IG9mIGEgcmVxdWVzdC4gVGhlIHJldHVybmVkIG9iamVjdCBjYW4gYmVcbiAgICAgKiBhbnl0aGluZywgYnV0IG11c3QgYmUgc2VyaWFsaXphYmxlIHRvIENCT1IuXG4gICAgICogQHBhcmFtIHJlcXVlc3QgLSBpbnRlcm5ldCBjb21wdXRlciByZXF1ZXN0IHRvIHRyYW5zZm9ybVxuICAgICAqL1xuICAgIGFzeW5jIHRyYW5zZm9ybVJlcXVlc3QocmVxdWVzdCkge1xuICAgICAgICBjb25zdCB7IGJvZHksIC4uLmZpZWxkcyB9ID0gcmVxdWVzdDtcbiAgICAgICAgY29uc3QgcmVxdWVzdElkID0gcmVxdWVzdElkT2YoYm9keSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5maWVsZHMsXG4gICAgICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICAgICAgY29udGVudDogYm9keSxcbiAgICAgICAgICAgICAgICBzZW5kZXJfcHVia2V5OiB0aGlzLmdldFB1YmxpY0tleSgpLnRvRGVyKCksXG4gICAgICAgICAgICAgICAgc2VuZGVyX3NpZzogYXdhaXQgdGhpcy5zaWduKGNvbmNhdEJ5dGVzKElDX1JFUVVFU1RfRE9NQUlOX1NFUEFSQVRPUiwgcmVxdWVzdElkKSksXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBBbm9ueW1vdXNJZGVudGl0eSB7XG4gICAgZ2V0UHJpbmNpcGFsKCkge1xuICAgICAgICByZXR1cm4gUHJpbmNpcGFsLmFub255bW91cygpO1xuICAgIH1cbiAgICBhc3luYyB0cmFuc2Zvcm1SZXF1ZXN0KHJlcXVlc3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnJlcXVlc3QsXG4gICAgICAgICAgICBib2R5OiB7IGNvbnRlbnQ6IHJlcXVlc3QuYm9keSB9LFxuICAgICAgICB9O1xuICAgIH1cbn1cbi8qKlxuICogQ3JlYXRlIGFuIElkZW50aXR5RGVzY3JpcHRvciBmcm9tIGEgQGRmaW5pdHkvaWRlbnRpdHkgSWRlbnRpdHlcbiAqIEBwYXJhbSBpZGVudGl0eSAtIGlkZW50aXR5IGRlc2NyaWJlIGluIHJldHVybmVkIGRlc2NyaXB0b3JcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUlkZW50aXR5RGVzY3JpcHRvcihpZGVudGl0eSkge1xuICAgIGNvbnN0IGlkZW50aXR5SW5kaWNhdG9yID0gJ2dldFB1YmxpY0tleScgaW4gaWRlbnRpdHlcbiAgICAgICAgPyB7IHR5cGU6ICdQdWJsaWNLZXlJZGVudGl0eScsIHB1YmxpY0tleTogYnl0ZXNUb0hleChpZGVudGl0eS5nZXRQdWJsaWNLZXkoKS50b0RlcigpKSB9XG4gICAgICAgIDogeyB0eXBlOiAnQW5vbnltb3VzSWRlbnRpdHknIH07XG4gICAgcmV0dXJuIGlkZW50aXR5SW5kaWNhdG9yO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXV0aC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/auth.js\n");

/***/ }),

/***/ "(ssr)/../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/canisterStatus/index.js":
/*!*****************************************************************************************!*\
  !*** ../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/canisterStatus/index.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CustomPath: () => (/* binding */ CustomPath),\n/* harmony export */   encodePath: () => (/* binding */ encodePath),\n/* harmony export */   fetchNodeKeys: () => (/* binding */ fetchNodeKeys),\n/* harmony export */   request: () => (/* binding */ request)\n/* harmony export */ });\n/* harmony import */ var _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @dfinity/principal */ \"(ssr)/../../packages/sdk-js/node_modules/@dfinity/principal/lib/esm/principal.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../errors.js */ \"(ssr)/../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/errors.js\");\n/* harmony import */ var _certificate_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../certificate.js */ \"(ssr)/../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/certificate.js\");\n/* harmony import */ var _cbor_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../cbor.js */ \"(ssr)/../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/cbor.js\");\n/* harmony import */ var _utils_leb_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/leb.js */ \"(ssr)/../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/utils/leb.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/hashes/utils */ \"(ssr)/../../packages/sdk-js/node_modules/@noble/hashes/esm/utils.js\");\n\n\n\n\n\n\n/**\n * Interface to define a custom path. Nested paths will be represented as individual buffers, and can be created from text using TextEncoder.\n * @param {string} key the key to use to access the returned value in the canisterStatus map\n * @param {Uint8Array[]} path the path to the desired value, represented as an array of buffers\n * @param {string} decodeStrategy the strategy to use to decode the returned value\n */\nclass CustomPath {\n    constructor(key, path, decodeStrategy) {\n        this.key = key;\n        this.path = path;\n        this.decodeStrategy = decodeStrategy;\n    }\n}\n/**\n * Requests information from a canister's `read_state` endpoint.\n * Can be used to request information about the canister's controllers, time, module hash, candid interface, and more.\n * @param {CanisterStatusOptions} options The configuration for the canister status request.\n * @see {@link CanisterStatusOptions} for detailed options.\n * @returns {Promise<StatusMap>} A map populated with data from the requested paths. Each path is a key in the map, and the value is the data obtained from the certificate for that path.\n * @example\n * const status = await canisterStatus({\n *   paths: ['controllers', 'candid'],\n *   ...options\n * });\n *\n * const controllers = status.get('controllers');\n */\nconst request = async (options) => {\n    const { agent, paths, disableCertificateTimeVerification = false } = options;\n    const canisterId = _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.from(options.canisterId);\n    const uniquePaths = [...new Set(paths)];\n    const status = new Map();\n    const promises = uniquePaths.map((path, index) => {\n        const encodedPath = encodePath(path, canisterId);\n        return (async () => {\n            try {\n                if (agent.rootKey === null) {\n                    throw _errors_js__WEBPACK_IMPORTED_MODULE_1__.ExternalError.fromCode(new _errors_js__WEBPACK_IMPORTED_MODULE_1__.MissingRootKeyErrorCode());\n                }\n                const rootKey = agent.rootKey;\n                const response = await agent.readState(canisterId, {\n                    paths: [encodedPath],\n                });\n                const certificate = await _certificate_js__WEBPACK_IMPORTED_MODULE_2__.Certificate.create({\n                    certificate: response.certificate,\n                    rootKey,\n                    canisterId,\n                    disableTimeVerification: disableCertificateTimeVerification,\n                    agent,\n                });\n                const lookup = (cert, path) => {\n                    if (path === 'subnet') {\n                        const data = fetchNodeKeys(response.certificate, canisterId, rootKey);\n                        return {\n                            path,\n                            data,\n                        };\n                    }\n                    else {\n                        return {\n                            path,\n                            data: (0,_certificate_js__WEBPACK_IMPORTED_MODULE_2__.lookupResultToBuffer)(cert.lookup_path(encodedPath)),\n                        };\n                    }\n                };\n                // must pass in the rootKey if we have no delegation\n                const { path, data } = lookup(certificate, uniquePaths[index]);\n                if (!data) {\n                    // Typically, the cert lookup will throw\n                    console.warn(`Expected to find result for path ${path}, but instead found nothing.`);\n                    if (typeof path === 'string') {\n                        status.set(path, null);\n                    }\n                    else {\n                        status.set(path.key, null);\n                    }\n                }\n                else {\n                    switch (path) {\n                        case 'time': {\n                            status.set(path, (0,_utils_leb_js__WEBPACK_IMPORTED_MODULE_3__.decodeTime)(data));\n                            break;\n                        }\n                        case 'controllers': {\n                            status.set(path, decodeControllers(data));\n                            break;\n                        }\n                        case 'module_hash': {\n                            status.set(path, (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_4__.bytesToHex)(data));\n                            break;\n                        }\n                        case 'subnet': {\n                            status.set(path, data);\n                            break;\n                        }\n                        case 'candid': {\n                            status.set(path, new TextDecoder().decode(data));\n                            break;\n                        }\n                        default: {\n                            // Check for CustomPath signature\n                            if (typeof path !== 'string' && 'key' in path && 'path' in path) {\n                                switch (path.decodeStrategy) {\n                                    case 'raw':\n                                        status.set(path.key, data);\n                                        break;\n                                    case 'leb128': {\n                                        status.set(path.key, (0,_utils_leb_js__WEBPACK_IMPORTED_MODULE_3__.decodeLeb128)(data));\n                                        break;\n                                    }\n                                    case 'cbor': {\n                                        status.set(path.key, _cbor_js__WEBPACK_IMPORTED_MODULE_5__.decode(data));\n                                        break;\n                                    }\n                                    case 'hex': {\n                                        status.set(path.key, (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_4__.bytesToHex)(data));\n                                        break;\n                                    }\n                                    case 'utf-8': {\n                                        status.set(path.key, new TextDecoder().decode(data));\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            catch (error) {\n                // Throw on certificate errors\n                if (error instanceof _errors_js__WEBPACK_IMPORTED_MODULE_1__.AgentError &&\n                    (error.hasCode(_errors_js__WEBPACK_IMPORTED_MODULE_1__.CertificateVerificationErrorCode) ||\n                        error.hasCode(_errors_js__WEBPACK_IMPORTED_MODULE_1__.CertificateTimeErrorCode))) {\n                    throw error;\n                }\n                if (typeof path !== 'string' && 'key' in path && 'path' in path) {\n                    status.set(path.key, null);\n                }\n                else {\n                    status.set(path, null);\n                }\n                console.group();\n                console.warn(`Expected to find result for path ${path}, but instead found nothing.`);\n                console.warn(error);\n                console.groupEnd();\n            }\n        })();\n    });\n    // Fetch all values separately, as each option can fail\n    await Promise.all(promises);\n    return status;\n};\nconst fetchNodeKeys = (certificate, canisterId, root_key) => {\n    if (!canisterId._isPrincipal) {\n        throw _errors_js__WEBPACK_IMPORTED_MODULE_1__.InputError.fromCode(new _errors_js__WEBPACK_IMPORTED_MODULE_1__.UnexpectedErrorCode('Invalid canisterId'));\n    }\n    const cert = _cbor_js__WEBPACK_IMPORTED_MODULE_5__.decode(certificate);\n    const tree = cert.tree;\n    let delegation = cert.delegation;\n    let subnetId;\n    if (delegation && delegation.subnet_id) {\n        subnetId = _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.fromUint8Array(new Uint8Array(delegation.subnet_id));\n    }\n    // On local replica, with System type subnet, there is no delegation\n    else if (!delegation && typeof root_key !== 'undefined') {\n        subnetId = _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.selfAuthenticating(new Uint8Array(root_key));\n        delegation = {\n            subnet_id: subnetId.toUint8Array(),\n            certificate: new Uint8Array(0),\n        };\n    }\n    // otherwise use default NNS subnet id\n    else {\n        subnetId = _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.selfAuthenticating(_dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.fromText('tdb26-jop6k-aogll-7ltgs-eruif-6kk7m-qpktf-gdiqx-mxtrf-vb5e6-eqe').toUint8Array());\n        delegation = {\n            subnet_id: subnetId.toUint8Array(),\n            certificate: new Uint8Array(0),\n        };\n    }\n    const canisterInRange = (0,_certificate_js__WEBPACK_IMPORTED_MODULE_2__.check_canister_ranges)({ canisterId, subnetId, tree });\n    if (!canisterInRange) {\n        throw _errors_js__WEBPACK_IMPORTED_MODULE_1__.TrustError.fromCode(new _errors_js__WEBPACK_IMPORTED_MODULE_1__.CertificateNotAuthorizedErrorCode(canisterId, subnetId));\n    }\n    const subnetLookupResult = (0,_certificate_js__WEBPACK_IMPORTED_MODULE_2__.lookup_subtree)(['subnet', delegation.subnet_id, 'node'], tree);\n    if (subnetLookupResult.status !== _certificate_js__WEBPACK_IMPORTED_MODULE_2__.LookupSubtreeStatus.Found) {\n        throw _errors_js__WEBPACK_IMPORTED_MODULE_1__.ProtocolError.fromCode(new _errors_js__WEBPACK_IMPORTED_MODULE_1__.LookupErrorCode('Node not found', subnetLookupResult.status));\n    }\n    if (subnetLookupResult.value instanceof Uint8Array) {\n        throw _errors_js__WEBPACK_IMPORTED_MODULE_1__.UnknownError.fromCode(new _errors_js__WEBPACK_IMPORTED_MODULE_1__.HashTreeDecodeErrorCode('Invalid node tree'));\n    }\n    // The forks are all labeled trees with the <node_id> label\n    const nodeForks = (0,_certificate_js__WEBPACK_IMPORTED_MODULE_2__.flatten_forks)(subnetLookupResult.value);\n    const nodeKeys = new Map();\n    nodeForks.forEach(fork => {\n        const node_id = _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.from(fork[1]).toText();\n        const publicKeyLookupResult = (0,_certificate_js__WEBPACK_IMPORTED_MODULE_2__.lookup_path)(['public_key'], fork[2]);\n        if (publicKeyLookupResult.status !== _certificate_js__WEBPACK_IMPORTED_MODULE_2__.LookupPathStatus.Found) {\n            throw _errors_js__WEBPACK_IMPORTED_MODULE_1__.ProtocolError.fromCode(new _errors_js__WEBPACK_IMPORTED_MODULE_1__.LookupErrorCode('Public key not found', publicKeyLookupResult.status));\n        }\n        const derEncodedPublicKey = publicKeyLookupResult.value;\n        if (derEncodedPublicKey.byteLength !== 44) {\n            throw _errors_js__WEBPACK_IMPORTED_MODULE_1__.ProtocolError.fromCode(new _errors_js__WEBPACK_IMPORTED_MODULE_1__.DerKeyLengthMismatchErrorCode(44, derEncodedPublicKey.byteLength));\n        }\n        else {\n            nodeKeys.set(node_id, derEncodedPublicKey);\n        }\n    });\n    return {\n        subnetId: _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.fromUint8Array(new Uint8Array(delegation.subnet_id)).toText(),\n        nodeKeys,\n    };\n};\nconst encodePath = (path, canisterId) => {\n    const canisterUint8Array = canisterId.toUint8Array();\n    switch (path) {\n        case 'time':\n            return [(0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_4__.utf8ToBytes)('time')];\n        case 'controllers':\n            return [(0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_4__.utf8ToBytes)('canister'), canisterUint8Array, (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_4__.utf8ToBytes)('controllers')];\n        case 'module_hash':\n            return [(0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_4__.utf8ToBytes)('canister'), canisterUint8Array, (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_4__.utf8ToBytes)('module_hash')];\n        case 'subnet':\n            return [(0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_4__.utf8ToBytes)('subnet')];\n        case 'candid':\n            return [\n                (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_4__.utf8ToBytes)('canister'),\n                canisterUint8Array,\n                (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_4__.utf8ToBytes)('metadata'),\n                (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_4__.utf8ToBytes)('candid:service'),\n            ];\n        default: {\n            // Check for CustomPath signature\n            if ('key' in path && 'path' in path) {\n                // For simplified metadata queries\n                if (typeof path['path'] === 'string' || path['path'] instanceof Uint8Array) {\n                    const metaPath = path.path;\n                    const encoded = typeof metaPath === 'string' ? (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_4__.utf8ToBytes)(metaPath) : metaPath;\n                    return [(0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_4__.utf8ToBytes)('canister'), canisterUint8Array, (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_4__.utf8ToBytes)('metadata'), encoded];\n                    // For non-metadata, return the provided custompath\n                }\n                else {\n                    return path['path'];\n                }\n            }\n        }\n    }\n    throw _errors_js__WEBPACK_IMPORTED_MODULE_1__.UnknownError.fromCode(new _errors_js__WEBPACK_IMPORTED_MODULE_1__.UnexpectedErrorCode(`Error while encoding your path for canister status. Please ensure that your path ${path} was formatted correctly.`));\n};\n// Controllers are CBOR-encoded buffers\nconst decodeControllers = (buf) => {\n    const controllersRaw = _cbor_js__WEBPACK_IMPORTED_MODULE_5__.decode(buf);\n    return controllersRaw.map(buf => {\n        return _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.fromUint8Array(buf);\n    });\n};\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vcGFja2FnZXMvc2RrLWpzL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL2NhbmlzdGVyU3RhdHVzL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBK0M7QUFDc1I7QUFDcEo7QUFDOUk7QUFDd0I7QUFDRztBQUM5RDtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsY0FBYztBQUN6QixXQUFXLFFBQVE7QUFDbkI7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsdUJBQXVCO0FBQ2xDLFNBQVMsNkJBQTZCO0FBQ3RDLGFBQWEsb0JBQW9CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsWUFBWSwyREFBMkQ7QUFDdkUsdUJBQXVCLHlEQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHFEQUFhLGNBQWMsK0RBQXVCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLDBDQUEwQyx3REFBVztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MscUVBQW9CO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGFBQWE7QUFDckM7QUFDQTtBQUNBLHFFQUFxRSxLQUFLO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLHlEQUFVO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLCtEQUFVO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCwyREFBWTtBQUN6RTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsNENBQVc7QUFDeEU7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELCtEQUFVO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGtEQUFVO0FBQy9DLG1DQUFtQyx3RUFBZ0M7QUFDbkUsc0NBQXNDLGdFQUF3QjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsS0FBSztBQUN0RTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLGNBQWMsa0RBQVUsY0FBYywyREFBbUI7QUFDekQ7QUFDQSxpQkFBaUIsNENBQVc7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIseURBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHlEQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHlEQUFTLG9CQUFvQix5REFBUztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHNFQUFxQixHQUFHLDRCQUE0QjtBQUNoRjtBQUNBLGNBQWMsa0RBQVUsY0FBYyx5RUFBaUM7QUFDdkU7QUFDQSwrQkFBK0IsK0RBQWM7QUFDN0Msc0NBQXNDLGdFQUFtQjtBQUN6RCxjQUFjLHFEQUFhLGNBQWMsdURBQWU7QUFDeEQ7QUFDQTtBQUNBLGNBQWMsb0RBQVksY0FBYywrREFBdUI7QUFDL0Q7QUFDQTtBQUNBLHNCQUFzQiw4REFBYTtBQUNuQztBQUNBO0FBQ0Esd0JBQXdCLHlEQUFTO0FBQ2pDLHNDQUFzQyw0REFBVztBQUNqRCw2Q0FBNkMsNkRBQWdCO0FBQzdELGtCQUFrQixxREFBYSxjQUFjLHVEQUFlO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixxREFBYSxjQUFjLHFFQUE2QjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGtCQUFrQix5REFBUztBQUMzQjtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnRUFBVztBQUMvQjtBQUNBLG9CQUFvQixnRUFBVyxrQ0FBa0MsZ0VBQVc7QUFDNUU7QUFDQSxvQkFBb0IsZ0VBQVcsa0NBQWtDLGdFQUFXO0FBQzVFO0FBQ0Esb0JBQW9CLGdFQUFXO0FBQy9CO0FBQ0E7QUFDQSxnQkFBZ0IsZ0VBQVc7QUFDM0I7QUFDQSxnQkFBZ0IsZ0VBQVc7QUFDM0IsZ0JBQWdCLGdFQUFXO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLGdFQUFXO0FBQzlFLDRCQUE0QixnRUFBVyxrQ0FBa0MsZ0VBQVc7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsb0RBQVksY0FBYywyREFBbUIscUZBQXFGLE1BQU07QUFDbEo7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDRDQUFXO0FBQ3RDO0FBQ0EsZUFBZSx5REFBUztBQUN4QixLQUFLO0FBQ0w7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BpcXViZS9vcHMtY29uc29sZS8uLi8uLi9wYWNrYWdlcy9zZGstanMvbm9kZV9tb2R1bGVzL0BkZmluaXR5L2FnZW50L2xpYi9lc20vY2FuaXN0ZXJTdGF0dXMvaW5kZXguanM/YWU5NiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQcmluY2lwYWwgfSBmcm9tICdAZGZpbml0eS9wcmluY2lwYWwnO1xuaW1wb3J0IHsgQ2VydGlmaWNhdGVWZXJpZmljYXRpb25FcnJvckNvZGUsIE1pc3NpbmdSb290S2V5RXJyb3JDb2RlLCBDZXJ0aWZpY2F0ZU5vdEF1dGhvcml6ZWRFcnJvckNvZGUsIExvb2t1cEVycm9yQ29kZSwgRGVyS2V5TGVuZ3RoTWlzbWF0Y2hFcnJvckNvZGUsIEV4dGVybmFsRXJyb3IsIFByb3RvY29sRXJyb3IsIFRydXN0RXJyb3IsIEFnZW50RXJyb3IsIFVua25vd25FcnJvciwgSGFzaFRyZWVEZWNvZGVFcnJvckNvZGUsIFVuZXhwZWN0ZWRFcnJvckNvZGUsIElucHV0RXJyb3IsIENlcnRpZmljYXRlVGltZUVycm9yQ29kZSwgfSBmcm9tIFwiLi4vZXJyb3JzLmpzXCI7XG5pbXBvcnQgeyBDZXJ0aWZpY2F0ZSwgZmxhdHRlbl9mb3JrcywgY2hlY2tfY2FuaXN0ZXJfcmFuZ2VzLCBMb29rdXBQYXRoU3RhdHVzLCBsb29rdXBfcGF0aCwgbG9va3VwUmVzdWx0VG9CdWZmZXIsIGxvb2t1cF9zdWJ0cmVlLCBMb29rdXBTdWJ0cmVlU3RhdHVzLCB9IGZyb20gXCIuLi9jZXJ0aWZpY2F0ZS5qc1wiO1xuaW1wb3J0ICogYXMgY2JvciBmcm9tIFwiLi4vY2Jvci5qc1wiO1xuaW1wb3J0IHsgZGVjb2RlTGViMTI4LCBkZWNvZGVUaW1lIH0gZnJvbSBcIi4uL3V0aWxzL2xlYi5qc1wiO1xuaW1wb3J0IHsgdXRmOFRvQnl0ZXMsIGJ5dGVzVG9IZXggfSBmcm9tICdAbm9ibGUvaGFzaGVzL3V0aWxzJztcbi8qKlxuICogSW50ZXJmYWNlIHRvIGRlZmluZSBhIGN1c3RvbSBwYXRoLiBOZXN0ZWQgcGF0aHMgd2lsbCBiZSByZXByZXNlbnRlZCBhcyBpbmRpdmlkdWFsIGJ1ZmZlcnMsIGFuZCBjYW4gYmUgY3JlYXRlZCBmcm9tIHRleHQgdXNpbmcgVGV4dEVuY29kZXIuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IHRoZSBrZXkgdG8gdXNlIHRvIGFjY2VzcyB0aGUgcmV0dXJuZWQgdmFsdWUgaW4gdGhlIGNhbmlzdGVyU3RhdHVzIG1hcFxuICogQHBhcmFtIHtVaW50OEFycmF5W119IHBhdGggdGhlIHBhdGggdG8gdGhlIGRlc2lyZWQgdmFsdWUsIHJlcHJlc2VudGVkIGFzIGFuIGFycmF5IG9mIGJ1ZmZlcnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBkZWNvZGVTdHJhdGVneSB0aGUgc3RyYXRlZ3kgdG8gdXNlIHRvIGRlY29kZSB0aGUgcmV0dXJuZWQgdmFsdWVcbiAqL1xuZXhwb3J0IGNsYXNzIEN1c3RvbVBhdGgge1xuICAgIGNvbnN0cnVjdG9yKGtleSwgcGF0aCwgZGVjb2RlU3RyYXRlZ3kpIHtcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgICAgIHRoaXMuZGVjb2RlU3RyYXRlZ3kgPSBkZWNvZGVTdHJhdGVneTtcbiAgICB9XG59XG4vKipcbiAqIFJlcXVlc3RzIGluZm9ybWF0aW9uIGZyb20gYSBjYW5pc3RlcidzIGByZWFkX3N0YXRlYCBlbmRwb2ludC5cbiAqIENhbiBiZSB1c2VkIHRvIHJlcXVlc3QgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGNhbmlzdGVyJ3MgY29udHJvbGxlcnMsIHRpbWUsIG1vZHVsZSBoYXNoLCBjYW5kaWQgaW50ZXJmYWNlLCBhbmQgbW9yZS5cbiAqIEBwYXJhbSB7Q2FuaXN0ZXJTdGF0dXNPcHRpb25zfSBvcHRpb25zIFRoZSBjb25maWd1cmF0aW9uIGZvciB0aGUgY2FuaXN0ZXIgc3RhdHVzIHJlcXVlc3QuXG4gKiBAc2VlIHtAbGluayBDYW5pc3RlclN0YXR1c09wdGlvbnN9IGZvciBkZXRhaWxlZCBvcHRpb25zLlxuICogQHJldHVybnMge1Byb21pc2U8U3RhdHVzTWFwPn0gQSBtYXAgcG9wdWxhdGVkIHdpdGggZGF0YSBmcm9tIHRoZSByZXF1ZXN0ZWQgcGF0aHMuIEVhY2ggcGF0aCBpcyBhIGtleSBpbiB0aGUgbWFwLCBhbmQgdGhlIHZhbHVlIGlzIHRoZSBkYXRhIG9idGFpbmVkIGZyb20gdGhlIGNlcnRpZmljYXRlIGZvciB0aGF0IHBhdGguXG4gKiBAZXhhbXBsZVxuICogY29uc3Qgc3RhdHVzID0gYXdhaXQgY2FuaXN0ZXJTdGF0dXMoe1xuICogICBwYXRoczogWydjb250cm9sbGVycycsICdjYW5kaWQnXSxcbiAqICAgLi4ub3B0aW9uc1xuICogfSk7XG4gKlxuICogY29uc3QgY29udHJvbGxlcnMgPSBzdGF0dXMuZ2V0KCdjb250cm9sbGVycycpO1xuICovXG5leHBvcnQgY29uc3QgcmVxdWVzdCA9IGFzeW5jIChvcHRpb25zKSA9PiB7XG4gICAgY29uc3QgeyBhZ2VudCwgcGF0aHMsIGRpc2FibGVDZXJ0aWZpY2F0ZVRpbWVWZXJpZmljYXRpb24gPSBmYWxzZSB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBjYW5pc3RlcklkID0gUHJpbmNpcGFsLmZyb20ob3B0aW9ucy5jYW5pc3RlcklkKTtcbiAgICBjb25zdCB1bmlxdWVQYXRocyA9IFsuLi5uZXcgU2V0KHBhdGhzKV07XG4gICAgY29uc3Qgc3RhdHVzID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IHByb21pc2VzID0gdW5pcXVlUGF0aHMubWFwKChwYXRoLCBpbmRleCkgPT4ge1xuICAgICAgICBjb25zdCBlbmNvZGVkUGF0aCA9IGVuY29kZVBhdGgocGF0aCwgY2FuaXN0ZXJJZCk7XG4gICAgICAgIHJldHVybiAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoYWdlbnQucm9vdEtleSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFeHRlcm5hbEVycm9yLmZyb21Db2RlKG5ldyBNaXNzaW5nUm9vdEtleUVycm9yQ29kZSgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgcm9vdEtleSA9IGFnZW50LnJvb3RLZXk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhZ2VudC5yZWFkU3RhdGUoY2FuaXN0ZXJJZCwge1xuICAgICAgICAgICAgICAgICAgICBwYXRoczogW2VuY29kZWRQYXRoXSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCBjZXJ0aWZpY2F0ZSA9IGF3YWl0IENlcnRpZmljYXRlLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIGNlcnRpZmljYXRlOiByZXNwb25zZS5jZXJ0aWZpY2F0ZSxcbiAgICAgICAgICAgICAgICAgICAgcm9vdEtleSxcbiAgICAgICAgICAgICAgICAgICAgY2FuaXN0ZXJJZCxcbiAgICAgICAgICAgICAgICAgICAgZGlzYWJsZVRpbWVWZXJpZmljYXRpb246IGRpc2FibGVDZXJ0aWZpY2F0ZVRpbWVWZXJpZmljYXRpb24sXG4gICAgICAgICAgICAgICAgICAgIGFnZW50LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvb2t1cCA9IChjZXJ0LCBwYXRoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXRoID09PSAnc3VibmV0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IGZldGNoTm9kZUtleXMocmVzcG9uc2UuY2VydGlmaWNhdGUsIGNhbmlzdGVySWQsIHJvb3RLZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGxvb2t1cFJlc3VsdFRvQnVmZmVyKGNlcnQubG9va3VwX3BhdGgoZW5jb2RlZFBhdGgpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIC8vIG11c3QgcGFzcyBpbiB0aGUgcm9vdEtleSBpZiB3ZSBoYXZlIG5vIGRlbGVnYXRpb25cbiAgICAgICAgICAgICAgICBjb25zdCB7IHBhdGgsIGRhdGEgfSA9IGxvb2t1cChjZXJ0aWZpY2F0ZSwgdW5pcXVlUGF0aHNbaW5kZXhdKTtcbiAgICAgICAgICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVHlwaWNhbGx5LCB0aGUgY2VydCBsb29rdXAgd2lsbCB0aHJvd1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYEV4cGVjdGVkIHRvIGZpbmQgcmVzdWx0IGZvciBwYXRoICR7cGF0aH0sIGJ1dCBpbnN0ZWFkIGZvdW5kIG5vdGhpbmcuYCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1cy5zZXQocGF0aCwgbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXMuc2V0KHBhdGgua2V5LCBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChwYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd0aW1lJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1cy5zZXQocGF0aCwgZGVjb2RlVGltZShkYXRhKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdjb250cm9sbGVycyc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXMuc2V0KHBhdGgsIGRlY29kZUNvbnRyb2xsZXJzKGRhdGEpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ21vZHVsZV9oYXNoJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1cy5zZXQocGF0aCwgYnl0ZXNUb0hleChkYXRhKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdzdWJuZXQnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzLnNldChwYXRoLCBkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2NhbmRpZCc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXMuc2V0KHBhdGgsIG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShkYXRhKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIEN1c3RvbVBhdGggc2lnbmF0dXJlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJyAmJiAna2V5JyBpbiBwYXRoICYmICdwYXRoJyBpbiBwYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAocGF0aC5kZWNvZGVTdHJhdGVneSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAncmF3JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXMuc2V0KHBhdGgua2V5LCBkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2xlYjEyOCc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXMuc2V0KHBhdGgua2V5LCBkZWNvZGVMZWIxMjgoZGF0YSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnY2Jvcic6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXMuc2V0KHBhdGgua2V5LCBjYm9yLmRlY29kZShkYXRhKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdoZXgnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzLnNldChwYXRoLmtleSwgYnl0ZXNUb0hleChkYXRhKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd1dGYtOCc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXMuc2V0KHBhdGgua2V5LCBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoZGF0YSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhyb3cgb24gY2VydGlmaWNhdGUgZXJyb3JzXG4gICAgICAgICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgQWdlbnRFcnJvciAmJlxuICAgICAgICAgICAgICAgICAgICAoZXJyb3IuaGFzQ29kZShDZXJ0aWZpY2F0ZVZlcmlmaWNhdGlvbkVycm9yQ29kZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yLmhhc0NvZGUoQ2VydGlmaWNhdGVUaW1lRXJyb3JDb2RlKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycgJiYgJ2tleScgaW4gcGF0aCAmJiAncGF0aCcgaW4gcGF0aCkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuc2V0KHBhdGgua2V5LCBudWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5zZXQocGF0aCwgbnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZ3JvdXAoKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYEV4cGVjdGVkIHRvIGZpbmQgcmVzdWx0IGZvciBwYXRoICR7cGF0aH0sIGJ1dCBpbnN0ZWFkIGZvdW5kIG5vdGhpbmcuYCk7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGVycm9yKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmdyb3VwRW5kKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKCk7XG4gICAgfSk7XG4gICAgLy8gRmV0Y2ggYWxsIHZhbHVlcyBzZXBhcmF0ZWx5LCBhcyBlYWNoIG9wdGlvbiBjYW4gZmFpbFxuICAgIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICByZXR1cm4gc3RhdHVzO1xufTtcbmV4cG9ydCBjb25zdCBmZXRjaE5vZGVLZXlzID0gKGNlcnRpZmljYXRlLCBjYW5pc3RlcklkLCByb290X2tleSkgPT4ge1xuICAgIGlmICghY2FuaXN0ZXJJZC5faXNQcmluY2lwYWwpIHtcbiAgICAgICAgdGhyb3cgSW5wdXRFcnJvci5mcm9tQ29kZShuZXcgVW5leHBlY3RlZEVycm9yQ29kZSgnSW52YWxpZCBjYW5pc3RlcklkJykpO1xuICAgIH1cbiAgICBjb25zdCBjZXJ0ID0gY2Jvci5kZWNvZGUoY2VydGlmaWNhdGUpO1xuICAgIGNvbnN0IHRyZWUgPSBjZXJ0LnRyZWU7XG4gICAgbGV0IGRlbGVnYXRpb24gPSBjZXJ0LmRlbGVnYXRpb247XG4gICAgbGV0IHN1Ym5ldElkO1xuICAgIGlmIChkZWxlZ2F0aW9uICYmIGRlbGVnYXRpb24uc3VibmV0X2lkKSB7XG4gICAgICAgIHN1Ym5ldElkID0gUHJpbmNpcGFsLmZyb21VaW50OEFycmF5KG5ldyBVaW50OEFycmF5KGRlbGVnYXRpb24uc3VibmV0X2lkKSk7XG4gICAgfVxuICAgIC8vIE9uIGxvY2FsIHJlcGxpY2EsIHdpdGggU3lzdGVtIHR5cGUgc3VibmV0LCB0aGVyZSBpcyBubyBkZWxlZ2F0aW9uXG4gICAgZWxzZSBpZiAoIWRlbGVnYXRpb24gJiYgdHlwZW9mIHJvb3Rfa2V5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBzdWJuZXRJZCA9IFByaW5jaXBhbC5zZWxmQXV0aGVudGljYXRpbmcobmV3IFVpbnQ4QXJyYXkocm9vdF9rZXkpKTtcbiAgICAgICAgZGVsZWdhdGlvbiA9IHtcbiAgICAgICAgICAgIHN1Ym5ldF9pZDogc3VibmV0SWQudG9VaW50OEFycmF5KCksXG4gICAgICAgICAgICBjZXJ0aWZpY2F0ZTogbmV3IFVpbnQ4QXJyYXkoMCksXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIG90aGVyd2lzZSB1c2UgZGVmYXVsdCBOTlMgc3VibmV0IGlkXG4gICAgZWxzZSB7XG4gICAgICAgIHN1Ym5ldElkID0gUHJpbmNpcGFsLnNlbGZBdXRoZW50aWNhdGluZyhQcmluY2lwYWwuZnJvbVRleHQoJ3RkYjI2LWpvcDZrLWFvZ2xsLTdsdGdzLWVydWlmLTZrazdtLXFwa3RmLWdkaXF4LW14dHJmLXZiNWU2LWVxZScpLnRvVWludDhBcnJheSgpKTtcbiAgICAgICAgZGVsZWdhdGlvbiA9IHtcbiAgICAgICAgICAgIHN1Ym5ldF9pZDogc3VibmV0SWQudG9VaW50OEFycmF5KCksXG4gICAgICAgICAgICBjZXJ0aWZpY2F0ZTogbmV3IFVpbnQ4QXJyYXkoMCksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGNhbmlzdGVySW5SYW5nZSA9IGNoZWNrX2NhbmlzdGVyX3Jhbmdlcyh7IGNhbmlzdGVySWQsIHN1Ym5ldElkLCB0cmVlIH0pO1xuICAgIGlmICghY2FuaXN0ZXJJblJhbmdlKSB7XG4gICAgICAgIHRocm93IFRydXN0RXJyb3IuZnJvbUNvZGUobmV3IENlcnRpZmljYXRlTm90QXV0aG9yaXplZEVycm9yQ29kZShjYW5pc3RlcklkLCBzdWJuZXRJZCkpO1xuICAgIH1cbiAgICBjb25zdCBzdWJuZXRMb29rdXBSZXN1bHQgPSBsb29rdXBfc3VidHJlZShbJ3N1Ym5ldCcsIGRlbGVnYXRpb24uc3VibmV0X2lkLCAnbm9kZSddLCB0cmVlKTtcbiAgICBpZiAoc3VibmV0TG9va3VwUmVzdWx0LnN0YXR1cyAhPT0gTG9va3VwU3VidHJlZVN0YXR1cy5Gb3VuZCkge1xuICAgICAgICB0aHJvdyBQcm90b2NvbEVycm9yLmZyb21Db2RlKG5ldyBMb29rdXBFcnJvckNvZGUoJ05vZGUgbm90IGZvdW5kJywgc3VibmV0TG9va3VwUmVzdWx0LnN0YXR1cykpO1xuICAgIH1cbiAgICBpZiAoc3VibmV0TG9va3VwUmVzdWx0LnZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICB0aHJvdyBVbmtub3duRXJyb3IuZnJvbUNvZGUobmV3IEhhc2hUcmVlRGVjb2RlRXJyb3JDb2RlKCdJbnZhbGlkIG5vZGUgdHJlZScpKTtcbiAgICB9XG4gICAgLy8gVGhlIGZvcmtzIGFyZSBhbGwgbGFiZWxlZCB0cmVlcyB3aXRoIHRoZSA8bm9kZV9pZD4gbGFiZWxcbiAgICBjb25zdCBub2RlRm9ya3MgPSBmbGF0dGVuX2ZvcmtzKHN1Ym5ldExvb2t1cFJlc3VsdC52YWx1ZSk7XG4gICAgY29uc3Qgbm9kZUtleXMgPSBuZXcgTWFwKCk7XG4gICAgbm9kZUZvcmtzLmZvckVhY2goZm9yayA9PiB7XG4gICAgICAgIGNvbnN0IG5vZGVfaWQgPSBQcmluY2lwYWwuZnJvbShmb3JrWzFdKS50b1RleHQoKTtcbiAgICAgICAgY29uc3QgcHVibGljS2V5TG9va3VwUmVzdWx0ID0gbG9va3VwX3BhdGgoWydwdWJsaWNfa2V5J10sIGZvcmtbMl0pO1xuICAgICAgICBpZiAocHVibGljS2V5TG9va3VwUmVzdWx0LnN0YXR1cyAhPT0gTG9va3VwUGF0aFN0YXR1cy5Gb3VuZCkge1xuICAgICAgICAgICAgdGhyb3cgUHJvdG9jb2xFcnJvci5mcm9tQ29kZShuZXcgTG9va3VwRXJyb3JDb2RlKCdQdWJsaWMga2V5IG5vdCBmb3VuZCcsIHB1YmxpY0tleUxvb2t1cFJlc3VsdC5zdGF0dXMpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkZXJFbmNvZGVkUHVibGljS2V5ID0gcHVibGljS2V5TG9va3VwUmVzdWx0LnZhbHVlO1xuICAgICAgICBpZiAoZGVyRW5jb2RlZFB1YmxpY0tleS5ieXRlTGVuZ3RoICE9PSA0NCkge1xuICAgICAgICAgICAgdGhyb3cgUHJvdG9jb2xFcnJvci5mcm9tQ29kZShuZXcgRGVyS2V5TGVuZ3RoTWlzbWF0Y2hFcnJvckNvZGUoNDQsIGRlckVuY29kZWRQdWJsaWNLZXkuYnl0ZUxlbmd0aCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbm9kZUtleXMuc2V0KG5vZGVfaWQsIGRlckVuY29kZWRQdWJsaWNLZXkpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3VibmV0SWQ6IFByaW5jaXBhbC5mcm9tVWludDhBcnJheShuZXcgVWludDhBcnJheShkZWxlZ2F0aW9uLnN1Ym5ldF9pZCkpLnRvVGV4dCgpLFxuICAgICAgICBub2RlS2V5cyxcbiAgICB9O1xufTtcbmV4cG9ydCBjb25zdCBlbmNvZGVQYXRoID0gKHBhdGgsIGNhbmlzdGVySWQpID0+IHtcbiAgICBjb25zdCBjYW5pc3RlclVpbnQ4QXJyYXkgPSBjYW5pc3RlcklkLnRvVWludDhBcnJheSgpO1xuICAgIHN3aXRjaCAocGF0aCkge1xuICAgICAgICBjYXNlICd0aW1lJzpcbiAgICAgICAgICAgIHJldHVybiBbdXRmOFRvQnl0ZXMoJ3RpbWUnKV07XG4gICAgICAgIGNhc2UgJ2NvbnRyb2xsZXJzJzpcbiAgICAgICAgICAgIHJldHVybiBbdXRmOFRvQnl0ZXMoJ2NhbmlzdGVyJyksIGNhbmlzdGVyVWludDhBcnJheSwgdXRmOFRvQnl0ZXMoJ2NvbnRyb2xsZXJzJyldO1xuICAgICAgICBjYXNlICdtb2R1bGVfaGFzaCc6XG4gICAgICAgICAgICByZXR1cm4gW3V0ZjhUb0J5dGVzKCdjYW5pc3RlcicpLCBjYW5pc3RlclVpbnQ4QXJyYXksIHV0ZjhUb0J5dGVzKCdtb2R1bGVfaGFzaCcpXTtcbiAgICAgICAgY2FzZSAnc3VibmV0JzpcbiAgICAgICAgICAgIHJldHVybiBbdXRmOFRvQnl0ZXMoJ3N1Ym5ldCcpXTtcbiAgICAgICAgY2FzZSAnY2FuZGlkJzpcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgdXRmOFRvQnl0ZXMoJ2NhbmlzdGVyJyksXG4gICAgICAgICAgICAgICAgY2FuaXN0ZXJVaW50OEFycmF5LFxuICAgICAgICAgICAgICAgIHV0ZjhUb0J5dGVzKCdtZXRhZGF0YScpLFxuICAgICAgICAgICAgICAgIHV0ZjhUb0J5dGVzKCdjYW5kaWQ6c2VydmljZScpLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIEN1c3RvbVBhdGggc2lnbmF0dXJlXG4gICAgICAgICAgICBpZiAoJ2tleScgaW4gcGF0aCAmJiAncGF0aCcgaW4gcGF0aCkge1xuICAgICAgICAgICAgICAgIC8vIEZvciBzaW1wbGlmaWVkIG1ldGFkYXRhIHF1ZXJpZXNcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHBhdGhbJ3BhdGgnXSA9PT0gJ3N0cmluZycgfHwgcGF0aFsncGF0aCddIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtZXRhUGF0aCA9IHBhdGgucGF0aDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZW5jb2RlZCA9IHR5cGVvZiBtZXRhUGF0aCA9PT0gJ3N0cmluZycgPyB1dGY4VG9CeXRlcyhtZXRhUGF0aCkgOiBtZXRhUGF0aDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFt1dGY4VG9CeXRlcygnY2FuaXN0ZXInKSwgY2FuaXN0ZXJVaW50OEFycmF5LCB1dGY4VG9CeXRlcygnbWV0YWRhdGEnKSwgZW5jb2RlZF07XG4gICAgICAgICAgICAgICAgICAgIC8vIEZvciBub24tbWV0YWRhdGEsIHJldHVybiB0aGUgcHJvdmlkZWQgY3VzdG9tcGF0aFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhdGhbJ3BhdGgnXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgVW5rbm93bkVycm9yLmZyb21Db2RlKG5ldyBVbmV4cGVjdGVkRXJyb3JDb2RlKGBFcnJvciB3aGlsZSBlbmNvZGluZyB5b3VyIHBhdGggZm9yIGNhbmlzdGVyIHN0YXR1cy4gUGxlYXNlIGVuc3VyZSB0aGF0IHlvdXIgcGF0aCAke3BhdGh9IHdhcyBmb3JtYXR0ZWQgY29ycmVjdGx5LmApKTtcbn07XG4vLyBDb250cm9sbGVycyBhcmUgQ0JPUi1lbmNvZGVkIGJ1ZmZlcnNcbmNvbnN0IGRlY29kZUNvbnRyb2xsZXJzID0gKGJ1ZikgPT4ge1xuICAgIGNvbnN0IGNvbnRyb2xsZXJzUmF3ID0gY2Jvci5kZWNvZGUoYnVmKTtcbiAgICByZXR1cm4gY29udHJvbGxlcnNSYXcubWFwKGJ1ZiA9PiB7XG4gICAgICAgIHJldHVybiBQcmluY2lwYWwuZnJvbVVpbnQ4QXJyYXkoYnVmKTtcbiAgICB9KTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/canisterStatus/index.js\n");

/***/ }),

/***/ "(ssr)/../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/cbor.js":
/*!*************************************************************************!*\
  !*** ../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/cbor.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Cbor: () => (/* binding */ Cbor),\n/* harmony export */   ToCborValue: () => (/* binding */ ToCborValue),\n/* harmony export */   decode: () => (/* binding */ decode),\n/* harmony export */   encode: () => (/* binding */ encode)\n/* harmony export */ });\n/* harmony import */ var _dfinity_principal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @dfinity/principal */ \"(ssr)/../../packages/sdk-js/node_modules/@dfinity/principal/lib/esm/principal.js\");\n/* harmony import */ var _dfinity_cbor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @dfinity/cbor */ \"(ssr)/../../packages/sdk-js/node_modules/@dfinity/cbor/dist/cbor.mjs\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./errors.js */ \"(ssr)/../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/errors.js\");\n/* harmony import */ var _agent_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./agent/index.js */ \"(ssr)/../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/agent/http/transforms.js\");\n\n\n\n\n/**\n * Used to extend classes that need to provide a custom value for the CBOR encoding process.\n */\nclass ToCborValue {\n}\nfunction hasCborValueMethod(value) {\n    return typeof value === 'object' && value !== null && 'toCborValue' in value;\n}\n/**\n * Encode a JavaScript value into CBOR. If the value is an instance of {@link ToCborValue},\n * the {@link ToCborValue.toCborValue} method will be called to get the value to encode.\n * @param value The value to encode\n */\nfunction encode(value) {\n    try {\n        return _dfinity_cbor__WEBPACK_IMPORTED_MODULE_0__.encodeWithSelfDescribedTag(value, value => {\n            if (_dfinity_principal__WEBPACK_IMPORTED_MODULE_1__.Principal.isPrincipal(value)) {\n                return value.toUint8Array();\n            }\n            if (_agent_index_js__WEBPACK_IMPORTED_MODULE_2__.Expiry.isExpiry(value)) {\n                return value.toBigInt();\n            }\n            if (hasCborValueMethod(value)) {\n                return value.toCborValue();\n            }\n            return value;\n        });\n    }\n    catch (error) {\n        throw _errors_js__WEBPACK_IMPORTED_MODULE_3__.InputError.fromCode(new _errors_js__WEBPACK_IMPORTED_MODULE_3__.CborEncodeErrorCode(error, value));\n    }\n}\n/**\n * Decode a CBOR encoded value into a JavaScript value.\n * @param input The CBOR encoded value\n */\nfunction decode(input) {\n    try {\n        return _dfinity_cbor__WEBPACK_IMPORTED_MODULE_0__.decode(input);\n    }\n    catch (error) {\n        throw _errors_js__WEBPACK_IMPORTED_MODULE_3__.InputError.fromCode(new _errors_js__WEBPACK_IMPORTED_MODULE_3__.CborDecodeErrorCode(error, input));\n    }\n}\n// Not strictly necessary, we're just keeping it for backwards compatibility.\nconst Cbor = {\n    encode,\n    decode,\n};\n//# sourceMappingURL=cbor.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vcGFja2FnZXMvc2RrLWpzL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL2Nib3IuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBK0M7QUFDVDtBQUM2QztBQUN6QztBQUMxQztBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0Usa0JBQWtCO0FBQzFGLFFBQVEsK0JBQStCO0FBQ3ZDO0FBQ0E7QUFDTztBQUNQO0FBQ0EsZUFBZSxxRUFBK0I7QUFDOUMsZ0JBQWdCLHlEQUFTO0FBQ3pCO0FBQ0E7QUFDQSxnQkFBZ0IsbURBQU07QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxjQUFjLGtEQUFVLGNBQWMsMkRBQW1CO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxlQUFlLGlEQUFXO0FBQzFCO0FBQ0E7QUFDQSxjQUFjLGtEQUFVLGNBQWMsMkRBQW1CO0FBQ3pEO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AaXF1YmUvb3BzLWNvbnNvbGUvLi4vLi4vcGFja2FnZXMvc2RrLWpzL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL2Nib3IuanM/YzNkNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQcmluY2lwYWwgfSBmcm9tICdAZGZpbml0eS9wcmluY2lwYWwnO1xuaW1wb3J0ICogYXMgY2JvciBmcm9tICdAZGZpbml0eS9jYm9yJztcbmltcG9ydCB7IENib3JEZWNvZGVFcnJvckNvZGUsIENib3JFbmNvZGVFcnJvckNvZGUsIElucHV0RXJyb3IgfSBmcm9tIFwiLi9lcnJvcnMuanNcIjtcbmltcG9ydCB7IEV4cGlyeSB9IGZyb20gXCIuL2FnZW50L2luZGV4LmpzXCI7XG4vKipcbiAqIFVzZWQgdG8gZXh0ZW5kIGNsYXNzZXMgdGhhdCBuZWVkIHRvIHByb3ZpZGUgYSBjdXN0b20gdmFsdWUgZm9yIHRoZSBDQk9SIGVuY29kaW5nIHByb2Nlc3MuXG4gKi9cbmV4cG9ydCBjbGFzcyBUb0Nib3JWYWx1ZSB7XG59XG5mdW5jdGlvbiBoYXNDYm9yVmFsdWVNZXRob2QodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCAmJiAndG9DYm9yVmFsdWUnIGluIHZhbHVlO1xufVxuLyoqXG4gKiBFbmNvZGUgYSBKYXZhU2NyaXB0IHZhbHVlIGludG8gQ0JPUi4gSWYgdGhlIHZhbHVlIGlzIGFuIGluc3RhbmNlIG9mIHtAbGluayBUb0Nib3JWYWx1ZX0sXG4gKiB0aGUge0BsaW5rIFRvQ2JvclZhbHVlLnRvQ2JvclZhbHVlfSBtZXRob2Qgd2lsbCBiZSBjYWxsZWQgdG8gZ2V0IHRoZSB2YWx1ZSB0byBlbmNvZGUuXG4gKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIGVuY29kZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlKHZhbHVlKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGNib3IuZW5jb2RlV2l0aFNlbGZEZXNjcmliZWRUYWcodmFsdWUsIHZhbHVlID0+IHtcbiAgICAgICAgICAgIGlmIChQcmluY2lwYWwuaXNQcmluY2lwYWwodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRvVWludDhBcnJheSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKEV4cGlyeS5pc0V4cGlyeSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUudG9CaWdJbnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoYXNDYm9yVmFsdWVNZXRob2QodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRvQ2JvclZhbHVlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgSW5wdXRFcnJvci5mcm9tQ29kZShuZXcgQ2JvckVuY29kZUVycm9yQ29kZShlcnJvciwgdmFsdWUpKTtcbiAgICB9XG59XG4vKipcbiAqIERlY29kZSBhIENCT1IgZW5jb2RlZCB2YWx1ZSBpbnRvIGEgSmF2YVNjcmlwdCB2YWx1ZS5cbiAqIEBwYXJhbSBpbnB1dCBUaGUgQ0JPUiBlbmNvZGVkIHZhbHVlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGUoaW5wdXQpIHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gY2Jvci5kZWNvZGUoaW5wdXQpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgSW5wdXRFcnJvci5mcm9tQ29kZShuZXcgQ2JvckRlY29kZUVycm9yQ29kZShlcnJvciwgaW5wdXQpKTtcbiAgICB9XG59XG4vLyBOb3Qgc3RyaWN0bHkgbmVjZXNzYXJ5LCB3ZSdyZSBqdXN0IGtlZXBpbmcgaXQgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuZXhwb3J0IGNvbnN0IENib3IgPSB7XG4gICAgZW5jb2RlLFxuICAgIGRlY29kZSxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jYm9yLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/cbor.js\n");

/***/ }),

/***/ "(ssr)/../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/certificate.js":
/*!********************************************************************************!*\
  !*** ../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/certificate.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Certificate: () => (/* binding */ Certificate),\n/* harmony export */   LookupLabelStatus: () => (/* binding */ LookupLabelStatus),\n/* harmony export */   LookupPathStatus: () => (/* binding */ LookupPathStatus),\n/* harmony export */   LookupSubtreeStatus: () => (/* binding */ LookupSubtreeStatus),\n/* harmony export */   NodeType: () => (/* binding */ NodeType),\n/* harmony export */   check_canister_ranges: () => (/* binding */ check_canister_ranges),\n/* harmony export */   domain_sep: () => (/* binding */ domain_sep),\n/* harmony export */   find_label: () => (/* binding */ find_label),\n/* harmony export */   flatten_forks: () => (/* binding */ flatten_forks),\n/* harmony export */   hashTreeToString: () => (/* binding */ hashTreeToString),\n/* harmony export */   lookupResultToBuffer: () => (/* binding */ lookupResultToBuffer),\n/* harmony export */   lookup_path: () => (/* binding */ lookup_path),\n/* harmony export */   lookup_subtree: () => (/* binding */ lookup_subtree),\n/* harmony export */   reconstruct: () => (/* binding */ reconstruct)\n/* harmony export */ });\n/* harmony import */ var _cbor_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./cbor.js */ \"(ssr)/../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/cbor.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.js */ \"(ssr)/../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/errors.js\");\n/* harmony import */ var _dfinity_principal__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @dfinity/principal */ \"(ssr)/../../packages/sdk-js/node_modules/@dfinity/principal/lib/esm/principal.js\");\n/* harmony import */ var _utils_bls_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/bls.js */ \"(ssr)/../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/utils/bls.js\");\n/* harmony import */ var _utils_leb_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/leb.js */ \"(ssr)/../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/utils/leb.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/hashes/utils */ \"(ssr)/../../packages/sdk-js/node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _utils_buffer_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils/buffer.js */ \"(ssr)/../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/utils/buffer.js\");\n/* harmony import */ var _noble_hashes_sha2__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @noble/hashes/sha2 */ \"(ssr)/../../packages/sdk-js/node_modules/@noble/hashes/esm/sha2.js\");\n\n\n\n\n\n\n\n\nconst MINUTES_TO_MSEC = 60 * 1000;\nconst HOURS_TO_MINUTES = 60;\nconst DAYS_TO_HOURS = 24;\nconst DAYS_TO_MINUTES = DAYS_TO_HOURS * HOURS_TO_MINUTES;\nconst DEFAULT_CERTIFICATE_MAX_AGE_IN_MINUTES = 5;\nconst DEFAULT_CERTIFICATE_MAX_MINUTES_IN_FUTURE = 5;\n// For now, we don't want to set a strict timeout on the certificate delegation freshness,\n// so we set the max age really far in the past.\nconst DEFAULT_CERTIFICATE_DELEGATION_MAX_AGE_IN_MINUTES = 30 * DAYS_TO_MINUTES;\nvar NodeType;\n(function (NodeType) {\n    NodeType[NodeType[\"Empty\"] = 0] = \"Empty\";\n    NodeType[NodeType[\"Fork\"] = 1] = \"Fork\";\n    NodeType[NodeType[\"Labeled\"] = 2] = \"Labeled\";\n    NodeType[NodeType[\"Leaf\"] = 3] = \"Leaf\";\n    NodeType[NodeType[\"Pruned\"] = 4] = \"Pruned\";\n})(NodeType || (NodeType = {}));\n/**\n * Make a human readable string out of a hash tree.\n * @param tree The hash tree to convert to a string\n */\nfunction hashTreeToString(tree) {\n    const indent = (s) => s\n        .split('\\n')\n        .map(x => '  ' + x)\n        .join('\\n');\n    function labelToString(label) {\n        const decoder = new TextDecoder(undefined, { fatal: true });\n        try {\n            return JSON.stringify(decoder.decode(label));\n            // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        }\n        catch (e) {\n            return `data(...${label.byteLength} bytes)`;\n        }\n    }\n    switch (tree[0]) {\n        case NodeType.Empty:\n            return '()';\n        case NodeType.Fork: {\n            if (tree[1] instanceof Array && tree[2] instanceof Uint8Array) {\n                const left = hashTreeToString(tree[1]);\n                const right = hashTreeToString(tree[2]);\n                return `sub(\\n left:\\n${indent(left)}\\n---\\n right:\\n${indent(right)}\\n)`;\n            }\n            else {\n                throw _errors_js__WEBPACK_IMPORTED_MODULE_0__.UnknownError.fromCode(new _errors_js__WEBPACK_IMPORTED_MODULE_0__.HashTreeDecodeErrorCode('Invalid tree structure for fork'));\n            }\n        }\n        case NodeType.Labeled: {\n            if (tree[1] instanceof Uint8Array && tree[2] instanceof Uint8Array) {\n                const label = labelToString(tree[1]);\n                const sub = hashTreeToString(tree[2]);\n                return `label(\\n label:\\n${indent(label)}\\n sub:\\n${indent(sub)}\\n)`;\n            }\n            else {\n                throw _errors_js__WEBPACK_IMPORTED_MODULE_0__.UnknownError.fromCode(new _errors_js__WEBPACK_IMPORTED_MODULE_0__.HashTreeDecodeErrorCode('Invalid tree structure for labeled'));\n            }\n        }\n        case NodeType.Leaf: {\n            if (!tree[1]) {\n                throw _errors_js__WEBPACK_IMPORTED_MODULE_0__.UnknownError.fromCode(new _errors_js__WEBPACK_IMPORTED_MODULE_0__.HashTreeDecodeErrorCode('Invalid tree structure for leaf'));\n            }\n            else if (Array.isArray(tree[1])) {\n                return JSON.stringify(tree[1]);\n            }\n            return `leaf(...${tree[1].byteLength} bytes)`;\n        }\n        case NodeType.Pruned: {\n            if (!tree[1]) {\n                throw _errors_js__WEBPACK_IMPORTED_MODULE_0__.UnknownError.fromCode(new _errors_js__WEBPACK_IMPORTED_MODULE_0__.HashTreeDecodeErrorCode('Invalid tree structure for pruned'));\n            }\n            else if (Array.isArray(tree[1])) {\n                return JSON.stringify(tree[1]);\n            }\n            return `pruned(${(0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.bytesToHex)(new Uint8Array(tree[1]))}`;\n        }\n        default: {\n            return `unknown(${JSON.stringify(tree[0])})`;\n        }\n    }\n}\nfunction isBufferGreaterThan(a, b) {\n    for (let i = 0; i < a.length; i++) {\n        if (a[i] > b[i]) {\n            return true;\n        }\n    }\n    return false;\n}\nclass Certificate {\n    #disableTimeVerification = false;\n    #agent = undefined;\n    /**\n     * Create a new instance of a certificate, automatically verifying it.\n     * @param {CreateCertificateOptions} options {@link CreateCertificateOptions}\n     * @throws if the verification of the certificate fails\n     */\n    static async create(options) {\n        const cert = Certificate.createUnverified(options);\n        await cert.verify();\n        return cert;\n    }\n    static createUnverified(options) {\n        return new Certificate(options.certificate, options.rootKey, options.canisterId, options.blsVerify ?? _utils_bls_js__WEBPACK_IMPORTED_MODULE_2__.blsVerify, options.maxAgeInMinutes, options.disableTimeVerification, options.agent);\n    }\n    constructor(certificate, _rootKey, _canisterId, _blsVerify, _maxAgeInMinutes = DEFAULT_CERTIFICATE_MAX_AGE_IN_MINUTES, disableTimeVerification = false, agent) {\n        this._rootKey = _rootKey;\n        this._canisterId = _canisterId;\n        this._blsVerify = _blsVerify;\n        this._maxAgeInMinutes = _maxAgeInMinutes;\n        this.#disableTimeVerification = disableTimeVerification;\n        this.cert = _cbor_js__WEBPACK_IMPORTED_MODULE_3__.decode(certificate);\n        if (agent && 'getTimeDiffMsecs' in agent && 'hasSyncedTime' in agent && 'syncTime' in agent) {\n            this.#agent = agent;\n        }\n    }\n    /**\n     * Lookup a path in the certificate tree, using {@link lookup_path}.\n     * @param path The path to lookup.\n     * @returns The result of the lookup.\n     */\n    lookup_path(path) {\n        return lookup_path(path, this.cert.tree);\n    }\n    /**\n     * Lookup a subtree in the certificate tree, using {@link lookup_subtree}.\n     * @param path The path to lookup.\n     * @returns The result of the lookup.\n     */\n    lookup_subtree(path) {\n        return lookup_subtree(path, this.cert.tree);\n    }\n    async verify() {\n        const rootHash = await reconstruct(this.cert.tree);\n        const derKey = await this._checkDelegationAndGetKey(this.cert.delegation);\n        const sig = this.cert.signature;\n        const key = extractDER(derKey);\n        const msg = (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(domain_sep('ic-state-root'), rootHash);\n        const lookupTime = lookupResultToBuffer(this.lookup_path(['time']));\n        if (!lookupTime) {\n            // Should never happen - time is always present in IC certificates\n            throw _errors_js__WEBPACK_IMPORTED_MODULE_0__.ProtocolError.fromCode(new _errors_js__WEBPACK_IMPORTED_MODULE_0__.CertificateVerificationErrorCode('Certificate does not contain a time'));\n        }\n        // Certificate time verification checks\n        if (!this.#disableTimeVerification) {\n            const timeDiffMsecs = this.#agent?.getTimeDiffMsecs() ?? 0;\n            const maxAgeInMsec = this._maxAgeInMinutes * MINUTES_TO_MSEC;\n            const now = new Date();\n            const adjustedNow = now.getTime() + timeDiffMsecs;\n            const earliestCertificateTime = adjustedNow - maxAgeInMsec;\n            const latestCertificateTime = adjustedNow + DEFAULT_CERTIFICATE_MAX_MINUTES_IN_FUTURE * MINUTES_TO_MSEC;\n            const certTime = (0,_utils_leb_js__WEBPACK_IMPORTED_MODULE_4__.decodeTime)(lookupTime);\n            const isCertificateTimePast = certTime.getTime() < earliestCertificateTime;\n            const isCertificateTimeFuture = certTime.getTime() > latestCertificateTime;\n            if ((isCertificateTimePast || isCertificateTimeFuture) &&\n                this.#agent &&\n                !this.#agent.hasSyncedTime()) {\n                await this.#agent.syncTime(this._canisterId);\n                return await this.verify();\n            }\n            if (isCertificateTimePast) {\n                throw _errors_js__WEBPACK_IMPORTED_MODULE_0__.TrustError.fromCode(new _errors_js__WEBPACK_IMPORTED_MODULE_0__.CertificateTimeErrorCode(this._maxAgeInMinutes, certTime, now, timeDiffMsecs, 'past'));\n            }\n            else if (isCertificateTimeFuture) {\n                if (this.#agent?.hasSyncedTime()) {\n                    // This case should never happen, and it signals a bug in either the replica or the local system.\n                    throw _errors_js__WEBPACK_IMPORTED_MODULE_0__.UnknownError.fromCode(new _errors_js__WEBPACK_IMPORTED_MODULE_0__.UnexpectedErrorCode('System time has been synced with the IC network, but certificate is still too far in the future.'));\n                }\n                throw _errors_js__WEBPACK_IMPORTED_MODULE_0__.TrustError.fromCode(new _errors_js__WEBPACK_IMPORTED_MODULE_0__.CertificateTimeErrorCode(5, certTime, now, timeDiffMsecs, 'future'));\n            }\n        }\n        try {\n            const sigVer = await this._blsVerify(key, sig, msg);\n            if (!sigVer) {\n                throw _errors_js__WEBPACK_IMPORTED_MODULE_0__.TrustError.fromCode(new _errors_js__WEBPACK_IMPORTED_MODULE_0__.CertificateVerificationErrorCode('Invalid signature'));\n            }\n        }\n        catch (err) {\n            throw _errors_js__WEBPACK_IMPORTED_MODULE_0__.TrustError.fromCode(new _errors_js__WEBPACK_IMPORTED_MODULE_0__.CertificateVerificationErrorCode('Signature verification failed', err));\n        }\n    }\n    async _checkDelegationAndGetKey(d) {\n        if (!d) {\n            return this._rootKey;\n        }\n        const cert = Certificate.createUnverified({\n            certificate: d.certificate,\n            rootKey: this._rootKey,\n            canisterId: this._canisterId,\n            blsVerify: this._blsVerify,\n            disableTimeVerification: this.#disableTimeVerification,\n            maxAgeInMinutes: DEFAULT_CERTIFICATE_DELEGATION_MAX_AGE_IN_MINUTES,\n            agent: this.#agent,\n        });\n        if (cert.cert.delegation) {\n            throw _errors_js__WEBPACK_IMPORTED_MODULE_0__.ProtocolError.fromCode(new _errors_js__WEBPACK_IMPORTED_MODULE_0__.CertificateHasTooManyDelegationsErrorCode());\n        }\n        await cert.verify();\n        const subnetIdBytes = d.subnet_id;\n        const subnetId = _dfinity_principal__WEBPACK_IMPORTED_MODULE_5__.Principal.fromUint8Array(subnetIdBytes);\n        const canisterInRange = check_canister_ranges({\n            canisterId: this._canisterId,\n            subnetId,\n            tree: cert.cert.tree,\n        });\n        if (!canisterInRange) {\n            throw _errors_js__WEBPACK_IMPORTED_MODULE_0__.TrustError.fromCode(new _errors_js__WEBPACK_IMPORTED_MODULE_0__.CertificateNotAuthorizedErrorCode(this._canisterId, subnetId));\n        }\n        const publicKeyLookup = lookupResultToBuffer(cert.lookup_path(['subnet', subnetIdBytes, 'public_key']));\n        if (!publicKeyLookup) {\n            throw _errors_js__WEBPACK_IMPORTED_MODULE_0__.TrustError.fromCode(new _errors_js__WEBPACK_IMPORTED_MODULE_0__.MissingLookupValueErrorCode(`Could not find subnet key for subnet ID ${subnetId.toText()}`));\n        }\n        return publicKeyLookup;\n    }\n}\nconst DER_PREFIX = (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.hexToBytes)('308182301d060d2b0601040182dc7c0503010201060c2b0601040182dc7c05030201036100');\nconst KEY_LENGTH = 96;\nfunction extractDER(buf) {\n    const expectedLength = DER_PREFIX.byteLength + KEY_LENGTH;\n    if (buf.byteLength !== expectedLength) {\n        throw _errors_js__WEBPACK_IMPORTED_MODULE_0__.ProtocolError.fromCode(new _errors_js__WEBPACK_IMPORTED_MODULE_0__.DerKeyLengthMismatchErrorCode(expectedLength, buf.byteLength));\n    }\n    const prefix = buf.slice(0, DER_PREFIX.byteLength);\n    if (!(0,_utils_buffer_js__WEBPACK_IMPORTED_MODULE_6__.uint8Equals)(prefix, DER_PREFIX)) {\n        throw _errors_js__WEBPACK_IMPORTED_MODULE_0__.ProtocolError.fromCode(new _errors_js__WEBPACK_IMPORTED_MODULE_0__.DerPrefixMismatchErrorCode(DER_PREFIX, prefix));\n    }\n    return buf.slice(DER_PREFIX.byteLength);\n}\n/**\n * Utility function to constrain the type of a lookup result\n * @param result the result of a lookup\n * @returns {Uint8Array | undefined} the value if the lookup was found, `undefined` otherwise\n */\nfunction lookupResultToBuffer(result) {\n    if (result.status !== LookupPathStatus.Found) {\n        return undefined;\n    }\n    if (result.value instanceof Uint8Array) {\n        return result.value;\n    }\n    return undefined;\n}\n/**\n * @param t The hash tree to reconstruct\n */\nasync function reconstruct(t) {\n    switch (t[0]) {\n        case NodeType.Empty:\n            return (0,_noble_hashes_sha2__WEBPACK_IMPORTED_MODULE_7__.sha256)(domain_sep('ic-hashtree-empty'));\n        case NodeType.Pruned:\n            return t[1];\n        case NodeType.Leaf:\n            return (0,_noble_hashes_sha2__WEBPACK_IMPORTED_MODULE_7__.sha256)((0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(domain_sep('ic-hashtree-leaf'), t[1]));\n        case NodeType.Labeled:\n            return (0,_noble_hashes_sha2__WEBPACK_IMPORTED_MODULE_7__.sha256)((0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(domain_sep('ic-hashtree-labeled'), t[1], await reconstruct(t[2])));\n        case NodeType.Fork:\n            return (0,_noble_hashes_sha2__WEBPACK_IMPORTED_MODULE_7__.sha256)((0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(domain_sep('ic-hashtree-fork'), await reconstruct(t[1]), await reconstruct(t[2])));\n        default:\n            throw _errors_js__WEBPACK_IMPORTED_MODULE_0__.UNREACHABLE_ERROR;\n    }\n}\n/**\n * Creates a domain separator for hashing by encoding the input string\n * with its length as a prefix.\n * @param s - The input string to encode.\n * @returns A Uint8Array containing the encoded domain separator.\n */\nfunction domain_sep(s) {\n    const len = new Uint8Array([s.length]);\n    const str = new TextEncoder().encode(s);\n    return (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(len, str);\n}\nfunction pathToLabel(path) {\n    return (typeof path[0] === 'string' ? (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.utf8ToBytes)(path[0]) : path[0]);\n}\nvar LookupPathStatus;\n(function (LookupPathStatus) {\n    LookupPathStatus[\"Unknown\"] = \"Unknown\";\n    LookupPathStatus[\"Absent\"] = \"Absent\";\n    LookupPathStatus[\"Found\"] = \"Found\";\n    LookupPathStatus[\"Error\"] = \"Error\";\n})(LookupPathStatus || (LookupPathStatus = {}));\nvar LookupSubtreeStatus;\n(function (LookupSubtreeStatus) {\n    LookupSubtreeStatus[\"Absent\"] = \"Absent\";\n    LookupSubtreeStatus[\"Unknown\"] = \"Unknown\";\n    LookupSubtreeStatus[\"Found\"] = \"Found\";\n})(LookupSubtreeStatus || (LookupSubtreeStatus = {}));\nvar LookupLabelStatus;\n(function (LookupLabelStatus) {\n    LookupLabelStatus[\"Absent\"] = \"Absent\";\n    LookupLabelStatus[\"Unknown\"] = \"Unknown\";\n    LookupLabelStatus[\"Found\"] = \"Found\";\n    LookupLabelStatus[\"Less\"] = \"Less\";\n    LookupLabelStatus[\"Greater\"] = \"Greater\";\n})(LookupLabelStatus || (LookupLabelStatus = {}));\n/**\n * Lookup a path in a tree. If the path is a subtree, use {@link lookup_subtree} instead.\n * @param path the path to look up\n * @param tree the tree to search\n * @returns {LookupResult} the result of the lookup\n */\nfunction lookup_path(path, tree) {\n    if (path.length === 0) {\n        switch (tree[0]) {\n            case NodeType.Empty: {\n                return {\n                    status: LookupPathStatus.Absent,\n                };\n            }\n            case NodeType.Leaf: {\n                if (!tree[1]) {\n                    throw _errors_js__WEBPACK_IMPORTED_MODULE_0__.UnknownError.fromCode(new _errors_js__WEBPACK_IMPORTED_MODULE_0__.HashTreeDecodeErrorCode('Invalid tree structure for leaf'));\n                }\n                if (tree[1] instanceof Uint8Array) {\n                    return {\n                        status: LookupPathStatus.Found,\n                        value: tree[1].slice(tree[1].byteOffset, tree[1].byteLength + tree[1].byteOffset),\n                    };\n                }\n                throw _errors_js__WEBPACK_IMPORTED_MODULE_0__.UNREACHABLE_ERROR;\n            }\n            case NodeType.Pruned: {\n                return {\n                    status: LookupPathStatus.Unknown,\n                };\n            }\n            case NodeType.Labeled:\n            case NodeType.Fork: {\n                return {\n                    status: LookupPathStatus.Error,\n                };\n            }\n            default: {\n                throw _errors_js__WEBPACK_IMPORTED_MODULE_0__.UNREACHABLE_ERROR;\n            }\n        }\n    }\n    const label = pathToLabel(path);\n    const lookupResult = find_label(label, tree);\n    switch (lookupResult.status) {\n        case LookupLabelStatus.Found: {\n            return lookup_path(path.slice(1), lookupResult.value);\n        }\n        case LookupLabelStatus.Absent:\n        case LookupLabelStatus.Greater:\n        case LookupLabelStatus.Less: {\n            return {\n                status: LookupPathStatus.Absent,\n            };\n        }\n        case LookupLabelStatus.Unknown: {\n            return {\n                status: LookupPathStatus.Unknown,\n            };\n        }\n        default: {\n            throw _errors_js__WEBPACK_IMPORTED_MODULE_0__.UNREACHABLE_ERROR;\n        }\n    }\n}\n/**\n * Lookup a subtree in a tree.\n * @param path the path to look up\n * @param tree the tree to search\n * @returns {SubtreeLookupResult} the result of the lookup\n */\nfunction lookup_subtree(path, tree) {\n    if (path.length === 0) {\n        return {\n            status: LookupSubtreeStatus.Found,\n            value: tree,\n        };\n    }\n    const label = pathToLabel(path);\n    const lookupResult = find_label(label, tree);\n    switch (lookupResult.status) {\n        case LookupLabelStatus.Found: {\n            return lookup_subtree(path.slice(1), lookupResult.value);\n        }\n        case LookupLabelStatus.Unknown: {\n            return {\n                status: LookupSubtreeStatus.Unknown,\n            };\n        }\n        case LookupLabelStatus.Absent:\n        case LookupLabelStatus.Greater:\n        case LookupLabelStatus.Less: {\n            return {\n                status: LookupSubtreeStatus.Absent,\n            };\n        }\n        default: {\n            throw _errors_js__WEBPACK_IMPORTED_MODULE_0__.UNREACHABLE_ERROR;\n        }\n    }\n}\n/**\n * If the tree is a fork, flatten it into an array of trees\n * @param {HashTree} t the tree to flatten\n * @returns {HashTree[]} the flattened tree\n */\nfunction flatten_forks(t) {\n    switch (t[0]) {\n        case NodeType.Empty:\n            return [];\n        case NodeType.Fork:\n            return flatten_forks(t[1]).concat(flatten_forks(t[2]));\n        default:\n            return [t];\n    }\n}\n/**\n * Find a label in a tree\n * @param label the label to find\n * @param tree the tree to search\n * @returns {LabelLookupResult} the result of the label lookup\n */\nfunction find_label(label, tree) {\n    switch (tree[0]) {\n        // if we have a labelled node, compare the node's label to the one we are\n        // looking for\n        case NodeType.Labeled:\n            // if the label we're searching for is greater than this node's label,\n            // we need to keep searching\n            if (isBufferGreaterThan(label, tree[1])) {\n                return {\n                    status: LookupLabelStatus.Greater,\n                };\n            }\n            // if the label we're searching for is equal this node's label, we can\n            // stop searching and return the found node\n            if ((0,_utils_buffer_js__WEBPACK_IMPORTED_MODULE_6__.uint8Equals)(label, tree[1])) {\n                return {\n                    status: LookupLabelStatus.Found,\n                    value: tree[2],\n                };\n            }\n            // if the label we're searching for is not greater than or equal to this\n            // node's label, then it's less than this node's label, and we can stop\n            // searching because we've looked too far\n            return {\n                status: LookupLabelStatus.Less,\n            };\n        // if we have a fork node, we need to search both sides, starting with the left\n        case NodeType.Fork: {\n            // search in the left node\n            const leftLookupResult = find_label(label, tree[1]);\n            switch (leftLookupResult.status) {\n                // if the label we're searching for is greater than the left node lookup,\n                // we need to search the right node\n                case LookupLabelStatus.Greater: {\n                    const rightLookupResult = find_label(label, tree[2]);\n                    // if the label we're searching for is less than the right node lookup,\n                    // then we can stop searching and say that the label is provably Absent\n                    if (rightLookupResult.status === LookupLabelStatus.Less) {\n                        return {\n                            status: LookupLabelStatus.Absent,\n                        };\n                    }\n                    // if the label we're searching for is less than or equal to the right\n                    // node lookup, then we let the caller handle it\n                    return rightLookupResult;\n                }\n                // if the left node returns an uncertain result, we need to search the\n                // right node\n                case LookupLabelStatus.Unknown: {\n                    const rightLookupResult = find_label(label, tree[2]);\n                    // if the label we're searching for is less than the right node lookup,\n                    // then we also need to return an uncertain result\n                    if (rightLookupResult.status === LookupLabelStatus.Less) {\n                        return {\n                            status: LookupLabelStatus.Unknown,\n                        };\n                    }\n                    // if the label we're searching for is less than or equal to the right\n                    // node lookup, then we let the caller handle it\n                    return rightLookupResult;\n                }\n                // if the label we're searching for is not greater than the left node\n                // lookup, or the result is not uncertain, we stop searching and return\n                // whatever the result of the left node lookup was, which can be either\n                // Found or Absent\n                default: {\n                    return leftLookupResult;\n                }\n            }\n        }\n        // if we encounter a Pruned node, we can't know for certain if the label\n        // we're searching for is present or not\n        case NodeType.Pruned:\n            return {\n                status: LookupLabelStatus.Unknown,\n            };\n        // if the current node is Empty, or a Leaf, we can stop searching because\n        // we know for sure that the label we're searching for is not present\n        default:\n            return {\n                status: LookupLabelStatus.Absent,\n            };\n    }\n}\n/**\n * Check if a canister ID falls within the canister ranges of a given subnet\n * @param params the parameters with which to check the canister ranges\n * @param params.canisterId the canister ID to check\n * @param params.subnetId the subnet ID from which to check the canister ranges\n * @param params.tree the hash tree in which to lookup the subnet's canister ranges\n * @returns {boolean} `true` if the canister is in the range, `false` otherwise\n */\nfunction check_canister_ranges(params) {\n    const { canisterId, subnetId, tree } = params;\n    const rangeLookup = lookup_path(['subnet', subnetId.toUint8Array(), 'canister_ranges'], tree);\n    if (rangeLookup.status !== LookupPathStatus.Found) {\n        throw _errors_js__WEBPACK_IMPORTED_MODULE_0__.ProtocolError.fromCode(new _errors_js__WEBPACK_IMPORTED_MODULE_0__.LookupErrorCode(`Could not find canister ranges for subnet ${subnetId.toText()}`, rangeLookup.status));\n    }\n    if (!(rangeLookup.value instanceof Uint8Array)) {\n        throw _errors_js__WEBPACK_IMPORTED_MODULE_0__.ProtocolError.fromCode(new _errors_js__WEBPACK_IMPORTED_MODULE_0__.MalformedLookupFoundValueErrorCode(`Could not find canister ranges for subnet ${subnetId.toText()}`));\n    }\n    const ranges_arr = _cbor_js__WEBPACK_IMPORTED_MODULE_3__.decode(rangeLookup.value);\n    const ranges = ranges_arr.map(v => [\n        _dfinity_principal__WEBPACK_IMPORTED_MODULE_5__.Principal.fromUint8Array(v[0]),\n        _dfinity_principal__WEBPACK_IMPORTED_MODULE_5__.Principal.fromUint8Array(v[1]),\n    ]);\n    const canisterInRange = ranges.some(r => r[0].ltEq(canisterId) && r[1].gtEq(canisterId));\n    return canisterInRange;\n}\n//# sourceMappingURL=certificate.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vcGFja2FnZXMvc2RrLWpzL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL2NlcnRpZmljYXRlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBa0M7QUFDNlg7QUFDaFg7QUFDVDtBQUNNO0FBQzJDO0FBQ3ZDO0FBQ0o7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDRCQUE0QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxhQUFhO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0JBQWtCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxhQUFhLGtCQUFrQixjQUFjO0FBQ3JGO0FBQ0E7QUFDQSxzQkFBc0Isb0RBQVksY0FBYywrREFBdUI7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGNBQWMsV0FBVyxZQUFZO0FBQ2hGO0FBQ0E7QUFDQSxzQkFBc0Isb0RBQVksY0FBYywrREFBdUI7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isb0RBQVksY0FBYywrREFBdUI7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsb0JBQW9CO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixvREFBWSxjQUFjLCtEQUF1QjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QiwrREFBVSwwQkFBMEI7QUFDakU7QUFDQTtBQUNBLDhCQUE4Qix3QkFBd0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQ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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDTztBQUNQLFlBQVksNkJBQTZCO0FBQ3pDO0FBQ0E7QUFDQSxjQUFjLHFEQUFhLGNBQWMsdURBQWUsOENBQThDLGtCQUFrQjtBQUN4SDtBQUNBO0FBQ0EsY0FBYyxxREFBYSxjQUFjLDBFQUFrQyw4Q0FBOEMsa0JBQWtCO0FBQzNJO0FBQ0EsdUJBQXVCLDRDQUFXO0FBQ2xDO0FBQ0EsUUFBUSx5REFBUztBQUNqQixRQUFRLHlEQUFTO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AaXF1YmUvb3BzLWNvbnNvbGUvLi4vLi4vcGFja2FnZXMvc2RrLWpzL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL2NlcnRpZmljYXRlLmpzP2E3ZWUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgY2JvciBmcm9tIFwiLi9jYm9yLmpzXCI7XG5pbXBvcnQgeyBDZXJ0aWZpY2F0ZUhhc1Rvb01hbnlEZWxlZ2F0aW9uc0Vycm9yQ29kZSwgQ2VydGlmaWNhdGVOb3RBdXRob3JpemVkRXJyb3JDb2RlLCBDZXJ0aWZpY2F0ZVRpbWVFcnJvckNvZGUsIENlcnRpZmljYXRlVmVyaWZpY2F0aW9uRXJyb3JDb2RlLCBEZXJLZXlMZW5ndGhNaXNtYXRjaEVycm9yQ29kZSwgRGVyUHJlZml4TWlzbWF0Y2hFcnJvckNvZGUsIFByb3RvY29sRXJyb3IsIExvb2t1cEVycm9yQ29kZSwgVHJ1c3RFcnJvciwgVW5rbm93bkVycm9yLCBIYXNoVHJlZURlY29kZUVycm9yQ29kZSwgVU5SRUFDSEFCTEVfRVJST1IsIE1hbGZvcm1lZExvb2t1cEZvdW5kVmFsdWVFcnJvckNvZGUsIE1pc3NpbmdMb29rdXBWYWx1ZUVycm9yQ29kZSwgVW5leHBlY3RlZEVycm9yQ29kZSwgfSBmcm9tIFwiLi9lcnJvcnMuanNcIjtcbmltcG9ydCB7IFByaW5jaXBhbCB9IGZyb20gJ0BkZmluaXR5L3ByaW5jaXBhbCc7XG5pbXBvcnQgKiBhcyBibHMgZnJvbSBcIi4vdXRpbHMvYmxzLmpzXCI7XG5pbXBvcnQgeyBkZWNvZGVUaW1lIH0gZnJvbSBcIi4vdXRpbHMvbGViLmpzXCI7XG5pbXBvcnQgeyBieXRlc1RvSGV4LCBjb25jYXRCeXRlcywgaGV4VG9CeXRlcywgdXRmOFRvQnl0ZXMgfSBmcm9tICdAbm9ibGUvaGFzaGVzL3V0aWxzJztcbmltcG9ydCB7IHVpbnQ4RXF1YWxzIH0gZnJvbSBcIi4vdXRpbHMvYnVmZmVyLmpzXCI7XG5pbXBvcnQgeyBzaGEyNTYgfSBmcm9tICdAbm9ibGUvaGFzaGVzL3NoYTInO1xuY29uc3QgTUlOVVRFU19UT19NU0VDID0gNjAgKiAxMDAwO1xuY29uc3QgSE9VUlNfVE9fTUlOVVRFUyA9IDYwO1xuY29uc3QgREFZU19UT19IT1VSUyA9IDI0O1xuY29uc3QgREFZU19UT19NSU5VVEVTID0gREFZU19UT19IT1VSUyAqIEhPVVJTX1RPX01JTlVURVM7XG5jb25zdCBERUZBVUxUX0NFUlRJRklDQVRFX01BWF9BR0VfSU5fTUlOVVRFUyA9IDU7XG5jb25zdCBERUZBVUxUX0NFUlRJRklDQVRFX01BWF9NSU5VVEVTX0lOX0ZVVFVSRSA9IDU7XG4vLyBGb3Igbm93LCB3ZSBkb24ndCB3YW50IHRvIHNldCBhIHN0cmljdCB0aW1lb3V0IG9uIHRoZSBjZXJ0aWZpY2F0ZSBkZWxlZ2F0aW9uIGZyZXNobmVzcyxcbi8vIHNvIHdlIHNldCB0aGUgbWF4IGFnZSByZWFsbHkgZmFyIGluIHRoZSBwYXN0LlxuY29uc3QgREVGQVVMVF9DRVJUSUZJQ0FURV9ERUxFR0FUSU9OX01BWF9BR0VfSU5fTUlOVVRFUyA9IDMwICogREFZU19UT19NSU5VVEVTO1xuZXhwb3J0IHZhciBOb2RlVHlwZTtcbihmdW5jdGlvbiAoTm9kZVR5cGUpIHtcbiAgICBOb2RlVHlwZVtOb2RlVHlwZVtcIkVtcHR5XCJdID0gMF0gPSBcIkVtcHR5XCI7XG4gICAgTm9kZVR5cGVbTm9kZVR5cGVbXCJGb3JrXCJdID0gMV0gPSBcIkZvcmtcIjtcbiAgICBOb2RlVHlwZVtOb2RlVHlwZVtcIkxhYmVsZWRcIl0gPSAyXSA9IFwiTGFiZWxlZFwiO1xuICAgIE5vZGVUeXBlW05vZGVUeXBlW1wiTGVhZlwiXSA9IDNdID0gXCJMZWFmXCI7XG4gICAgTm9kZVR5cGVbTm9kZVR5cGVbXCJQcnVuZWRcIl0gPSA0XSA9IFwiUHJ1bmVkXCI7XG59KShOb2RlVHlwZSB8fCAoTm9kZVR5cGUgPSB7fSkpO1xuLyoqXG4gKiBNYWtlIGEgaHVtYW4gcmVhZGFibGUgc3RyaW5nIG91dCBvZiBhIGhhc2ggdHJlZS5cbiAqIEBwYXJhbSB0cmVlIFRoZSBoYXNoIHRyZWUgdG8gY29udmVydCB0byBhIHN0cmluZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gaGFzaFRyZWVUb1N0cmluZyh0cmVlKSB7XG4gICAgY29uc3QgaW5kZW50ID0gKHMpID0+IHNcbiAgICAgICAgLnNwbGl0KCdcXG4nKVxuICAgICAgICAubWFwKHggPT4gJyAgJyArIHgpXG4gICAgICAgIC5qb2luKCdcXG4nKTtcbiAgICBmdW5jdGlvbiBsYWJlbFRvU3RyaW5nKGxhYmVsKSB7XG4gICAgICAgIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIodW5kZWZpbmVkLCB7IGZhdGFsOiB0cnVlIH0pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGRlY29kZXIuZGVjb2RlKGxhYmVsKSk7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBgZGF0YSguLi4ke2xhYmVsLmJ5dGVMZW5ndGh9IGJ5dGVzKWA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3dpdGNoICh0cmVlWzBdKSB7XG4gICAgICAgIGNhc2UgTm9kZVR5cGUuRW1wdHk6XG4gICAgICAgICAgICByZXR1cm4gJygpJztcbiAgICAgICAgY2FzZSBOb2RlVHlwZS5Gb3JrOiB7XG4gICAgICAgICAgICBpZiAodHJlZVsxXSBpbnN0YW5jZW9mIEFycmF5ICYmIHRyZWVbMl0gaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGVmdCA9IGhhc2hUcmVlVG9TdHJpbmcodHJlZVsxXSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmlnaHQgPSBoYXNoVHJlZVRvU3RyaW5nKHRyZWVbMl0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBgc3ViKFxcbiBsZWZ0OlxcbiR7aW5kZW50KGxlZnQpfVxcbi0tLVxcbiByaWdodDpcXG4ke2luZGVudChyaWdodCl9XFxuKWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBVbmtub3duRXJyb3IuZnJvbUNvZGUobmV3IEhhc2hUcmVlRGVjb2RlRXJyb3JDb2RlKCdJbnZhbGlkIHRyZWUgc3RydWN0dXJlIGZvciBmb3JrJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhc2UgTm9kZVR5cGUuTGFiZWxlZDoge1xuICAgICAgICAgICAgaWYgKHRyZWVbMV0gaW5zdGFuY2VvZiBVaW50OEFycmF5ICYmIHRyZWVbMl0gaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGFiZWwgPSBsYWJlbFRvU3RyaW5nKHRyZWVbMV0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN1YiA9IGhhc2hUcmVlVG9TdHJpbmcodHJlZVsyXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGBsYWJlbChcXG4gbGFiZWw6XFxuJHtpbmRlbnQobGFiZWwpfVxcbiBzdWI6XFxuJHtpbmRlbnQoc3ViKX1cXG4pYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IFVua25vd25FcnJvci5mcm9tQ29kZShuZXcgSGFzaFRyZWVEZWNvZGVFcnJvckNvZGUoJ0ludmFsaWQgdHJlZSBzdHJ1Y3R1cmUgZm9yIGxhYmVsZWQnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBOb2RlVHlwZS5MZWFmOiB7XG4gICAgICAgICAgICBpZiAoIXRyZWVbMV0pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBVbmtub3duRXJyb3IuZnJvbUNvZGUobmV3IEhhc2hUcmVlRGVjb2RlRXJyb3JDb2RlKCdJbnZhbGlkIHRyZWUgc3RydWN0dXJlIGZvciBsZWFmJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh0cmVlWzFdKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0cmVlWzFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBgbGVhZiguLi4ke3RyZWVbMV0uYnl0ZUxlbmd0aH0gYnl0ZXMpYDtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIE5vZGVUeXBlLlBydW5lZDoge1xuICAgICAgICAgICAgaWYgKCF0cmVlWzFdKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgVW5rbm93bkVycm9yLmZyb21Db2RlKG5ldyBIYXNoVHJlZURlY29kZUVycm9yQ29kZSgnSW52YWxpZCB0cmVlIHN0cnVjdHVyZSBmb3IgcHJ1bmVkJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh0cmVlWzFdKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0cmVlWzFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBgcHJ1bmVkKCR7Ynl0ZXNUb0hleChuZXcgVWludDhBcnJheSh0cmVlWzFdKSl9YDtcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICByZXR1cm4gYHVua25vd24oJHtKU09OLnN0cmluZ2lmeSh0cmVlWzBdKX0pYDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGlzQnVmZmVyR3JlYXRlclRoYW4oYSwgYikge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoYVtpXSA+IGJbaV0pIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmV4cG9ydCBjbGFzcyBDZXJ0aWZpY2F0ZSB7XG4gICAgI2Rpc2FibGVUaW1lVmVyaWZpY2F0aW9uID0gZmFsc2U7XG4gICAgI2FnZW50ID0gdW5kZWZpbmVkO1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiBhIGNlcnRpZmljYXRlLCBhdXRvbWF0aWNhbGx5IHZlcmlmeWluZyBpdC5cbiAgICAgKiBAcGFyYW0ge0NyZWF0ZUNlcnRpZmljYXRlT3B0aW9uc30gb3B0aW9ucyB7QGxpbmsgQ3JlYXRlQ2VydGlmaWNhdGVPcHRpb25zfVxuICAgICAqIEB0aHJvd3MgaWYgdGhlIHZlcmlmaWNhdGlvbiBvZiB0aGUgY2VydGlmaWNhdGUgZmFpbHNcbiAgICAgKi9cbiAgICBzdGF0aWMgYXN5bmMgY3JlYXRlKG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgY2VydCA9IENlcnRpZmljYXRlLmNyZWF0ZVVudmVyaWZpZWQob3B0aW9ucyk7XG4gICAgICAgIGF3YWl0IGNlcnQudmVyaWZ5KCk7XG4gICAgICAgIHJldHVybiBjZXJ0O1xuICAgIH1cbiAgICBzdGF0aWMgY3JlYXRlVW52ZXJpZmllZChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2VydGlmaWNhdGUob3B0aW9ucy5jZXJ0aWZpY2F0ZSwgb3B0aW9ucy5yb290S2V5LCBvcHRpb25zLmNhbmlzdGVySWQsIG9wdGlvbnMuYmxzVmVyaWZ5ID8/IGJscy5ibHNWZXJpZnksIG9wdGlvbnMubWF4QWdlSW5NaW51dGVzLCBvcHRpb25zLmRpc2FibGVUaW1lVmVyaWZpY2F0aW9uLCBvcHRpb25zLmFnZW50KTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoY2VydGlmaWNhdGUsIF9yb290S2V5LCBfY2FuaXN0ZXJJZCwgX2Jsc1ZlcmlmeSwgX21heEFnZUluTWludXRlcyA9IERFRkFVTFRfQ0VSVElGSUNBVEVfTUFYX0FHRV9JTl9NSU5VVEVTLCBkaXNhYmxlVGltZVZlcmlmaWNhdGlvbiA9IGZhbHNlLCBhZ2VudCkge1xuICAgICAgICB0aGlzLl9yb290S2V5ID0gX3Jvb3RLZXk7XG4gICAgICAgIHRoaXMuX2NhbmlzdGVySWQgPSBfY2FuaXN0ZXJJZDtcbiAgICAgICAgdGhpcy5fYmxzVmVyaWZ5ID0gX2Jsc1ZlcmlmeTtcbiAgICAgICAgdGhpcy5fbWF4QWdlSW5NaW51dGVzID0gX21heEFnZUluTWludXRlcztcbiAgICAgICAgdGhpcy4jZGlzYWJsZVRpbWVWZXJpZmljYXRpb24gPSBkaXNhYmxlVGltZVZlcmlmaWNhdGlvbjtcbiAgICAgICAgdGhpcy5jZXJ0ID0gY2Jvci5kZWNvZGUoY2VydGlmaWNhdGUpO1xuICAgICAgICBpZiAoYWdlbnQgJiYgJ2dldFRpbWVEaWZmTXNlY3MnIGluIGFnZW50ICYmICdoYXNTeW5jZWRUaW1lJyBpbiBhZ2VudCAmJiAnc3luY1RpbWUnIGluIGFnZW50KSB7XG4gICAgICAgICAgICB0aGlzLiNhZ2VudCA9IGFnZW50O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvb2t1cCBhIHBhdGggaW4gdGhlIGNlcnRpZmljYXRlIHRyZWUsIHVzaW5nIHtAbGluayBsb29rdXBfcGF0aH0uXG4gICAgICogQHBhcmFtIHBhdGggVGhlIHBhdGggdG8gbG9va3VwLlxuICAgICAqIEByZXR1cm5zIFRoZSByZXN1bHQgb2YgdGhlIGxvb2t1cC5cbiAgICAgKi9cbiAgICBsb29rdXBfcGF0aChwYXRoKSB7XG4gICAgICAgIHJldHVybiBsb29rdXBfcGF0aChwYXRoLCB0aGlzLmNlcnQudHJlZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvb2t1cCBhIHN1YnRyZWUgaW4gdGhlIGNlcnRpZmljYXRlIHRyZWUsIHVzaW5nIHtAbGluayBsb29rdXBfc3VidHJlZX0uXG4gICAgICogQHBhcmFtIHBhdGggVGhlIHBhdGggdG8gbG9va3VwLlxuICAgICAqIEByZXR1cm5zIFRoZSByZXN1bHQgb2YgdGhlIGxvb2t1cC5cbiAgICAgKi9cbiAgICBsb29rdXBfc3VidHJlZShwYXRoKSB7XG4gICAgICAgIHJldHVybiBsb29rdXBfc3VidHJlZShwYXRoLCB0aGlzLmNlcnQudHJlZSk7XG4gICAgfVxuICAgIGFzeW5jIHZlcmlmeSgpIHtcbiAgICAgICAgY29uc3Qgcm9vdEhhc2ggPSBhd2FpdCByZWNvbnN0cnVjdCh0aGlzLmNlcnQudHJlZSk7XG4gICAgICAgIGNvbnN0IGRlcktleSA9IGF3YWl0IHRoaXMuX2NoZWNrRGVsZWdhdGlvbkFuZEdldEtleSh0aGlzLmNlcnQuZGVsZWdhdGlvbik7XG4gICAgICAgIGNvbnN0IHNpZyA9IHRoaXMuY2VydC5zaWduYXR1cmU7XG4gICAgICAgIGNvbnN0IGtleSA9IGV4dHJhY3RERVIoZGVyS2V5KTtcbiAgICAgICAgY29uc3QgbXNnID0gY29uY2F0Qnl0ZXMoZG9tYWluX3NlcCgnaWMtc3RhdGUtcm9vdCcpLCByb290SGFzaCk7XG4gICAgICAgIGNvbnN0IGxvb2t1cFRpbWUgPSBsb29rdXBSZXN1bHRUb0J1ZmZlcih0aGlzLmxvb2t1cF9wYXRoKFsndGltZSddKSk7XG4gICAgICAgIGlmICghbG9va3VwVGltZSkge1xuICAgICAgICAgICAgLy8gU2hvdWxkIG5ldmVyIGhhcHBlbiAtIHRpbWUgaXMgYWx3YXlzIHByZXNlbnQgaW4gSUMgY2VydGlmaWNhdGVzXG4gICAgICAgICAgICB0aHJvdyBQcm90b2NvbEVycm9yLmZyb21Db2RlKG5ldyBDZXJ0aWZpY2F0ZVZlcmlmaWNhdGlvbkVycm9yQ29kZSgnQ2VydGlmaWNhdGUgZG9lcyBub3QgY29udGFpbiBhIHRpbWUnKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2VydGlmaWNhdGUgdGltZSB2ZXJpZmljYXRpb24gY2hlY2tzXG4gICAgICAgIGlmICghdGhpcy4jZGlzYWJsZVRpbWVWZXJpZmljYXRpb24pIHtcbiAgICAgICAgICAgIGNvbnN0IHRpbWVEaWZmTXNlY3MgPSB0aGlzLiNhZ2VudD8uZ2V0VGltZURpZmZNc2VjcygpID8/IDA7XG4gICAgICAgICAgICBjb25zdCBtYXhBZ2VJbk1zZWMgPSB0aGlzLl9tYXhBZ2VJbk1pbnV0ZXMgKiBNSU5VVEVTX1RPX01TRUM7XG4gICAgICAgICAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgY29uc3QgYWRqdXN0ZWROb3cgPSBub3cuZ2V0VGltZSgpICsgdGltZURpZmZNc2VjcztcbiAgICAgICAgICAgIGNvbnN0IGVhcmxpZXN0Q2VydGlmaWNhdGVUaW1lID0gYWRqdXN0ZWROb3cgLSBtYXhBZ2VJbk1zZWM7XG4gICAgICAgICAgICBjb25zdCBsYXRlc3RDZXJ0aWZpY2F0ZVRpbWUgPSBhZGp1c3RlZE5vdyArIERFRkFVTFRfQ0VSVElGSUNBVEVfTUFYX01JTlVURVNfSU5fRlVUVVJFICogTUlOVVRFU19UT19NU0VDO1xuICAgICAgICAgICAgY29uc3QgY2VydFRpbWUgPSBkZWNvZGVUaW1lKGxvb2t1cFRpbWUpO1xuICAgICAgICAgICAgY29uc3QgaXNDZXJ0aWZpY2F0ZVRpbWVQYXN0ID0gY2VydFRpbWUuZ2V0VGltZSgpIDwgZWFybGllc3RDZXJ0aWZpY2F0ZVRpbWU7XG4gICAgICAgICAgICBjb25zdCBpc0NlcnRpZmljYXRlVGltZUZ1dHVyZSA9IGNlcnRUaW1lLmdldFRpbWUoKSA+IGxhdGVzdENlcnRpZmljYXRlVGltZTtcbiAgICAgICAgICAgIGlmICgoaXNDZXJ0aWZpY2F0ZVRpbWVQYXN0IHx8IGlzQ2VydGlmaWNhdGVUaW1lRnV0dXJlKSAmJlxuICAgICAgICAgICAgICAgIHRoaXMuI2FnZW50ICYmXG4gICAgICAgICAgICAgICAgIXRoaXMuI2FnZW50Lmhhc1N5bmNlZFRpbWUoKSkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuI2FnZW50LnN5bmNUaW1lKHRoaXMuX2NhbmlzdGVySWQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnZlcmlmeSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzQ2VydGlmaWNhdGVUaW1lUGFzdCkge1xuICAgICAgICAgICAgICAgIHRocm93IFRydXN0RXJyb3IuZnJvbUNvZGUobmV3IENlcnRpZmljYXRlVGltZUVycm9yQ29kZSh0aGlzLl9tYXhBZ2VJbk1pbnV0ZXMsIGNlcnRUaW1lLCBub3csIHRpbWVEaWZmTXNlY3MsICdwYXN0JykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNDZXJ0aWZpY2F0ZVRpbWVGdXR1cmUpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy4jYWdlbnQ/Lmhhc1N5bmNlZFRpbWUoKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGNhc2Ugc2hvdWxkIG5ldmVyIGhhcHBlbiwgYW5kIGl0IHNpZ25hbHMgYSBidWcgaW4gZWl0aGVyIHRoZSByZXBsaWNhIG9yIHRoZSBsb2NhbCBzeXN0ZW0uXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFVua25vd25FcnJvci5mcm9tQ29kZShuZXcgVW5leHBlY3RlZEVycm9yQ29kZSgnU3lzdGVtIHRpbWUgaGFzIGJlZW4gc3luY2VkIHdpdGggdGhlIElDIG5ldHdvcmssIGJ1dCBjZXJ0aWZpY2F0ZSBpcyBzdGlsbCB0b28gZmFyIGluIHRoZSBmdXR1cmUuJykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBUcnVzdEVycm9yLmZyb21Db2RlKG5ldyBDZXJ0aWZpY2F0ZVRpbWVFcnJvckNvZGUoNSwgY2VydFRpbWUsIG5vdywgdGltZURpZmZNc2VjcywgJ2Z1dHVyZScpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3Qgc2lnVmVyID0gYXdhaXQgdGhpcy5fYmxzVmVyaWZ5KGtleSwgc2lnLCBtc2cpO1xuICAgICAgICAgICAgaWYgKCFzaWdWZXIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBUcnVzdEVycm9yLmZyb21Db2RlKG5ldyBDZXJ0aWZpY2F0ZVZlcmlmaWNhdGlvbkVycm9yQ29kZSgnSW52YWxpZCBzaWduYXR1cmUnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhyb3cgVHJ1c3RFcnJvci5mcm9tQ29kZShuZXcgQ2VydGlmaWNhdGVWZXJpZmljYXRpb25FcnJvckNvZGUoJ1NpZ25hdHVyZSB2ZXJpZmljYXRpb24gZmFpbGVkJywgZXJyKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgX2NoZWNrRGVsZWdhdGlvbkFuZEdldEtleShkKSB7XG4gICAgICAgIGlmICghZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Jvb3RLZXk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2VydCA9IENlcnRpZmljYXRlLmNyZWF0ZVVudmVyaWZpZWQoe1xuICAgICAgICAgICAgY2VydGlmaWNhdGU6IGQuY2VydGlmaWNhdGUsXG4gICAgICAgICAgICByb290S2V5OiB0aGlzLl9yb290S2V5LFxuICAgICAgICAgICAgY2FuaXN0ZXJJZDogdGhpcy5fY2FuaXN0ZXJJZCxcbiAgICAgICAgICAgIGJsc1ZlcmlmeTogdGhpcy5fYmxzVmVyaWZ5LFxuICAgICAgICAgICAgZGlzYWJsZVRpbWVWZXJpZmljYXRpb246IHRoaXMuI2Rpc2FibGVUaW1lVmVyaWZpY2F0aW9uLFxuICAgICAgICAgICAgbWF4QWdlSW5NaW51dGVzOiBERUZBVUxUX0NFUlRJRklDQVRFX0RFTEVHQVRJT05fTUFYX0FHRV9JTl9NSU5VVEVTLFxuICAgICAgICAgICAgYWdlbnQ6IHRoaXMuI2FnZW50LFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGNlcnQuY2VydC5kZWxlZ2F0aW9uKSB7XG4gICAgICAgICAgICB0aHJvdyBQcm90b2NvbEVycm9yLmZyb21Db2RlKG5ldyBDZXJ0aWZpY2F0ZUhhc1Rvb01hbnlEZWxlZ2F0aW9uc0Vycm9yQ29kZSgpKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBjZXJ0LnZlcmlmeSgpO1xuICAgICAgICBjb25zdCBzdWJuZXRJZEJ5dGVzID0gZC5zdWJuZXRfaWQ7XG4gICAgICAgIGNvbnN0IHN1Ym5ldElkID0gUHJpbmNpcGFsLmZyb21VaW50OEFycmF5KHN1Ym5ldElkQnl0ZXMpO1xuICAgICAgICBjb25zdCBjYW5pc3RlckluUmFuZ2UgPSBjaGVja19jYW5pc3Rlcl9yYW5nZXMoe1xuICAgICAgICAgICAgY2FuaXN0ZXJJZDogdGhpcy5fY2FuaXN0ZXJJZCxcbiAgICAgICAgICAgIHN1Ym5ldElkLFxuICAgICAgICAgICAgdHJlZTogY2VydC5jZXJ0LnRyZWUsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIWNhbmlzdGVySW5SYW5nZSkge1xuICAgICAgICAgICAgdGhyb3cgVHJ1c3RFcnJvci5mcm9tQ29kZShuZXcgQ2VydGlmaWNhdGVOb3RBdXRob3JpemVkRXJyb3JDb2RlKHRoaXMuX2NhbmlzdGVySWQsIHN1Ym5ldElkKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHVibGljS2V5TG9va3VwID0gbG9va3VwUmVzdWx0VG9CdWZmZXIoY2VydC5sb29rdXBfcGF0aChbJ3N1Ym5ldCcsIHN1Ym5ldElkQnl0ZXMsICdwdWJsaWNfa2V5J10pKTtcbiAgICAgICAgaWYgKCFwdWJsaWNLZXlMb29rdXApIHtcbiAgICAgICAgICAgIHRocm93IFRydXN0RXJyb3IuZnJvbUNvZGUobmV3IE1pc3NpbmdMb29rdXBWYWx1ZUVycm9yQ29kZShgQ291bGQgbm90IGZpbmQgc3VibmV0IGtleSBmb3Igc3VibmV0IElEICR7c3VibmV0SWQudG9UZXh0KCl9YCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwdWJsaWNLZXlMb29rdXA7XG4gICAgfVxufVxuY29uc3QgREVSX1BSRUZJWCA9IGhleFRvQnl0ZXMoJzMwODE4MjMwMWQwNjBkMmIwNjAxMDQwMTgyZGM3YzA1MDMwMTAyMDEwNjBjMmIwNjAxMDQwMTgyZGM3YzA1MDMwMjAxMDM2MTAwJyk7XG5jb25zdCBLRVlfTEVOR1RIID0gOTY7XG5mdW5jdGlvbiBleHRyYWN0REVSKGJ1Zikge1xuICAgIGNvbnN0IGV4cGVjdGVkTGVuZ3RoID0gREVSX1BSRUZJWC5ieXRlTGVuZ3RoICsgS0VZX0xFTkdUSDtcbiAgICBpZiAoYnVmLmJ5dGVMZW5ndGggIT09IGV4cGVjdGVkTGVuZ3RoKSB7XG4gICAgICAgIHRocm93IFByb3RvY29sRXJyb3IuZnJvbUNvZGUobmV3IERlcktleUxlbmd0aE1pc21hdGNoRXJyb3JDb2RlKGV4cGVjdGVkTGVuZ3RoLCBidWYuYnl0ZUxlbmd0aCkpO1xuICAgIH1cbiAgICBjb25zdCBwcmVmaXggPSBidWYuc2xpY2UoMCwgREVSX1BSRUZJWC5ieXRlTGVuZ3RoKTtcbiAgICBpZiAoIXVpbnQ4RXF1YWxzKHByZWZpeCwgREVSX1BSRUZJWCkpIHtcbiAgICAgICAgdGhyb3cgUHJvdG9jb2xFcnJvci5mcm9tQ29kZShuZXcgRGVyUHJlZml4TWlzbWF0Y2hFcnJvckNvZGUoREVSX1BSRUZJWCwgcHJlZml4KSk7XG4gICAgfVxuICAgIHJldHVybiBidWYuc2xpY2UoREVSX1BSRUZJWC5ieXRlTGVuZ3RoKTtcbn1cbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbiB0byBjb25zdHJhaW4gdGhlIHR5cGUgb2YgYSBsb29rdXAgcmVzdWx0XG4gKiBAcGFyYW0gcmVzdWx0IHRoZSByZXN1bHQgb2YgYSBsb29rdXBcbiAqIEByZXR1cm5zIHtVaW50OEFycmF5IHwgdW5kZWZpbmVkfSB0aGUgdmFsdWUgaWYgdGhlIGxvb2t1cCB3YXMgZm91bmQsIGB1bmRlZmluZWRgIG90aGVyd2lzZVxuICovXG5leHBvcnQgZnVuY3Rpb24gbG9va3VwUmVzdWx0VG9CdWZmZXIocmVzdWx0KSB7XG4gICAgaWYgKHJlc3VsdC5zdGF0dXMgIT09IExvb2t1cFBhdGhTdGF0dXMuRm91bmQpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKHJlc3VsdC52YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC52YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbi8qKlxuICogQHBhcmFtIHQgVGhlIGhhc2ggdHJlZSB0byByZWNvbnN0cnVjdFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVjb25zdHJ1Y3QodCkge1xuICAgIHN3aXRjaCAodFswXSkge1xuICAgICAgICBjYXNlIE5vZGVUeXBlLkVtcHR5OlxuICAgICAgICAgICAgcmV0dXJuIHNoYTI1Nihkb21haW5fc2VwKCdpYy1oYXNodHJlZS1lbXB0eScpKTtcbiAgICAgICAgY2FzZSBOb2RlVHlwZS5QcnVuZWQ6XG4gICAgICAgICAgICByZXR1cm4gdFsxXTtcbiAgICAgICAgY2FzZSBOb2RlVHlwZS5MZWFmOlxuICAgICAgICAgICAgcmV0dXJuIHNoYTI1Nihjb25jYXRCeXRlcyhkb21haW5fc2VwKCdpYy1oYXNodHJlZS1sZWFmJyksIHRbMV0pKTtcbiAgICAgICAgY2FzZSBOb2RlVHlwZS5MYWJlbGVkOlxuICAgICAgICAgICAgcmV0dXJuIHNoYTI1Nihjb25jYXRCeXRlcyhkb21haW5fc2VwKCdpYy1oYXNodHJlZS1sYWJlbGVkJyksIHRbMV0sIGF3YWl0IHJlY29uc3RydWN0KHRbMl0pKSk7XG4gICAgICAgIGNhc2UgTm9kZVR5cGUuRm9yazpcbiAgICAgICAgICAgIHJldHVybiBzaGEyNTYoY29uY2F0Qnl0ZXMoZG9tYWluX3NlcCgnaWMtaGFzaHRyZWUtZm9yaycpLCBhd2FpdCByZWNvbnN0cnVjdCh0WzFdKSwgYXdhaXQgcmVjb25zdHJ1Y3QodFsyXSkpKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IFVOUkVBQ0hBQkxFX0VSUk9SO1xuICAgIH1cbn1cbi8qKlxuICogQ3JlYXRlcyBhIGRvbWFpbiBzZXBhcmF0b3IgZm9yIGhhc2hpbmcgYnkgZW5jb2RpbmcgdGhlIGlucHV0IHN0cmluZ1xuICogd2l0aCBpdHMgbGVuZ3RoIGFzIGEgcHJlZml4LlxuICogQHBhcmFtIHMgLSBUaGUgaW5wdXQgc3RyaW5nIHRvIGVuY29kZS5cbiAqIEByZXR1cm5zIEEgVWludDhBcnJheSBjb250YWluaW5nIHRoZSBlbmNvZGVkIGRvbWFpbiBzZXBhcmF0b3IuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkb21haW5fc2VwKHMpIHtcbiAgICBjb25zdCBsZW4gPSBuZXcgVWludDhBcnJheShbcy5sZW5ndGhdKTtcbiAgICBjb25zdCBzdHIgPSBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUocyk7XG4gICAgcmV0dXJuIGNvbmNhdEJ5dGVzKGxlbiwgc3RyKTtcbn1cbmZ1bmN0aW9uIHBhdGhUb0xhYmVsKHBhdGgpIHtcbiAgICByZXR1cm4gKHR5cGVvZiBwYXRoWzBdID09PSAnc3RyaW5nJyA/IHV0ZjhUb0J5dGVzKHBhdGhbMF0pIDogcGF0aFswXSk7XG59XG5leHBvcnQgdmFyIExvb2t1cFBhdGhTdGF0dXM7XG4oZnVuY3Rpb24gKExvb2t1cFBhdGhTdGF0dXMpIHtcbiAgICBMb29rdXBQYXRoU3RhdHVzW1wiVW5rbm93blwiXSA9IFwiVW5rbm93blwiO1xuICAgIExvb2t1cFBhdGhTdGF0dXNbXCJBYnNlbnRcIl0gPSBcIkFic2VudFwiO1xuICAgIExvb2t1cFBhdGhTdGF0dXNbXCJGb3VuZFwiXSA9IFwiRm91bmRcIjtcbiAgICBMb29rdXBQYXRoU3RhdHVzW1wiRXJyb3JcIl0gPSBcIkVycm9yXCI7XG59KShMb29rdXBQYXRoU3RhdHVzIHx8IChMb29rdXBQYXRoU3RhdHVzID0ge30pKTtcbmV4cG9ydCB2YXIgTG9va3VwU3VidHJlZVN0YXR1cztcbihmdW5jdGlvbiAoTG9va3VwU3VidHJlZVN0YXR1cykge1xuICAgIExvb2t1cFN1YnRyZWVTdGF0dXNbXCJBYnNlbnRcIl0gPSBcIkFic2VudFwiO1xuICAgIExvb2t1cFN1YnRyZWVTdGF0dXNbXCJVbmtub3duXCJdID0gXCJVbmtub3duXCI7XG4gICAgTG9va3VwU3VidHJlZVN0YXR1c1tcIkZvdW5kXCJdID0gXCJGb3VuZFwiO1xufSkoTG9va3VwU3VidHJlZVN0YXR1cyB8fCAoTG9va3VwU3VidHJlZVN0YXR1cyA9IHt9KSk7XG5leHBvcnQgdmFyIExvb2t1cExhYmVsU3RhdHVzO1xuKGZ1bmN0aW9uIChMb29rdXBMYWJlbFN0YXR1cykge1xuICAgIExvb2t1cExhYmVsU3RhdHVzW1wiQWJzZW50XCJdID0gXCJBYnNlbnRcIjtcbiAgICBMb29rdXBMYWJlbFN0YXR1c1tcIlVua25vd25cIl0gPSBcIlVua25vd25cIjtcbiAgICBMb29rdXBMYWJlbFN0YXR1c1tcIkZvdW5kXCJdID0gXCJGb3VuZFwiO1xuICAgIExvb2t1cExhYmVsU3RhdHVzW1wiTGVzc1wiXSA9IFwiTGVzc1wiO1xuICAgIExvb2t1cExhYmVsU3RhdHVzW1wiR3JlYXRlclwiXSA9IFwiR3JlYXRlclwiO1xufSkoTG9va3VwTGFiZWxTdGF0dXMgfHwgKExvb2t1cExhYmVsU3RhdHVzID0ge30pKTtcbi8qKlxuICogTG9va3VwIGEgcGF0aCBpbiBhIHRyZWUuIElmIHRoZSBwYXRoIGlzIGEgc3VidHJlZSwgdXNlIHtAbGluayBsb29rdXBfc3VidHJlZX0gaW5zdGVhZC5cbiAqIEBwYXJhbSBwYXRoIHRoZSBwYXRoIHRvIGxvb2sgdXBcbiAqIEBwYXJhbSB0cmVlIHRoZSB0cmVlIHRvIHNlYXJjaFxuICogQHJldHVybnMge0xvb2t1cFJlc3VsdH0gdGhlIHJlc3VsdCBvZiB0aGUgbG9va3VwXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsb29rdXBfcGF0aChwYXRoLCB0cmVlKSB7XG4gICAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHN3aXRjaCAodHJlZVswXSkge1xuICAgICAgICAgICAgY2FzZSBOb2RlVHlwZS5FbXB0eToge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1czogTG9va3VwUGF0aFN0YXR1cy5BYnNlbnQsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgTm9kZVR5cGUuTGVhZjoge1xuICAgICAgICAgICAgICAgIGlmICghdHJlZVsxXSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBVbmtub3duRXJyb3IuZnJvbUNvZGUobmV3IEhhc2hUcmVlRGVjb2RlRXJyb3JDb2RlKCdJbnZhbGlkIHRyZWUgc3RydWN0dXJlIGZvciBsZWFmJykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHJlZVsxXSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogTG9va3VwUGF0aFN0YXR1cy5Gb3VuZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0cmVlWzFdLnNsaWNlKHRyZWVbMV0uYnl0ZU9mZnNldCwgdHJlZVsxXS5ieXRlTGVuZ3RoICsgdHJlZVsxXS5ieXRlT2Zmc2V0KSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgVU5SRUFDSEFCTEVfRVJST1I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIE5vZGVUeXBlLlBydW5lZDoge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1czogTG9va3VwUGF0aFN0YXR1cy5Vbmtub3duLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIE5vZGVUeXBlLkxhYmVsZWQ6XG4gICAgICAgICAgICBjYXNlIE5vZGVUeXBlLkZvcms6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IExvb2t1cFBhdGhTdGF0dXMuRXJyb3IsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICB0aHJvdyBVTlJFQUNIQUJMRV9FUlJPUjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBsYWJlbCA9IHBhdGhUb0xhYmVsKHBhdGgpO1xuICAgIGNvbnN0IGxvb2t1cFJlc3VsdCA9IGZpbmRfbGFiZWwobGFiZWwsIHRyZWUpO1xuICAgIHN3aXRjaCAobG9va3VwUmVzdWx0LnN0YXR1cykge1xuICAgICAgICBjYXNlIExvb2t1cExhYmVsU3RhdHVzLkZvdW5kOiB7XG4gICAgICAgICAgICByZXR1cm4gbG9va3VwX3BhdGgocGF0aC5zbGljZSgxKSwgbG9va3VwUmVzdWx0LnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIExvb2t1cExhYmVsU3RhdHVzLkFic2VudDpcbiAgICAgICAgY2FzZSBMb29rdXBMYWJlbFN0YXR1cy5HcmVhdGVyOlxuICAgICAgICBjYXNlIExvb2t1cExhYmVsU3RhdHVzLkxlc3M6IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3RhdHVzOiBMb29rdXBQYXRoU3RhdHVzLkFic2VudCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBMb29rdXBMYWJlbFN0YXR1cy5Vbmtub3duOiB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN0YXR1czogTG9va3VwUGF0aFN0YXR1cy5Vbmtub3duLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICB0aHJvdyBVTlJFQUNIQUJMRV9FUlJPUjtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogTG9va3VwIGEgc3VidHJlZSBpbiBhIHRyZWUuXG4gKiBAcGFyYW0gcGF0aCB0aGUgcGF0aCB0byBsb29rIHVwXG4gKiBAcGFyYW0gdHJlZSB0aGUgdHJlZSB0byBzZWFyY2hcbiAqIEByZXR1cm5zIHtTdWJ0cmVlTG9va3VwUmVzdWx0fSB0aGUgcmVzdWx0IG9mIHRoZSBsb29rdXBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxvb2t1cF9zdWJ0cmVlKHBhdGgsIHRyZWUpIHtcbiAgICBpZiAocGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN0YXR1czogTG9va3VwU3VidHJlZVN0YXR1cy5Gb3VuZCxcbiAgICAgICAgICAgIHZhbHVlOiB0cmVlLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBsYWJlbCA9IHBhdGhUb0xhYmVsKHBhdGgpO1xuICAgIGNvbnN0IGxvb2t1cFJlc3VsdCA9IGZpbmRfbGFiZWwobGFiZWwsIHRyZWUpO1xuICAgIHN3aXRjaCAobG9va3VwUmVzdWx0LnN0YXR1cykge1xuICAgICAgICBjYXNlIExvb2t1cExhYmVsU3RhdHVzLkZvdW5kOiB7XG4gICAgICAgICAgICByZXR1cm4gbG9va3VwX3N1YnRyZWUocGF0aC5zbGljZSgxKSwgbG9va3VwUmVzdWx0LnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIExvb2t1cExhYmVsU3RhdHVzLlVua25vd246IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3RhdHVzOiBMb29rdXBTdWJ0cmVlU3RhdHVzLlVua25vd24sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgTG9va3VwTGFiZWxTdGF0dXMuQWJzZW50OlxuICAgICAgICBjYXNlIExvb2t1cExhYmVsU3RhdHVzLkdyZWF0ZXI6XG4gICAgICAgIGNhc2UgTG9va3VwTGFiZWxTdGF0dXMuTGVzczoge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdGF0dXM6IExvb2t1cFN1YnRyZWVTdGF0dXMuQWJzZW50LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICB0aHJvdyBVTlJFQUNIQUJMRV9FUlJPUjtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogSWYgdGhlIHRyZWUgaXMgYSBmb3JrLCBmbGF0dGVuIGl0IGludG8gYW4gYXJyYXkgb2YgdHJlZXNcbiAqIEBwYXJhbSB7SGFzaFRyZWV9IHQgdGhlIHRyZWUgdG8gZmxhdHRlblxuICogQHJldHVybnMge0hhc2hUcmVlW119IHRoZSBmbGF0dGVuZWQgdHJlZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZmxhdHRlbl9mb3Jrcyh0KSB7XG4gICAgc3dpdGNoICh0WzBdKSB7XG4gICAgICAgIGNhc2UgTm9kZVR5cGUuRW1wdHk6XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIGNhc2UgTm9kZVR5cGUuRm9yazpcbiAgICAgICAgICAgIHJldHVybiBmbGF0dGVuX2ZvcmtzKHRbMV0pLmNvbmNhdChmbGF0dGVuX2ZvcmtzKHRbMl0pKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBbdF07XG4gICAgfVxufVxuLyoqXG4gKiBGaW5kIGEgbGFiZWwgaW4gYSB0cmVlXG4gKiBAcGFyYW0gbGFiZWwgdGhlIGxhYmVsIHRvIGZpbmRcbiAqIEBwYXJhbSB0cmVlIHRoZSB0cmVlIHRvIHNlYXJjaFxuICogQHJldHVybnMge0xhYmVsTG9va3VwUmVzdWx0fSB0aGUgcmVzdWx0IG9mIHRoZSBsYWJlbCBsb29rdXBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpbmRfbGFiZWwobGFiZWwsIHRyZWUpIHtcbiAgICBzd2l0Y2ggKHRyZWVbMF0pIHtcbiAgICAgICAgLy8gaWYgd2UgaGF2ZSBhIGxhYmVsbGVkIG5vZGUsIGNvbXBhcmUgdGhlIG5vZGUncyBsYWJlbCB0byB0aGUgb25lIHdlIGFyZVxuICAgICAgICAvLyBsb29raW5nIGZvclxuICAgICAgICBjYXNlIE5vZGVUeXBlLkxhYmVsZWQ6XG4gICAgICAgICAgICAvLyBpZiB0aGUgbGFiZWwgd2UncmUgc2VhcmNoaW5nIGZvciBpcyBncmVhdGVyIHRoYW4gdGhpcyBub2RlJ3MgbGFiZWwsXG4gICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIGtlZXAgc2VhcmNoaW5nXG4gICAgICAgICAgICBpZiAoaXNCdWZmZXJHcmVhdGVyVGhhbihsYWJlbCwgdHJlZVsxXSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IExvb2t1cExhYmVsU3RhdHVzLkdyZWF0ZXIsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmIHRoZSBsYWJlbCB3ZSdyZSBzZWFyY2hpbmcgZm9yIGlzIGVxdWFsIHRoaXMgbm9kZSdzIGxhYmVsLCB3ZSBjYW5cbiAgICAgICAgICAgIC8vIHN0b3Agc2VhcmNoaW5nIGFuZCByZXR1cm4gdGhlIGZvdW5kIG5vZGVcbiAgICAgICAgICAgIGlmICh1aW50OEVxdWFscyhsYWJlbCwgdHJlZVsxXSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IExvb2t1cExhYmVsU3RhdHVzLkZvdW5kLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdHJlZVsyXSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgdGhlIGxhYmVsIHdlJ3JlIHNlYXJjaGluZyBmb3IgaXMgbm90IGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB0aGlzXG4gICAgICAgICAgICAvLyBub2RlJ3MgbGFiZWwsIHRoZW4gaXQncyBsZXNzIHRoYW4gdGhpcyBub2RlJ3MgbGFiZWwsIGFuZCB3ZSBjYW4gc3RvcFxuICAgICAgICAgICAgLy8gc2VhcmNoaW5nIGJlY2F1c2Ugd2UndmUgbG9va2VkIHRvbyBmYXJcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3RhdHVzOiBMb29rdXBMYWJlbFN0YXR1cy5MZXNzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgLy8gaWYgd2UgaGF2ZSBhIGZvcmsgbm9kZSwgd2UgbmVlZCB0byBzZWFyY2ggYm90aCBzaWRlcywgc3RhcnRpbmcgd2l0aCB0aGUgbGVmdFxuICAgICAgICBjYXNlIE5vZGVUeXBlLkZvcms6IHtcbiAgICAgICAgICAgIC8vIHNlYXJjaCBpbiB0aGUgbGVmdCBub2RlXG4gICAgICAgICAgICBjb25zdCBsZWZ0TG9va3VwUmVzdWx0ID0gZmluZF9sYWJlbChsYWJlbCwgdHJlZVsxXSk7XG4gICAgICAgICAgICBzd2l0Y2ggKGxlZnRMb29rdXBSZXN1bHQuc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIGxhYmVsIHdlJ3JlIHNlYXJjaGluZyBmb3IgaXMgZ3JlYXRlciB0aGFuIHRoZSBsZWZ0IG5vZGUgbG9va3VwLFxuICAgICAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gc2VhcmNoIHRoZSByaWdodCBub2RlXG4gICAgICAgICAgICAgICAgY2FzZSBMb29rdXBMYWJlbFN0YXR1cy5HcmVhdGVyOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJpZ2h0TG9va3VwUmVzdWx0ID0gZmluZF9sYWJlbChsYWJlbCwgdHJlZVsyXSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBsYWJlbCB3ZSdyZSBzZWFyY2hpbmcgZm9yIGlzIGxlc3MgdGhhbiB0aGUgcmlnaHQgbm9kZSBsb29rdXAsXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZW4gd2UgY2FuIHN0b3Agc2VhcmNoaW5nIGFuZCBzYXkgdGhhdCB0aGUgbGFiZWwgaXMgcHJvdmFibHkgQWJzZW50XG4gICAgICAgICAgICAgICAgICAgIGlmIChyaWdodExvb2t1cFJlc3VsdC5zdGF0dXMgPT09IExvb2t1cExhYmVsU3RhdHVzLkxlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBMb29rdXBMYWJlbFN0YXR1cy5BYnNlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBsYWJlbCB3ZSdyZSBzZWFyY2hpbmcgZm9yIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgLy8gbm9kZSBsb29rdXAsIHRoZW4gd2UgbGV0IHRoZSBjYWxsZXIgaGFuZGxlIGl0XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByaWdodExvb2t1cFJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIGxlZnQgbm9kZSByZXR1cm5zIGFuIHVuY2VydGFpbiByZXN1bHQsIHdlIG5lZWQgdG8gc2VhcmNoIHRoZVxuICAgICAgICAgICAgICAgIC8vIHJpZ2h0IG5vZGVcbiAgICAgICAgICAgICAgICBjYXNlIExvb2t1cExhYmVsU3RhdHVzLlVua25vd246IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmlnaHRMb29rdXBSZXN1bHQgPSBmaW5kX2xhYmVsKGxhYmVsLCB0cmVlWzJdKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIGxhYmVsIHdlJ3JlIHNlYXJjaGluZyBmb3IgaXMgbGVzcyB0aGFuIHRoZSByaWdodCBub2RlIGxvb2t1cCxcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlbiB3ZSBhbHNvIG5lZWQgdG8gcmV0dXJuIGFuIHVuY2VydGFpbiByZXN1bHRcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJpZ2h0TG9va3VwUmVzdWx0LnN0YXR1cyA9PT0gTG9va3VwTGFiZWxTdGF0dXMuTGVzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IExvb2t1cExhYmVsU3RhdHVzLlVua25vd24sXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBsYWJlbCB3ZSdyZSBzZWFyY2hpbmcgZm9yIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgLy8gbm9kZSBsb29rdXAsIHRoZW4gd2UgbGV0IHRoZSBjYWxsZXIgaGFuZGxlIGl0XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByaWdodExvb2t1cFJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIGxhYmVsIHdlJ3JlIHNlYXJjaGluZyBmb3IgaXMgbm90IGdyZWF0ZXIgdGhhbiB0aGUgbGVmdCBub2RlXG4gICAgICAgICAgICAgICAgLy8gbG9va3VwLCBvciB0aGUgcmVzdWx0IGlzIG5vdCB1bmNlcnRhaW4sIHdlIHN0b3Agc2VhcmNoaW5nIGFuZCByZXR1cm5cbiAgICAgICAgICAgICAgICAvLyB3aGF0ZXZlciB0aGUgcmVzdWx0IG9mIHRoZSBsZWZ0IG5vZGUgbG9va3VwIHdhcywgd2hpY2ggY2FuIGJlIGVpdGhlclxuICAgICAgICAgICAgICAgIC8vIEZvdW5kIG9yIEFic2VudFxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxlZnRMb29rdXBSZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHdlIGVuY291bnRlciBhIFBydW5lZCBub2RlLCB3ZSBjYW4ndCBrbm93IGZvciBjZXJ0YWluIGlmIHRoZSBsYWJlbFxuICAgICAgICAvLyB3ZSdyZSBzZWFyY2hpbmcgZm9yIGlzIHByZXNlbnQgb3Igbm90XG4gICAgICAgIGNhc2UgTm9kZVR5cGUuUHJ1bmVkOlxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdGF0dXM6IExvb2t1cExhYmVsU3RhdHVzLlVua25vd24sXG4gICAgICAgICAgICB9O1xuICAgICAgICAvLyBpZiB0aGUgY3VycmVudCBub2RlIGlzIEVtcHR5LCBvciBhIExlYWYsIHdlIGNhbiBzdG9wIHNlYXJjaGluZyBiZWNhdXNlXG4gICAgICAgIC8vIHdlIGtub3cgZm9yIHN1cmUgdGhhdCB0aGUgbGFiZWwgd2UncmUgc2VhcmNoaW5nIGZvciBpcyBub3QgcHJlc2VudFxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdGF0dXM6IExvb2t1cExhYmVsU3RhdHVzLkFic2VudCxcbiAgICAgICAgICAgIH07XG4gICAgfVxufVxuLyoqXG4gKiBDaGVjayBpZiBhIGNhbmlzdGVyIElEIGZhbGxzIHdpdGhpbiB0aGUgY2FuaXN0ZXIgcmFuZ2VzIG9mIGEgZ2l2ZW4gc3VibmV0XG4gKiBAcGFyYW0gcGFyYW1zIHRoZSBwYXJhbWV0ZXJzIHdpdGggd2hpY2ggdG8gY2hlY2sgdGhlIGNhbmlzdGVyIHJhbmdlc1xuICogQHBhcmFtIHBhcmFtcy5jYW5pc3RlcklkIHRoZSBjYW5pc3RlciBJRCB0byBjaGVja1xuICogQHBhcmFtIHBhcmFtcy5zdWJuZXRJZCB0aGUgc3VibmV0IElEIGZyb20gd2hpY2ggdG8gY2hlY2sgdGhlIGNhbmlzdGVyIHJhbmdlc1xuICogQHBhcmFtIHBhcmFtcy50cmVlIHRoZSBoYXNoIHRyZWUgaW4gd2hpY2ggdG8gbG9va3VwIHRoZSBzdWJuZXQncyBjYW5pc3RlciByYW5nZXNcbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIGNhbmlzdGVyIGlzIGluIHRoZSByYW5nZSwgYGZhbHNlYCBvdGhlcndpc2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrX2NhbmlzdGVyX3JhbmdlcyhwYXJhbXMpIHtcbiAgICBjb25zdCB7IGNhbmlzdGVySWQsIHN1Ym5ldElkLCB0cmVlIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgcmFuZ2VMb29rdXAgPSBsb29rdXBfcGF0aChbJ3N1Ym5ldCcsIHN1Ym5ldElkLnRvVWludDhBcnJheSgpLCAnY2FuaXN0ZXJfcmFuZ2VzJ10sIHRyZWUpO1xuICAgIGlmIChyYW5nZUxvb2t1cC5zdGF0dXMgIT09IExvb2t1cFBhdGhTdGF0dXMuRm91bmQpIHtcbiAgICAgICAgdGhyb3cgUHJvdG9jb2xFcnJvci5mcm9tQ29kZShuZXcgTG9va3VwRXJyb3JDb2RlKGBDb3VsZCBub3QgZmluZCBjYW5pc3RlciByYW5nZXMgZm9yIHN1Ym5ldCAke3N1Ym5ldElkLnRvVGV4dCgpfWAsIHJhbmdlTG9va3VwLnN0YXR1cykpO1xuICAgIH1cbiAgICBpZiAoIShyYW5nZUxvb2t1cC52YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB7XG4gICAgICAgIHRocm93IFByb3RvY29sRXJyb3IuZnJvbUNvZGUobmV3IE1hbGZvcm1lZExvb2t1cEZvdW5kVmFsdWVFcnJvckNvZGUoYENvdWxkIG5vdCBmaW5kIGNhbmlzdGVyIHJhbmdlcyBmb3Igc3VibmV0ICR7c3VibmV0SWQudG9UZXh0KCl9YCkpO1xuICAgIH1cbiAgICBjb25zdCByYW5nZXNfYXJyID0gY2Jvci5kZWNvZGUocmFuZ2VMb29rdXAudmFsdWUpO1xuICAgIGNvbnN0IHJhbmdlcyA9IHJhbmdlc19hcnIubWFwKHYgPT4gW1xuICAgICAgICBQcmluY2lwYWwuZnJvbVVpbnQ4QXJyYXkodlswXSksXG4gICAgICAgIFByaW5jaXBhbC5mcm9tVWludDhBcnJheSh2WzFdKSxcbiAgICBdKTtcbiAgICBjb25zdCBjYW5pc3RlckluUmFuZ2UgPSByYW5nZXMuc29tZShyID0+IHJbMF0ubHRFcShjYW5pc3RlcklkKSAmJiByWzFdLmd0RXEoY2FuaXN0ZXJJZCkpO1xuICAgIHJldHVybiBjYW5pc3RlckluUmFuZ2U7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jZXJ0aWZpY2F0ZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/certificate.js\n");

/***/ }),

/***/ "(ssr)/../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/constants.js":
/*!******************************************************************************!*\
  !*** ../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/constants.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS: () => (/* binding */ DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS),\n/* harmony export */   IC_REQUEST_AUTH_DELEGATION_DOMAIN_SEPARATOR: () => (/* binding */ IC_REQUEST_AUTH_DELEGATION_DOMAIN_SEPARATOR),\n/* harmony export */   IC_REQUEST_DOMAIN_SEPARATOR: () => (/* binding */ IC_REQUEST_DOMAIN_SEPARATOR),\n/* harmony export */   IC_RESPONSE_DOMAIN_SEPARATOR: () => (/* binding */ IC_RESPONSE_DOMAIN_SEPARATOR)\n/* harmony export */ });\n// Default delta for ingress expiry is 5 minutes.\nconst DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS = 5 * 60 * 1000;\n/**\n * The `\\x0Aic-request` domain separator used in the signature of IC requests.\n */\nconst IC_REQUEST_DOMAIN_SEPARATOR = new TextEncoder().encode('\\x0Aic-request');\n/**\n * The `\\x0Bic-response` domain separator used in the signature of IC responses.\n */\nconst IC_RESPONSE_DOMAIN_SEPARATOR = new TextEncoder().encode('\\x0Bic-response');\n/**\n * The `\\x1Aic-request-auth-delegation` domain separator used in the signature of delegations.\n */\nconst IC_REQUEST_AUTH_DELEGATION_DOMAIN_SEPARATOR = new TextEncoder().encode('\\x1Aic-request-auth-delegation');\n//# sourceMappingURL=constants.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vcGFja2FnZXMvc2RrLWpzL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL2NvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGlxdWJlL29wcy1jb25zb2xlLy4uLy4uL3BhY2thZ2VzL3Nkay1qcy9ub2RlX21vZHVsZXMvQGRmaW5pdHkvYWdlbnQvbGliL2VzbS9jb25zdGFudHMuanM/YzdkZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBEZWZhdWx0IGRlbHRhIGZvciBpbmdyZXNzIGV4cGlyeSBpcyA1IG1pbnV0ZXMuXG5leHBvcnQgY29uc3QgREVGQVVMVF9JTkdSRVNTX0VYUElSWV9ERUxUQV9JTl9NU0VDUyA9IDUgKiA2MCAqIDEwMDA7XG4vKipcbiAqIFRoZSBgXFx4MEFpYy1yZXF1ZXN0YCBkb21haW4gc2VwYXJhdG9yIHVzZWQgaW4gdGhlIHNpZ25hdHVyZSBvZiBJQyByZXF1ZXN0cy5cbiAqL1xuZXhwb3J0IGNvbnN0IElDX1JFUVVFU1RfRE9NQUlOX1NFUEFSQVRPUiA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZSgnXFx4MEFpYy1yZXF1ZXN0Jyk7XG4vKipcbiAqIFRoZSBgXFx4MEJpYy1yZXNwb25zZWAgZG9tYWluIHNlcGFyYXRvciB1c2VkIGluIHRoZSBzaWduYXR1cmUgb2YgSUMgcmVzcG9uc2VzLlxuICovXG5leHBvcnQgY29uc3QgSUNfUkVTUE9OU0VfRE9NQUlOX1NFUEFSQVRPUiA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZSgnXFx4MEJpYy1yZXNwb25zZScpO1xuLyoqXG4gKiBUaGUgYFxceDFBaWMtcmVxdWVzdC1hdXRoLWRlbGVnYXRpb25gIGRvbWFpbiBzZXBhcmF0b3IgdXNlZCBpbiB0aGUgc2lnbmF0dXJlIG9mIGRlbGVnYXRpb25zLlxuICovXG5leHBvcnQgY29uc3QgSUNfUkVRVUVTVF9BVVRIX0RFTEVHQVRJT05fRE9NQUlOX1NFUEFSQVRPUiA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZSgnXFx4MUFpYy1yZXF1ZXN0LWF1dGgtZGVsZWdhdGlvbicpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uc3RhbnRzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/constants.js\n");

/***/ }),

/***/ "(ssr)/../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/der.js":
/*!************************************************************************!*\
  !*** ../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/der.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BLS12_381_G2_OID: () => (/* binding */ BLS12_381_G2_OID),\n/* harmony export */   DER_COSE_OID: () => (/* binding */ DER_COSE_OID),\n/* harmony export */   ED25519_OID: () => (/* binding */ ED25519_OID),\n/* harmony export */   SECP256K1_OID: () => (/* binding */ SECP256K1_OID),\n/* harmony export */   decodeLen: () => (/* binding */ decodeLen),\n/* harmony export */   decodeLenBytes: () => (/* binding */ decodeLenBytes),\n/* harmony export */   encodeLen: () => (/* binding */ encodeLen),\n/* harmony export */   encodeLenBytes: () => (/* binding */ encodeLenBytes),\n/* harmony export */   unwrapDER: () => (/* binding */ unwrapDER),\n/* harmony export */   wrapDER: () => (/* binding */ wrapDER)\n/* harmony export */ });\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.js */ \"(ssr)/../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/errors.js\");\n/* harmony import */ var _utils_buffer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/buffer.js */ \"(ssr)/../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/utils/buffer.js\");\n\n\nconst encodeLenBytes = (len) => {\n    if (len <= 0x7f) {\n        return 1;\n    }\n    else if (len <= 0xff) {\n        return 2;\n    }\n    else if (len <= 0xffff) {\n        return 3;\n    }\n    else if (len <= 0xffffff) {\n        return 4;\n    }\n    else {\n        throw _errors_js__WEBPACK_IMPORTED_MODULE_0__.InputError.fromCode(new _errors_js__WEBPACK_IMPORTED_MODULE_0__.DerEncodeErrorCode('Length too long (> 4 bytes)'));\n    }\n};\nconst encodeLen = (buf, offset, len) => {\n    if (len <= 0x7f) {\n        buf[offset] = len;\n        return 1;\n    }\n    else if (len <= 0xff) {\n        buf[offset] = 0x81;\n        buf[offset + 1] = len;\n        return 2;\n    }\n    else if (len <= 0xffff) {\n        buf[offset] = 0x82;\n        buf[offset + 1] = len >> 8;\n        buf[offset + 2] = len;\n        return 3;\n    }\n    else if (len <= 0xffffff) {\n        buf[offset] = 0x83;\n        buf[offset + 1] = len >> 16;\n        buf[offset + 2] = len >> 8;\n        buf[offset + 3] = len;\n        return 4;\n    }\n    else {\n        throw _errors_js__WEBPACK_IMPORTED_MODULE_0__.InputError.fromCode(new _errors_js__WEBPACK_IMPORTED_MODULE_0__.DerEncodeErrorCode('Length too long (> 4 bytes)'));\n    }\n};\nconst decodeLenBytes = (buf, offset) => {\n    if (buf[offset] < 0x80)\n        return 1;\n    if (buf[offset] === 0x80)\n        throw _errors_js__WEBPACK_IMPORTED_MODULE_0__.InputError.fromCode(new _errors_js__WEBPACK_IMPORTED_MODULE_0__.DerDecodeErrorCode('Invalid length 0'));\n    if (buf[offset] === 0x81)\n        return 2;\n    if (buf[offset] === 0x82)\n        return 3;\n    if (buf[offset] === 0x83)\n        return 4;\n    throw _errors_js__WEBPACK_IMPORTED_MODULE_0__.InputError.fromCode(new _errors_js__WEBPACK_IMPORTED_MODULE_0__.DerDecodeErrorCode('Length too long (> 4 bytes)'));\n};\nconst decodeLen = (buf, offset) => {\n    const lenBytes = decodeLenBytes(buf, offset);\n    if (lenBytes === 1)\n        return buf[offset];\n    else if (lenBytes === 2)\n        return buf[offset + 1];\n    else if (lenBytes === 3)\n        return (buf[offset + 1] << 8) + buf[offset + 2];\n    else if (lenBytes === 4)\n        return (buf[offset + 1] << 16) + (buf[offset + 2] << 8) + buf[offset + 3];\n    throw _errors_js__WEBPACK_IMPORTED_MODULE_0__.InputError.fromCode(new _errors_js__WEBPACK_IMPORTED_MODULE_0__.DerDecodeErrorCode('Length too long (> 4 bytes)'));\n};\n/**\n * A DER encoded `SEQUENCE(OID)` for DER-encoded-COSE\n */\nconst DER_COSE_OID = Uint8Array.from([\n    ...[0x30, 0x0c], // SEQUENCE\n    ...[0x06, 0x0a], // OID with 10 bytes\n    ...[0x2b, 0x06, 0x01, 0x04, 0x01, 0x83, 0xb8, 0x43, 0x01, 0x01], // DER encoded COSE\n]);\n/**\n * A DER encoded `SEQUENCE(OID)` for the Ed25519 algorithm\n */\nconst ED25519_OID = Uint8Array.from([\n    ...[0x30, 0x05], // SEQUENCE\n    ...[0x06, 0x03], // OID with 3 bytes\n    ...[0x2b, 0x65, 0x70], // id-Ed25519 OID\n]);\n/**\n * A DER encoded `SEQUENCE(OID)` for secp256k1 with the ECDSA algorithm\n */\nconst SECP256K1_OID = Uint8Array.from([\n    ...[0x30, 0x10], // SEQUENCE\n    ...[0x06, 0x07], // OID with 7 bytes\n    ...[0x2a, 0x86, 0x48, 0xce, 0x3d, 0x02, 0x01], // OID ECDSA\n    ...[0x06, 0x05], // OID with 5 bytes\n    ...[0x2b, 0x81, 0x04, 0x00, 0x0a], // OID secp256k1\n]);\nconst BLS12_381_G2_OID = Uint8Array.from([\n    ...[0x30, 0x1d], // SEQUENCE, length 29 bytes\n    // Algorithm OID\n    ...[0x06, 0x0d],\n    ...[0x2b, 0x06, 0x01, 0x04, 0x01, 0x82, 0xdc, 0x7c, 0x05, 0x03, 0x01, 0x02, 0x01],\n    // Curve OID\n    ...[0x06, 0x0c],\n    ...[0x2b, 0x06, 0x01, 0x04, 0x01, 0x82, 0xdc, 0x7c, 0x05, 0x03, 0x02, 0x01],\n]);\n/**\n * Wraps the given `payload` in a DER encoding tagged with the given encoded `oid` like so:\n * `SEQUENCE(oid, BITSTRING(payload))`\n * @param payload The payload to encode as the bit string\n * @param oid The DER encoded (and SEQUENCE wrapped!) OID to tag the payload with\n */\nfunction wrapDER(payload, oid) {\n    // The Bit String header needs to include the unused bit count byte in its length\n    const bitStringHeaderLength = 2 + encodeLenBytes(payload.byteLength + 1);\n    const len = oid.byteLength + bitStringHeaderLength + payload.byteLength;\n    let offset = 0;\n    const buf = new Uint8Array(1 + encodeLenBytes(len) + len);\n    // Sequence\n    buf[offset++] = 0x30;\n    // Sequence Length\n    offset += encodeLen(buf, offset, len);\n    // OID\n    buf.set(oid, offset);\n    offset += oid.byteLength;\n    // Bit String Header\n    buf[offset++] = 0x03;\n    offset += encodeLen(buf, offset, payload.byteLength + 1);\n    // 0 padding\n    buf[offset++] = 0x00;\n    buf.set(new Uint8Array(payload), offset);\n    return buf;\n}\n/**\n * Extracts a payload from the given `derEncoded` data, and checks that it was tagged with the given `oid`.\n *\n * `derEncoded = SEQUENCE(oid, BITSTRING(payload))`\n * @param derEncoded The DER encoded and tagged data\n * @param oid The DER encoded (and SEQUENCE wrapped!) expected OID\n * @returns The unwrapped payload\n */\nconst unwrapDER = (derEncoded, oid) => {\n    let offset = 0;\n    const expect = (n, msg) => {\n        if (buf[offset++] !== n) {\n            throw _errors_js__WEBPACK_IMPORTED_MODULE_0__.InputError.fromCode(new _errors_js__WEBPACK_IMPORTED_MODULE_0__.DerDecodeErrorCode(`Expected ${msg} at offset ${offset}`));\n        }\n    };\n    const buf = new Uint8Array(derEncoded);\n    expect(0x30, 'sequence');\n    offset += decodeLenBytes(buf, offset);\n    if (!(0,_utils_buffer_js__WEBPACK_IMPORTED_MODULE_1__.uint8Equals)(buf.slice(offset, offset + oid.byteLength), oid)) {\n        throw _errors_js__WEBPACK_IMPORTED_MODULE_0__.InputError.fromCode(new _errors_js__WEBPACK_IMPORTED_MODULE_0__.DerDecodeErrorCode('Not the expected OID.'));\n    }\n    offset += oid.byteLength;\n    expect(0x03, 'bit string');\n    const payloadLen = decodeLen(buf, offset) - 1; // Subtracting 1 to account for the 0 padding\n    offset += decodeLenBytes(buf, offset);\n    expect(0x00, '0 padding');\n    const result = buf.slice(offset);\n    if (payloadLen !== result.length) {\n        throw _errors_js__WEBPACK_IMPORTED_MODULE_0__.InputError.fromCode(new _errors_js__WEBPACK_IMPORTED_MODULE_0__.DerDecodeLengthMismatchErrorCode(payloadLen, result.length));\n    }\n    return result;\n};\n//# sourceMappingURL=der.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vcGFja2FnZXMvc2RrLWpzL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL2Rlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBb0g7QUFDcEU7QUFDekM7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsa0RBQVUsY0FBYywwREFBa0I7QUFDeEQ7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsa0RBQVUsY0FBYywwREFBa0I7QUFDeEQ7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsY0FBYyxrREFBVSxjQUFjLDBEQUFrQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGtEQUFVLGNBQWMsMERBQWtCO0FBQ3BEO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGtEQUFVLGNBQWMsMERBQWtCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrREFBVSxjQUFjLDBEQUFrQixhQUFhLEtBQUssWUFBWSxPQUFPO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDZEQUFXO0FBQ3BCLGNBQWMsa0RBQVUsY0FBYywwREFBa0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxrREFBVSxjQUFjLHdFQUFnQztBQUN0RTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BpcXViZS9vcHMtY29uc29sZS8uLi8uLi9wYWNrYWdlcy9zZGstanMvbm9kZV9tb2R1bGVzL0BkZmluaXR5L2FnZW50L2xpYi9lc20vZGVyLmpzPzRkMDYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRGVyRGVjb2RlRXJyb3JDb2RlLCBEZXJEZWNvZGVMZW5ndGhNaXNtYXRjaEVycm9yQ29kZSwgRGVyRW5jb2RlRXJyb3JDb2RlLCBJbnB1dEVycm9yLCB9IGZyb20gXCIuL2Vycm9ycy5qc1wiO1xuaW1wb3J0IHsgdWludDhFcXVhbHMgfSBmcm9tIFwiLi91dGlscy9idWZmZXIuanNcIjtcbmV4cG9ydCBjb25zdCBlbmNvZGVMZW5CeXRlcyA9IChsZW4pID0+IHtcbiAgICBpZiAobGVuIDw9IDB4N2YpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIGVsc2UgaWYgKGxlbiA8PSAweGZmKSB7XG4gICAgICAgIHJldHVybiAyO1xuICAgIH1cbiAgICBlbHNlIGlmIChsZW4gPD0gMHhmZmZmKSB7XG4gICAgICAgIHJldHVybiAzO1xuICAgIH1cbiAgICBlbHNlIGlmIChsZW4gPD0gMHhmZmZmZmYpIHtcbiAgICAgICAgcmV0dXJuIDQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBJbnB1dEVycm9yLmZyb21Db2RlKG5ldyBEZXJFbmNvZGVFcnJvckNvZGUoJ0xlbmd0aCB0b28gbG9uZyAoPiA0IGJ5dGVzKScpKTtcbiAgICB9XG59O1xuZXhwb3J0IGNvbnN0IGVuY29kZUxlbiA9IChidWYsIG9mZnNldCwgbGVuKSA9PiB7XG4gICAgaWYgKGxlbiA8PSAweDdmKSB7XG4gICAgICAgIGJ1ZltvZmZzZXRdID0gbGVuO1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgZWxzZSBpZiAobGVuIDw9IDB4ZmYpIHtcbiAgICAgICAgYnVmW29mZnNldF0gPSAweDgxO1xuICAgICAgICBidWZbb2Zmc2V0ICsgMV0gPSBsZW47XG4gICAgICAgIHJldHVybiAyO1xuICAgIH1cbiAgICBlbHNlIGlmIChsZW4gPD0gMHhmZmZmKSB7XG4gICAgICAgIGJ1ZltvZmZzZXRdID0gMHg4MjtcbiAgICAgICAgYnVmW29mZnNldCArIDFdID0gbGVuID4+IDg7XG4gICAgICAgIGJ1ZltvZmZzZXQgKyAyXSA9IGxlbjtcbiAgICAgICAgcmV0dXJuIDM7XG4gICAgfVxuICAgIGVsc2UgaWYgKGxlbiA8PSAweGZmZmZmZikge1xuICAgICAgICBidWZbb2Zmc2V0XSA9IDB4ODM7XG4gICAgICAgIGJ1ZltvZmZzZXQgKyAxXSA9IGxlbiA+PiAxNjtcbiAgICAgICAgYnVmW29mZnNldCArIDJdID0gbGVuID4+IDg7XG4gICAgICAgIGJ1ZltvZmZzZXQgKyAzXSA9IGxlbjtcbiAgICAgICAgcmV0dXJuIDQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBJbnB1dEVycm9yLmZyb21Db2RlKG5ldyBEZXJFbmNvZGVFcnJvckNvZGUoJ0xlbmd0aCB0b28gbG9uZyAoPiA0IGJ5dGVzKScpKTtcbiAgICB9XG59O1xuZXhwb3J0IGNvbnN0IGRlY29kZUxlbkJ5dGVzID0gKGJ1Ziwgb2Zmc2V0KSA9PiB7XG4gICAgaWYgKGJ1ZltvZmZzZXRdIDwgMHg4MClcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgaWYgKGJ1ZltvZmZzZXRdID09PSAweDgwKVxuICAgICAgICB0aHJvdyBJbnB1dEVycm9yLmZyb21Db2RlKG5ldyBEZXJEZWNvZGVFcnJvckNvZGUoJ0ludmFsaWQgbGVuZ3RoIDAnKSk7XG4gICAgaWYgKGJ1ZltvZmZzZXRdID09PSAweDgxKVxuICAgICAgICByZXR1cm4gMjtcbiAgICBpZiAoYnVmW29mZnNldF0gPT09IDB4ODIpXG4gICAgICAgIHJldHVybiAzO1xuICAgIGlmIChidWZbb2Zmc2V0XSA9PT0gMHg4MylcbiAgICAgICAgcmV0dXJuIDQ7XG4gICAgdGhyb3cgSW5wdXRFcnJvci5mcm9tQ29kZShuZXcgRGVyRGVjb2RlRXJyb3JDb2RlKCdMZW5ndGggdG9vIGxvbmcgKD4gNCBieXRlcyknKSk7XG59O1xuZXhwb3J0IGNvbnN0IGRlY29kZUxlbiA9IChidWYsIG9mZnNldCkgPT4ge1xuICAgIGNvbnN0IGxlbkJ5dGVzID0gZGVjb2RlTGVuQnl0ZXMoYnVmLCBvZmZzZXQpO1xuICAgIGlmIChsZW5CeXRlcyA9PT0gMSlcbiAgICAgICAgcmV0dXJuIGJ1ZltvZmZzZXRdO1xuICAgIGVsc2UgaWYgKGxlbkJ5dGVzID09PSAyKVxuICAgICAgICByZXR1cm4gYnVmW29mZnNldCArIDFdO1xuICAgIGVsc2UgaWYgKGxlbkJ5dGVzID09PSAzKVxuICAgICAgICByZXR1cm4gKGJ1ZltvZmZzZXQgKyAxXSA8PCA4KSArIGJ1ZltvZmZzZXQgKyAyXTtcbiAgICBlbHNlIGlmIChsZW5CeXRlcyA9PT0gNClcbiAgICAgICAgcmV0dXJuIChidWZbb2Zmc2V0ICsgMV0gPDwgMTYpICsgKGJ1ZltvZmZzZXQgKyAyXSA8PCA4KSArIGJ1ZltvZmZzZXQgKyAzXTtcbiAgICB0aHJvdyBJbnB1dEVycm9yLmZyb21Db2RlKG5ldyBEZXJEZWNvZGVFcnJvckNvZGUoJ0xlbmd0aCB0b28gbG9uZyAoPiA0IGJ5dGVzKScpKTtcbn07XG4vKipcbiAqIEEgREVSIGVuY29kZWQgYFNFUVVFTkNFKE9JRClgIGZvciBERVItZW5jb2RlZC1DT1NFXG4gKi9cbmV4cG9ydCBjb25zdCBERVJfQ09TRV9PSUQgPSBVaW50OEFycmF5LmZyb20oW1xuICAgIC4uLlsweDMwLCAweDBjXSwgLy8gU0VRVUVOQ0VcbiAgICAuLi5bMHgwNiwgMHgwYV0sIC8vIE9JRCB3aXRoIDEwIGJ5dGVzXG4gICAgLi4uWzB4MmIsIDB4MDYsIDB4MDEsIDB4MDQsIDB4MDEsIDB4ODMsIDB4YjgsIDB4NDMsIDB4MDEsIDB4MDFdLCAvLyBERVIgZW5jb2RlZCBDT1NFXG5dKTtcbi8qKlxuICogQSBERVIgZW5jb2RlZCBgU0VRVUVOQ0UoT0lEKWAgZm9yIHRoZSBFZDI1NTE5IGFsZ29yaXRobVxuICovXG5leHBvcnQgY29uc3QgRUQyNTUxOV9PSUQgPSBVaW50OEFycmF5LmZyb20oW1xuICAgIC4uLlsweDMwLCAweDA1XSwgLy8gU0VRVUVOQ0VcbiAgICAuLi5bMHgwNiwgMHgwM10sIC8vIE9JRCB3aXRoIDMgYnl0ZXNcbiAgICAuLi5bMHgyYiwgMHg2NSwgMHg3MF0sIC8vIGlkLUVkMjU1MTkgT0lEXG5dKTtcbi8qKlxuICogQSBERVIgZW5jb2RlZCBgU0VRVUVOQ0UoT0lEKWAgZm9yIHNlY3AyNTZrMSB3aXRoIHRoZSBFQ0RTQSBhbGdvcml0aG1cbiAqL1xuZXhwb3J0IGNvbnN0IFNFQ1AyNTZLMV9PSUQgPSBVaW50OEFycmF5LmZyb20oW1xuICAgIC4uLlsweDMwLCAweDEwXSwgLy8gU0VRVUVOQ0VcbiAgICAuLi5bMHgwNiwgMHgwN10sIC8vIE9JRCB3aXRoIDcgYnl0ZXNcbiAgICAuLi5bMHgyYSwgMHg4NiwgMHg0OCwgMHhjZSwgMHgzZCwgMHgwMiwgMHgwMV0sIC8vIE9JRCBFQ0RTQVxuICAgIC4uLlsweDA2LCAweDA1XSwgLy8gT0lEIHdpdGggNSBieXRlc1xuICAgIC4uLlsweDJiLCAweDgxLCAweDA0LCAweDAwLCAweDBhXSwgLy8gT0lEIHNlY3AyNTZrMVxuXSk7XG5leHBvcnQgY29uc3QgQkxTMTJfMzgxX0cyX09JRCA9IFVpbnQ4QXJyYXkuZnJvbShbXG4gICAgLi4uWzB4MzAsIDB4MWRdLCAvLyBTRVFVRU5DRSwgbGVuZ3RoIDI5IGJ5dGVzXG4gICAgLy8gQWxnb3JpdGhtIE9JRFxuICAgIC4uLlsweDA2LCAweDBkXSxcbiAgICAuLi5bMHgyYiwgMHgwNiwgMHgwMSwgMHgwNCwgMHgwMSwgMHg4MiwgMHhkYywgMHg3YywgMHgwNSwgMHgwMywgMHgwMSwgMHgwMiwgMHgwMV0sXG4gICAgLy8gQ3VydmUgT0lEXG4gICAgLi4uWzB4MDYsIDB4MGNdLFxuICAgIC4uLlsweDJiLCAweDA2LCAweDAxLCAweDA0LCAweDAxLCAweDgyLCAweGRjLCAweDdjLCAweDA1LCAweDAzLCAweDAyLCAweDAxXSxcbl0pO1xuLyoqXG4gKiBXcmFwcyB0aGUgZ2l2ZW4gYHBheWxvYWRgIGluIGEgREVSIGVuY29kaW5nIHRhZ2dlZCB3aXRoIHRoZSBnaXZlbiBlbmNvZGVkIGBvaWRgIGxpa2Ugc286XG4gKiBgU0VRVUVOQ0Uob2lkLCBCSVRTVFJJTkcocGF5bG9hZCkpYFxuICogQHBhcmFtIHBheWxvYWQgVGhlIHBheWxvYWQgdG8gZW5jb2RlIGFzIHRoZSBiaXQgc3RyaW5nXG4gKiBAcGFyYW0gb2lkIFRoZSBERVIgZW5jb2RlZCAoYW5kIFNFUVVFTkNFIHdyYXBwZWQhKSBPSUQgdG8gdGFnIHRoZSBwYXlsb2FkIHdpdGhcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdyYXBERVIocGF5bG9hZCwgb2lkKSB7XG4gICAgLy8gVGhlIEJpdCBTdHJpbmcgaGVhZGVyIG5lZWRzIHRvIGluY2x1ZGUgdGhlIHVudXNlZCBiaXQgY291bnQgYnl0ZSBpbiBpdHMgbGVuZ3RoXG4gICAgY29uc3QgYml0U3RyaW5nSGVhZGVyTGVuZ3RoID0gMiArIGVuY29kZUxlbkJ5dGVzKHBheWxvYWQuYnl0ZUxlbmd0aCArIDEpO1xuICAgIGNvbnN0IGxlbiA9IG9pZC5ieXRlTGVuZ3RoICsgYml0U3RyaW5nSGVhZGVyTGVuZ3RoICsgcGF5bG9hZC5ieXRlTGVuZ3RoO1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIGNvbnN0IGJ1ZiA9IG5ldyBVaW50OEFycmF5KDEgKyBlbmNvZGVMZW5CeXRlcyhsZW4pICsgbGVuKTtcbiAgICAvLyBTZXF1ZW5jZVxuICAgIGJ1ZltvZmZzZXQrK10gPSAweDMwO1xuICAgIC8vIFNlcXVlbmNlIExlbmd0aFxuICAgIG9mZnNldCArPSBlbmNvZGVMZW4oYnVmLCBvZmZzZXQsIGxlbik7XG4gICAgLy8gT0lEXG4gICAgYnVmLnNldChvaWQsIG9mZnNldCk7XG4gICAgb2Zmc2V0ICs9IG9pZC5ieXRlTGVuZ3RoO1xuICAgIC8vIEJpdCBTdHJpbmcgSGVhZGVyXG4gICAgYnVmW29mZnNldCsrXSA9IDB4MDM7XG4gICAgb2Zmc2V0ICs9IGVuY29kZUxlbihidWYsIG9mZnNldCwgcGF5bG9hZC5ieXRlTGVuZ3RoICsgMSk7XG4gICAgLy8gMCBwYWRkaW5nXG4gICAgYnVmW29mZnNldCsrXSA9IDB4MDA7XG4gICAgYnVmLnNldChuZXcgVWludDhBcnJheShwYXlsb2FkKSwgb2Zmc2V0KTtcbiAgICByZXR1cm4gYnVmO1xufVxuLyoqXG4gKiBFeHRyYWN0cyBhIHBheWxvYWQgZnJvbSB0aGUgZ2l2ZW4gYGRlckVuY29kZWRgIGRhdGEsIGFuZCBjaGVja3MgdGhhdCBpdCB3YXMgdGFnZ2VkIHdpdGggdGhlIGdpdmVuIGBvaWRgLlxuICpcbiAqIGBkZXJFbmNvZGVkID0gU0VRVUVOQ0Uob2lkLCBCSVRTVFJJTkcocGF5bG9hZCkpYFxuICogQHBhcmFtIGRlckVuY29kZWQgVGhlIERFUiBlbmNvZGVkIGFuZCB0YWdnZWQgZGF0YVxuICogQHBhcmFtIG9pZCBUaGUgREVSIGVuY29kZWQgKGFuZCBTRVFVRU5DRSB3cmFwcGVkISkgZXhwZWN0ZWQgT0lEXG4gKiBAcmV0dXJucyBUaGUgdW53cmFwcGVkIHBheWxvYWRcbiAqL1xuZXhwb3J0IGNvbnN0IHVud3JhcERFUiA9IChkZXJFbmNvZGVkLCBvaWQpID0+IHtcbiAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICBjb25zdCBleHBlY3QgPSAobiwgbXNnKSA9PiB7XG4gICAgICAgIGlmIChidWZbb2Zmc2V0KytdICE9PSBuKSB7XG4gICAgICAgICAgICB0aHJvdyBJbnB1dEVycm9yLmZyb21Db2RlKG5ldyBEZXJEZWNvZGVFcnJvckNvZGUoYEV4cGVjdGVkICR7bXNnfSBhdCBvZmZzZXQgJHtvZmZzZXR9YCkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBidWYgPSBuZXcgVWludDhBcnJheShkZXJFbmNvZGVkKTtcbiAgICBleHBlY3QoMHgzMCwgJ3NlcXVlbmNlJyk7XG4gICAgb2Zmc2V0ICs9IGRlY29kZUxlbkJ5dGVzKGJ1Ziwgb2Zmc2V0KTtcbiAgICBpZiAoIXVpbnQ4RXF1YWxzKGJ1Zi5zbGljZShvZmZzZXQsIG9mZnNldCArIG9pZC5ieXRlTGVuZ3RoKSwgb2lkKSkge1xuICAgICAgICB0aHJvdyBJbnB1dEVycm9yLmZyb21Db2RlKG5ldyBEZXJEZWNvZGVFcnJvckNvZGUoJ05vdCB0aGUgZXhwZWN0ZWQgT0lELicpKTtcbiAgICB9XG4gICAgb2Zmc2V0ICs9IG9pZC5ieXRlTGVuZ3RoO1xuICAgIGV4cGVjdCgweDAzLCAnYml0IHN0cmluZycpO1xuICAgIGNvbnN0IHBheWxvYWRMZW4gPSBkZWNvZGVMZW4oYnVmLCBvZmZzZXQpIC0gMTsgLy8gU3VidHJhY3RpbmcgMSB0byBhY2NvdW50IGZvciB0aGUgMCBwYWRkaW5nXG4gICAgb2Zmc2V0ICs9IGRlY29kZUxlbkJ5dGVzKGJ1Ziwgb2Zmc2V0KTtcbiAgICBleHBlY3QoMHgwMCwgJzAgcGFkZGluZycpO1xuICAgIGNvbnN0IHJlc3VsdCA9IGJ1Zi5zbGljZShvZmZzZXQpO1xuICAgIGlmIChwYXlsb2FkTGVuICE9PSByZXN1bHQubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IElucHV0RXJyb3IuZnJvbUNvZGUobmV3IERlckRlY29kZUxlbmd0aE1pc21hdGNoRXJyb3JDb2RlKHBheWxvYWRMZW4sIHJlc3VsdC5sZW5ndGgpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/der.js\n");

/***/ }),

/***/ "(ssr)/../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/errors.js":
/*!***************************************************************************!*\
  !*** ../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/errors.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AgentError: () => (/* binding */ AgentError),\n/* harmony export */   CborDecodeErrorCode: () => (/* binding */ CborDecodeErrorCode),\n/* harmony export */   CborEncodeErrorCode: () => (/* binding */ CborEncodeErrorCode),\n/* harmony export */   CertificateHasTooManyDelegationsErrorCode: () => (/* binding */ CertificateHasTooManyDelegationsErrorCode),\n/* harmony export */   CertificateNotAuthorizedErrorCode: () => (/* binding */ CertificateNotAuthorizedErrorCode),\n/* harmony export */   CertificateOutdatedErrorCode: () => (/* binding */ CertificateOutdatedErrorCode),\n/* harmony export */   CertificateTimeErrorCode: () => (/* binding */ CertificateTimeErrorCode),\n/* harmony export */   CertificateVerificationErrorCode: () => (/* binding */ CertificateVerificationErrorCode),\n/* harmony export */   CertifiedRejectErrorCode: () => (/* binding */ CertifiedRejectErrorCode),\n/* harmony export */   CreateHttpAgentErrorCode: () => (/* binding */ CreateHttpAgentErrorCode),\n/* harmony export */   DerDecodeErrorCode: () => (/* binding */ DerDecodeErrorCode),\n/* harmony export */   DerDecodeLengthMismatchErrorCode: () => (/* binding */ DerDecodeLengthMismatchErrorCode),\n/* harmony export */   DerEncodeErrorCode: () => (/* binding */ DerEncodeErrorCode),\n/* harmony export */   DerKeyLengthMismatchErrorCode: () => (/* binding */ DerKeyLengthMismatchErrorCode),\n/* harmony export */   DerPrefixMismatchErrorCode: () => (/* binding */ DerPrefixMismatchErrorCode),\n/* harmony export */   ErrorKindEnum: () => (/* binding */ ErrorKindEnum),\n/* harmony export */   ExpiryJsonDeserializeErrorCode: () => (/* binding */ ExpiryJsonDeserializeErrorCode),\n/* harmony export */   ExternalError: () => (/* binding */ ExternalError),\n/* harmony export */   HashTreeDecodeErrorCode: () => (/* binding */ HashTreeDecodeErrorCode),\n/* harmony export */   HashValueErrorCode: () => (/* binding */ HashValueErrorCode),\n/* harmony export */   HexDecodeErrorCode: () => (/* binding */ HexDecodeErrorCode),\n/* harmony export */   HttpDefaultFetchErrorCode: () => (/* binding */ HttpDefaultFetchErrorCode),\n/* harmony export */   HttpErrorCode: () => (/* binding */ HttpErrorCode),\n/* harmony export */   HttpFetchErrorCode: () => (/* binding */ HttpFetchErrorCode),\n/* harmony export */   HttpV3ApiNotSupportedErrorCode: () => (/* binding */ HttpV3ApiNotSupportedErrorCode),\n/* harmony export */   IdentityInvalidErrorCode: () => (/* binding */ IdentityInvalidErrorCode),\n/* harmony export */   IngressExpiryInvalidErrorCode: () => (/* binding */ IngressExpiryInvalidErrorCode),\n/* harmony export */   InputError: () => (/* binding */ InputError),\n/* harmony export */   InvalidReadStateRequestErrorCode: () => (/* binding */ InvalidReadStateRequestErrorCode),\n/* harmony export */   LimitError: () => (/* binding */ LimitError),\n/* harmony export */   LookupErrorCode: () => (/* binding */ LookupErrorCode),\n/* harmony export */   MalformedLookupFoundValueErrorCode: () => (/* binding */ MalformedLookupFoundValueErrorCode),\n/* harmony export */   MalformedPublicKeyErrorCode: () => (/* binding */ MalformedPublicKeyErrorCode),\n/* harmony export */   MalformedSignatureErrorCode: () => (/* binding */ MalformedSignatureErrorCode),\n/* harmony export */   MissingCanisterIdErrorCode: () => (/* binding */ MissingCanisterIdErrorCode),\n/* harmony export */   MissingLookupValueErrorCode: () => (/* binding */ MissingLookupValueErrorCode),\n/* harmony export */   MissingRootKeyErrorCode: () => (/* binding */ MissingRootKeyErrorCode),\n/* harmony export */   MissingSignatureErrorCode: () => (/* binding */ MissingSignatureErrorCode),\n/* harmony export */   ProtocolError: () => (/* binding */ ProtocolError),\n/* harmony export */   QuerySignatureVerificationFailedErrorCode: () => (/* binding */ QuerySignatureVerificationFailedErrorCode),\n/* harmony export */   RejectError: () => (/* binding */ RejectError),\n/* harmony export */   RequestStatusDoneNoReplyErrorCode: () => (/* binding */ RequestStatusDoneNoReplyErrorCode),\n/* harmony export */   TimeoutWaitingForResponseErrorCode: () => (/* binding */ TimeoutWaitingForResponseErrorCode),\n/* harmony export */   TransportError: () => (/* binding */ TransportError),\n/* harmony export */   TrustError: () => (/* binding */ TrustError),\n/* harmony export */   UNREACHABLE_ERROR: () => (/* binding */ UNREACHABLE_ERROR),\n/* harmony export */   UncertifiedRejectErrorCode: () => (/* binding */ UncertifiedRejectErrorCode),\n/* harmony export */   UncertifiedRejectUpdateErrorCode: () => (/* binding */ UncertifiedRejectUpdateErrorCode),\n/* harmony export */   UnexpectedErrorCode: () => (/* binding */ UnexpectedErrorCode),\n/* harmony export */   UnknownError: () => (/* binding */ UnknownError)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/utils */ \"(ssr)/../../packages/sdk-js/node_modules/@noble/hashes/esm/utils.js\");\n\nvar ErrorKindEnum;\n(function (ErrorKindEnum) {\n    ErrorKindEnum[\"Trust\"] = \"Trust\";\n    ErrorKindEnum[\"Protocol\"] = \"Protocol\";\n    ErrorKindEnum[\"Reject\"] = \"Reject\";\n    ErrorKindEnum[\"Transport\"] = \"Transport\";\n    ErrorKindEnum[\"External\"] = \"External\";\n    ErrorKindEnum[\"Limit\"] = \"Limit\";\n    ErrorKindEnum[\"Input\"] = \"Input\";\n    ErrorKindEnum[\"Unknown\"] = \"Unknown\";\n})(ErrorKindEnum || (ErrorKindEnum = {}));\nclass ErrorCode {\n    constructor(isCertified = false) {\n        this.isCertified = isCertified;\n    }\n    toString() {\n        let errorMessage = this.toErrorMessage();\n        if (this.requestContext) {\n            errorMessage +=\n                `\\nRequest context:\\n` +\n                    `  Request ID (hex): ${this.requestContext.requestId ? (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(this.requestContext.requestId) : 'undefined'}\\n` +\n                    `  Sender pubkey (hex): ${(0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(this.requestContext.senderPubKey)}\\n` +\n                    `  Sender signature (hex): ${(0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(this.requestContext.senderSignature)}\\n` +\n                    `  Ingress expiry: ${this.requestContext.ingressExpiry.toString()}`;\n        }\n        if (this.callContext) {\n            errorMessage +=\n                `\\nCall context:\\n` +\n                    `  Canister ID: ${this.callContext.canisterId.toText()}\\n` +\n                    `  Method name: ${this.callContext.methodName}\\n` +\n                    `  HTTP details: ${JSON.stringify(this.callContext.httpDetails, null, 2)}`;\n        }\n        return errorMessage;\n    }\n}\n/**\n * An error that happens in the Agent. This is the root of all errors and should be used\n * everywhere in the Agent code (this package).\n *\n * To know if the error is certified, use the `isCertified` getter.\n */\nclass AgentError extends Error {\n    get code() {\n        return this.cause.code;\n    }\n    set code(code) {\n        this.cause.code = code;\n    }\n    get kind() {\n        return this.cause.kind;\n    }\n    set kind(kind) {\n        this.cause.kind = kind;\n    }\n    /**\n     * Reads the `isCertified` property of the underlying error code.\n     * @returns `true` if the error is certified, `false` otherwise.\n     */\n    get isCertified() {\n        return this.code.isCertified;\n    }\n    constructor(code, kind) {\n        super(code.toString());\n        this.name = 'AgentError';\n        this.cause = { code, kind };\n        Object.setPrototypeOf(this, AgentError.prototype);\n    }\n    hasCode(code) {\n        return this.code instanceof code;\n    }\n    toString() {\n        return `${this.name} (${this.kind}): ${this.message}`;\n    }\n}\nclass ErrorKind extends AgentError {\n    static fromCode(code) {\n        return new this(code);\n    }\n}\nclass TrustError extends ErrorKind {\n    constructor(code) {\n        super(code, ErrorKindEnum.Trust);\n        this.name = 'TrustError';\n        Object.setPrototypeOf(this, TrustError.prototype);\n    }\n}\nclass ProtocolError extends ErrorKind {\n    constructor(code) {\n        super(code, ErrorKindEnum.Protocol);\n        this.name = 'ProtocolError';\n        Object.setPrototypeOf(this, ProtocolError.prototype);\n    }\n}\nclass RejectError extends ErrorKind {\n    constructor(code) {\n        super(code, ErrorKindEnum.Reject);\n        this.name = 'RejectError';\n        Object.setPrototypeOf(this, RejectError.prototype);\n    }\n}\nclass TransportError extends ErrorKind {\n    constructor(code) {\n        super(code, ErrorKindEnum.Transport);\n        this.name = 'TransportError';\n        Object.setPrototypeOf(this, TransportError.prototype);\n    }\n}\nclass ExternalError extends ErrorKind {\n    constructor(code) {\n        super(code, ErrorKindEnum.External);\n        this.name = 'ExternalError';\n        Object.setPrototypeOf(this, ExternalError.prototype);\n    }\n}\nclass LimitError extends ErrorKind {\n    constructor(code) {\n        super(code, ErrorKindEnum.Limit);\n        this.name = 'LimitError';\n        Object.setPrototypeOf(this, LimitError.prototype);\n    }\n}\nclass InputError extends ErrorKind {\n    constructor(code) {\n        super(code, ErrorKindEnum.Input);\n        this.name = 'InputError';\n        Object.setPrototypeOf(this, InputError.prototype);\n    }\n}\nclass UnknownError extends ErrorKind {\n    constructor(code) {\n        super(code, ErrorKindEnum.Unknown);\n        this.name = 'UnknownError';\n        Object.setPrototypeOf(this, UnknownError.prototype);\n    }\n}\nclass CertificateVerificationErrorCode extends ErrorCode {\n    constructor(reason, error) {\n        super();\n        this.reason = reason;\n        this.error = error;\n        this.name = 'CertificateVerificationErrorCode';\n        Object.setPrototypeOf(this, CertificateVerificationErrorCode.prototype);\n    }\n    toErrorMessage() {\n        let errorMessage = this.reason;\n        if (this.error) {\n            errorMessage += `: ${formatUnknownError(this.error)}`;\n        }\n        return `Certificate verification error: \"${errorMessage}\"`;\n    }\n}\nclass CertificateTimeErrorCode extends ErrorCode {\n    constructor(maxAgeInMinutes, certificateTime, currentTime, timeDiffMsecs, ageType) {\n        super();\n        this.maxAgeInMinutes = maxAgeInMinutes;\n        this.certificateTime = certificateTime;\n        this.currentTime = currentTime;\n        this.timeDiffMsecs = timeDiffMsecs;\n        this.ageType = ageType;\n        this.name = 'CertificateTimeErrorCode';\n        Object.setPrototypeOf(this, CertificateTimeErrorCode.prototype);\n    }\n    toErrorMessage() {\n        return `Certificate is signed more than ${this.maxAgeInMinutes} minutes in the ${this.ageType}. Certificate time: ${this.certificateTime.toISOString()} Current time: ${this.currentTime.toISOString()} Clock drift: ${this.timeDiffMsecs}ms`;\n    }\n}\nclass CertificateHasTooManyDelegationsErrorCode extends ErrorCode {\n    constructor() {\n        super();\n        this.name = 'CertificateHasTooManyDelegationsErrorCode';\n        Object.setPrototypeOf(this, CertificateHasTooManyDelegationsErrorCode.prototype);\n    }\n    toErrorMessage() {\n        return 'Certificate has too many delegations';\n    }\n}\nclass CertificateNotAuthorizedErrorCode extends ErrorCode {\n    constructor(canisterId, subnetId) {\n        super();\n        this.canisterId = canisterId;\n        this.subnetId = subnetId;\n        this.name = 'CertificateNotAuthorizedErrorCode';\n        Object.setPrototypeOf(this, CertificateNotAuthorizedErrorCode.prototype);\n    }\n    toErrorMessage() {\n        return `The certificate contains a delegation that does not include the canister ${this.canisterId.toText()} in the canister_ranges field. Subnet ID: ${this.subnetId.toText()}`;\n    }\n}\nclass LookupErrorCode extends ErrorCode {\n    constructor(message, lookupStatus) {\n        super();\n        this.message = message;\n        this.lookupStatus = lookupStatus;\n        this.name = 'LookupErrorCode';\n        Object.setPrototypeOf(this, LookupErrorCode.prototype);\n    }\n    toErrorMessage() {\n        return `${this.message}. Lookup status: ${this.lookupStatus}`;\n    }\n}\nclass MalformedLookupFoundValueErrorCode extends ErrorCode {\n    constructor(message) {\n        super();\n        this.message = message;\n        this.name = 'MalformedLookupFoundValueErrorCode';\n        Object.setPrototypeOf(this, MalformedLookupFoundValueErrorCode.prototype);\n    }\n    toErrorMessage() {\n        return this.message;\n    }\n}\nclass MissingLookupValueErrorCode extends ErrorCode {\n    constructor(message) {\n        super();\n        this.message = message;\n        this.name = 'MissingLookupValueErrorCode';\n        Object.setPrototypeOf(this, MissingLookupValueErrorCode.prototype);\n    }\n    toErrorMessage() {\n        return this.message;\n    }\n}\nclass DerKeyLengthMismatchErrorCode extends ErrorCode {\n    constructor(expectedLength, actualLength) {\n        super();\n        this.expectedLength = expectedLength;\n        this.actualLength = actualLength;\n        this.name = 'DerKeyLengthMismatchErrorCode';\n        Object.setPrototypeOf(this, DerKeyLengthMismatchErrorCode.prototype);\n    }\n    toErrorMessage() {\n        return `BLS DER-encoded public key must be ${this.expectedLength} bytes long, but is ${this.actualLength} bytes long`;\n    }\n}\nclass DerPrefixMismatchErrorCode extends ErrorCode {\n    constructor(expectedPrefix, actualPrefix) {\n        super();\n        this.expectedPrefix = expectedPrefix;\n        this.actualPrefix = actualPrefix;\n        this.name = 'DerPrefixMismatchErrorCode';\n        Object.setPrototypeOf(this, DerPrefixMismatchErrorCode.prototype);\n    }\n    toErrorMessage() {\n        return `BLS DER-encoded public key is invalid. Expected the following prefix: ${(0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(this.expectedPrefix)}, but got ${(0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(this.actualPrefix)}`;\n    }\n}\nclass DerDecodeLengthMismatchErrorCode extends ErrorCode {\n    constructor(expectedLength, actualLength) {\n        super();\n        this.expectedLength = expectedLength;\n        this.actualLength = actualLength;\n        this.name = 'DerDecodeLengthMismatchErrorCode';\n        Object.setPrototypeOf(this, DerDecodeLengthMismatchErrorCode.prototype);\n    }\n    toErrorMessage() {\n        return `DER payload mismatch: Expected length ${this.expectedLength}, actual length: ${this.actualLength}`;\n    }\n}\nclass DerDecodeErrorCode extends ErrorCode {\n    constructor(error) {\n        super();\n        this.error = error;\n        this.name = 'DerDecodeErrorCode';\n        Object.setPrototypeOf(this, DerDecodeErrorCode.prototype);\n    }\n    toErrorMessage() {\n        return `Failed to decode DER: ${this.error}`;\n    }\n}\nclass DerEncodeErrorCode extends ErrorCode {\n    constructor(error) {\n        super();\n        this.error = error;\n        this.name = 'DerEncodeErrorCode';\n        Object.setPrototypeOf(this, DerEncodeErrorCode.prototype);\n    }\n    toErrorMessage() {\n        return `Failed to encode DER: ${this.error}`;\n    }\n}\nclass CborDecodeErrorCode extends ErrorCode {\n    constructor(error, input) {\n        super();\n        this.error = error;\n        this.input = input;\n        this.name = 'CborDecodeErrorCode';\n        Object.setPrototypeOf(this, CborDecodeErrorCode.prototype);\n    }\n    toErrorMessage() {\n        return `Failed to decode CBOR: ${formatUnknownError(this.error)}, input: ${(0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(this.input)}`;\n    }\n}\nclass CborEncodeErrorCode extends ErrorCode {\n    constructor(error, value) {\n        super();\n        this.error = error;\n        this.value = value;\n        this.name = 'CborEncodeErrorCode';\n        Object.setPrototypeOf(this, CborEncodeErrorCode.prototype);\n    }\n    toErrorMessage() {\n        return `Failed to encode CBOR: ${formatUnknownError(this.error)}, input: ${this.value}`;\n    }\n}\nclass HexDecodeErrorCode extends ErrorCode {\n    constructor(error) {\n        super();\n        this.error = error;\n        this.name = 'HexDecodeErrorCode';\n        Object.setPrototypeOf(this, HexDecodeErrorCode.prototype);\n    }\n    toErrorMessage() {\n        return `Failed to decode hex: ${this.error}`;\n    }\n}\nclass TimeoutWaitingForResponseErrorCode extends ErrorCode {\n    constructor(message, requestId, status) {\n        super();\n        this.message = message;\n        this.requestId = requestId;\n        this.status = status;\n        this.name = 'TimeoutWaitingForResponseErrorCode';\n        Object.setPrototypeOf(this, TimeoutWaitingForResponseErrorCode.prototype);\n    }\n    toErrorMessage() {\n        let errorMessage = `${this.message}\\n`;\n        if (this.requestId) {\n            errorMessage += `  Request ID: ${(0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(this.requestId)}\\n`;\n        }\n        if (this.status) {\n            errorMessage += `  Request status: ${this.status}\\n`;\n        }\n        return errorMessage;\n    }\n}\nclass CertificateOutdatedErrorCode extends ErrorCode {\n    constructor(maxIngressExpiryInMinutes, requestId, retryTimes) {\n        super();\n        this.maxIngressExpiryInMinutes = maxIngressExpiryInMinutes;\n        this.requestId = requestId;\n        this.retryTimes = retryTimes;\n        this.name = 'CertificateOutdatedErrorCode';\n        Object.setPrototypeOf(this, CertificateOutdatedErrorCode.prototype);\n    }\n    toErrorMessage() {\n        let errorMessage = `Certificate is stale (over ${this.maxIngressExpiryInMinutes} minutes). Is the computer's clock synchronized?\\n  Request ID: ${(0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(this.requestId)}\\n`;\n        if (this.retryTimes !== undefined) {\n            errorMessage += `  Retried ${this.retryTimes} times.`;\n        }\n        return errorMessage;\n    }\n}\nclass CertifiedRejectErrorCode extends ErrorCode {\n    constructor(requestId, rejectCode, rejectMessage, rejectErrorCode) {\n        super(true);\n        this.requestId = requestId;\n        this.rejectCode = rejectCode;\n        this.rejectMessage = rejectMessage;\n        this.rejectErrorCode = rejectErrorCode;\n        this.name = 'CertifiedRejectErrorCode';\n        Object.setPrototypeOf(this, CertifiedRejectErrorCode.prototype);\n    }\n    toErrorMessage() {\n        return (`The replica returned a rejection error:\\n` +\n            `  Request ID: ${(0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(this.requestId)}\\n` +\n            `  Reject code: ${this.rejectCode}\\n` +\n            `  Reject text: ${this.rejectMessage}\\n` +\n            `  Error code: ${this.rejectErrorCode}\\n`);\n    }\n}\nclass UncertifiedRejectErrorCode extends ErrorCode {\n    constructor(requestId, rejectCode, rejectMessage, rejectErrorCode, signatures) {\n        super();\n        this.requestId = requestId;\n        this.rejectCode = rejectCode;\n        this.rejectMessage = rejectMessage;\n        this.rejectErrorCode = rejectErrorCode;\n        this.signatures = signatures;\n        this.name = 'UncertifiedRejectErrorCode';\n        Object.setPrototypeOf(this, UncertifiedRejectErrorCode.prototype);\n    }\n    toErrorMessage() {\n        return (`The replica returned a rejection error:\\n` +\n            `  Request ID: ${(0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(this.requestId)}\\n` +\n            `  Reject code: ${this.rejectCode}\\n` +\n            `  Reject text: ${this.rejectMessage}\\n` +\n            `  Error code: ${this.rejectErrorCode}\\n`);\n    }\n}\nclass UncertifiedRejectUpdateErrorCode extends ErrorCode {\n    constructor(requestId, rejectCode, rejectMessage, rejectErrorCode) {\n        super();\n        this.requestId = requestId;\n        this.rejectCode = rejectCode;\n        this.rejectMessage = rejectMessage;\n        this.rejectErrorCode = rejectErrorCode;\n        this.name = 'UncertifiedRejectUpdateErrorCode';\n        Object.setPrototypeOf(this, UncertifiedRejectUpdateErrorCode.prototype);\n    }\n    toErrorMessage() {\n        return (`The replica returned a rejection error:\\n` +\n            `  Request ID: ${(0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(this.requestId)}\\n` +\n            `  Reject code: ${this.rejectCode}\\n` +\n            `  Reject text: ${this.rejectMessage}\\n` +\n            `  Error code: ${this.rejectErrorCode}\\n`);\n    }\n}\nclass RequestStatusDoneNoReplyErrorCode extends ErrorCode {\n    constructor(requestId) {\n        super();\n        this.requestId = requestId;\n        this.name = 'RequestStatusDoneNoReplyErrorCode';\n        Object.setPrototypeOf(this, RequestStatusDoneNoReplyErrorCode.prototype);\n    }\n    toErrorMessage() {\n        return (`Call was marked as done but we never saw the reply:\\n` +\n            `  Request ID: ${(0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(this.requestId)}\\n`);\n    }\n}\nclass MissingRootKeyErrorCode extends ErrorCode {\n    constructor(shouldFetchRootKey) {\n        super();\n        this.shouldFetchRootKey = shouldFetchRootKey;\n        this.name = 'MissingRootKeyErrorCode';\n        Object.setPrototypeOf(this, MissingRootKeyErrorCode.prototype);\n    }\n    toErrorMessage() {\n        if (this.shouldFetchRootKey === undefined) {\n            return 'Agent is missing root key';\n        }\n        return `Agent is missing root key and the shouldFetchRootKey value is set to ${this.shouldFetchRootKey}. The root key should only be unknown if you are in local development. Otherwise you should avoid fetching and use the default IC Root Key or the known root key of your environment.`;\n    }\n}\nclass HashValueErrorCode extends ErrorCode {\n    constructor(value) {\n        super();\n        this.value = value;\n        this.name = 'HashValueErrorCode';\n        Object.setPrototypeOf(this, HashValueErrorCode.prototype);\n    }\n    toErrorMessage() {\n        return `Attempt to hash a value of unsupported type: ${this.value}`;\n    }\n}\nclass HttpDefaultFetchErrorCode extends ErrorCode {\n    constructor(error) {\n        super();\n        this.error = error;\n        this.name = 'HttpDefaultFetchErrorCode';\n        Object.setPrototypeOf(this, HttpDefaultFetchErrorCode.prototype);\n    }\n    toErrorMessage() {\n        return this.error;\n    }\n}\nclass IdentityInvalidErrorCode extends ErrorCode {\n    constructor() {\n        super();\n        this.name = 'IdentityInvalidErrorCode';\n        Object.setPrototypeOf(this, IdentityInvalidErrorCode.prototype);\n    }\n    toErrorMessage() {\n        return \"This identity has expired due this application's security policy. Please refresh your authentication.\";\n    }\n}\nclass IngressExpiryInvalidErrorCode extends ErrorCode {\n    constructor(message, providedIngressExpiryInMinutes) {\n        super();\n        this.message = message;\n        this.providedIngressExpiryInMinutes = providedIngressExpiryInMinutes;\n        this.name = 'IngressExpiryInvalidErrorCode';\n        Object.setPrototypeOf(this, IngressExpiryInvalidErrorCode.prototype);\n    }\n    toErrorMessage() {\n        return `${this.message}. Provided ingress expiry time is ${this.providedIngressExpiryInMinutes} minutes.`;\n    }\n}\nclass CreateHttpAgentErrorCode extends ErrorCode {\n    constructor() {\n        super();\n        this.name = 'CreateHttpAgentErrorCode';\n        Object.setPrototypeOf(this, CreateHttpAgentErrorCode.prototype);\n    }\n    toErrorMessage() {\n        return 'Failed to create agent from provided agent';\n    }\n}\nclass MalformedSignatureErrorCode extends ErrorCode {\n    constructor(error) {\n        super();\n        this.error = error;\n        this.name = 'MalformedSignatureErrorCode';\n        Object.setPrototypeOf(this, MalformedSignatureErrorCode.prototype);\n    }\n    toErrorMessage() {\n        return `Query response contained a malformed signature: ${this.error}`;\n    }\n}\nclass MissingSignatureErrorCode extends ErrorCode {\n    constructor() {\n        super();\n        this.name = 'MissingSignatureErrorCode';\n        Object.setPrototypeOf(this, MissingSignatureErrorCode.prototype);\n    }\n    toErrorMessage() {\n        return 'Query response did not contain any node signatures';\n    }\n}\nclass MalformedPublicKeyErrorCode extends ErrorCode {\n    constructor() {\n        super();\n        this.name = 'MalformedPublicKeyErrorCode';\n        Object.setPrototypeOf(this, MalformedPublicKeyErrorCode.prototype);\n    }\n    toErrorMessage() {\n        return 'Read state response contained a malformed public key';\n    }\n}\nclass QuerySignatureVerificationFailedErrorCode extends ErrorCode {\n    constructor(nodeId) {\n        super();\n        this.nodeId = nodeId;\n        this.name = 'QuerySignatureVerificationFailedErrorCode';\n        Object.setPrototypeOf(this, QuerySignatureVerificationFailedErrorCode.prototype);\n    }\n    toErrorMessage() {\n        return `Query signature verification failed. Node ID: ${this.nodeId}`;\n    }\n}\nclass UnexpectedErrorCode extends ErrorCode {\n    constructor(error) {\n        super();\n        this.error = error;\n        this.name = 'UnexpectedErrorCode';\n        Object.setPrototypeOf(this, UnexpectedErrorCode.prototype);\n    }\n    toErrorMessage() {\n        return `Unexpected error: ${formatUnknownError(this.error)}`;\n    }\n}\nclass HashTreeDecodeErrorCode extends ErrorCode {\n    constructor(error) {\n        super();\n        this.error = error;\n        this.name = 'HashTreeDecodeErrorCode';\n        Object.setPrototypeOf(this, HashTreeDecodeErrorCode.prototype);\n    }\n    toErrorMessage() {\n        return `Failed to decode certificate: ${this.error}`;\n    }\n}\nclass HttpErrorCode extends ErrorCode {\n    constructor(status, statusText, headers, bodyText) {\n        super();\n        this.status = status;\n        this.statusText = statusText;\n        this.headers = headers;\n        this.bodyText = bodyText;\n        this.name = 'HttpErrorCode';\n        Object.setPrototypeOf(this, HttpErrorCode.prototype);\n    }\n    toErrorMessage() {\n        let errorMessage = 'HTTP request failed:\\n' +\n            `  Status: ${this.status} (${this.statusText})\\n` +\n            `  Headers: ${JSON.stringify(this.headers)}\\n`;\n        if (this.bodyText) {\n            errorMessage += `  Body: ${this.bodyText}\\n`;\n        }\n        return errorMessage;\n    }\n}\nclass HttpV3ApiNotSupportedErrorCode extends ErrorCode {\n    constructor() {\n        super();\n        this.name = 'HttpV3ApiNotSupportedErrorCode';\n        Object.setPrototypeOf(this, HttpV3ApiNotSupportedErrorCode.prototype);\n    }\n    toErrorMessage() {\n        return 'HTTP request failed: v3 API is not supported';\n    }\n}\nclass HttpFetchErrorCode extends ErrorCode {\n    constructor(error) {\n        super();\n        this.error = error;\n        this.name = 'HttpFetchErrorCode';\n        Object.setPrototypeOf(this, HttpFetchErrorCode.prototype);\n    }\n    toErrorMessage() {\n        return `Failed to fetch HTTP request: ${formatUnknownError(this.error)}`;\n    }\n}\nclass MissingCanisterIdErrorCode extends ErrorCode {\n    constructor(receivedCanisterId) {\n        super();\n        this.receivedCanisterId = receivedCanisterId;\n        this.name = 'MissingCanisterIdErrorCode';\n        Object.setPrototypeOf(this, MissingCanisterIdErrorCode.prototype);\n    }\n    toErrorMessage() {\n        return `Canister ID is required, but received ${typeof this.receivedCanisterId} instead. If you are using automatically generated declarations, this may be because your application is not setting the canister ID in process.env correctly.`;\n    }\n}\nclass InvalidReadStateRequestErrorCode extends ErrorCode {\n    constructor(request) {\n        super();\n        this.request = request;\n        this.name = 'InvalidReadStateRequestErrorCode';\n        Object.setPrototypeOf(this, InvalidReadStateRequestErrorCode.prototype);\n    }\n    toErrorMessage() {\n        return `Invalid read state request: ${this.request}`;\n    }\n}\nclass ExpiryJsonDeserializeErrorCode extends ErrorCode {\n    constructor(error) {\n        super();\n        this.error = error;\n        this.name = 'ExpiryJsonDeserializeErrorCode';\n        Object.setPrototypeOf(this, ExpiryJsonDeserializeErrorCode.prototype);\n    }\n    toErrorMessage() {\n        return `Failed to deserialize expiry: ${this.error}`;\n    }\n}\nfunction formatUnknownError(error) {\n    if (error instanceof Error) {\n        return error.stack ?? error.message;\n    }\n    try {\n        return JSON.stringify(error);\n    }\n    catch {\n        return String(error);\n    }\n}\n/**\n * Special error used to indicate that a code path is unreachable.\n *\n * For internal use only.\n */\nconst UNREACHABLE_ERROR = new Error('unreachable');\n//# sourceMappingURL=errors.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vcGFja2FnZXMvc2RrLWpzL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL2Vycm9ycy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBaUQ7QUFDMUM7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHNDQUFzQztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsZ0NBQWdDLCtEQUFVLDhDQUE4QztBQUNuSSw4Q0FBOEMsK0RBQVUsbUNBQW1DO0FBQzNGLGlEQUFpRCwrREFBVSxzQ0FBc0M7QUFDakcseUNBQXlDLDZDQUE2QztBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxxQ0FBcUM7QUFDM0Usc0NBQXNDLDRCQUE0QjtBQUNsRSx1Q0FBdUMsc0RBQXNEO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsV0FBVyxHQUFHLFVBQVUsS0FBSyxhQUFhO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsK0JBQStCO0FBQ2hFO0FBQ0EsbURBQW1ELGFBQWE7QUFDaEU7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxzQkFBc0IsaUJBQWlCLGFBQWEsc0JBQXNCLG9DQUFvQyxnQkFBZ0IsZ0NBQWdDLGVBQWUsbUJBQW1CO0FBQ2xQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJGQUEyRiwwQkFBMEIsMkNBQTJDLHVCQUF1QjtBQUN2TDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGFBQWEsbUJBQW1CLGtCQUFrQjtBQUNwRTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQscUJBQXFCLHFCQUFxQixtQkFBbUI7QUFDbEg7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdGQUF3RiwrREFBVSxzQkFBc0IsWUFBWSwrREFBVSxvQkFBb0I7QUFDbEs7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxvQkFBb0IsbUJBQW1CLGtCQUFrQjtBQUNqSDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxXQUFXO0FBQ25EO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFdBQVc7QUFDbkQ7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QywrQkFBK0IsV0FBVywrREFBVSxhQUFhO0FBQzFHO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsK0JBQStCLFdBQVcsV0FBVztBQUM5RjtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxXQUFXO0FBQ25EO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixhQUFhO0FBQzNDO0FBQ0EsNkNBQTZDLCtEQUFVLGlCQUFpQjtBQUN4RTtBQUNBO0FBQ0EsaURBQWlELFlBQVk7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxnQ0FBZ0MsaUVBQWlFLCtEQUFVLGlCQUFpQjtBQUNyTDtBQUNBLHlDQUF5QyxpQkFBaUI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsK0RBQVUsaUJBQWlCO0FBQ3hELDhCQUE4QixnQkFBZ0I7QUFDOUMsOEJBQThCLG1CQUFtQjtBQUNqRCw2QkFBNkIscUJBQXFCO0FBQ2xEO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QiwrREFBVSxpQkFBaUI7QUFDeEQsOEJBQThCLGdCQUFnQjtBQUM5Qyw4QkFBOEIsbUJBQW1CO0FBQ2pELDZCQUE2QixxQkFBcUI7QUFDbEQ7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QiwrREFBVSxpQkFBaUI7QUFDeEQsOEJBQThCLGdCQUFnQjtBQUM5Qyw4QkFBOEIsbUJBQW1CO0FBQ2pELDZCQUE2QixxQkFBcUI7QUFDbEQ7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QiwrREFBVSxpQkFBaUI7QUFDeEQ7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RkFBdUYsd0JBQXdCO0FBQy9HO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELFdBQVc7QUFDMUU7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixhQUFhLG9DQUFvQyxxQ0FBcUM7QUFDeEc7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxXQUFXO0FBQzdFO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxZQUFZO0FBQzVFO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLCtCQUErQjtBQUNuRTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxXQUFXO0FBQzNEO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsYUFBYSxHQUFHLGdCQUFnQjtBQUN6RCwwQkFBMEIsNkJBQTZCO0FBQ3ZEO0FBQ0EsdUNBQXVDLGNBQWM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsK0JBQStCO0FBQy9FO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELGdDQUFnQztBQUN4RjtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxhQUFhO0FBQzNEO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFdBQVc7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCIsInNvdXJjZXMiOlsid2VicGFjazovL0BpcXViZS9vcHMtY29uc29sZS8uLi8uLi9wYWNrYWdlcy9zZGstanMvbm9kZV9tb2R1bGVzL0BkZmluaXR5L2FnZW50L2xpYi9lc20vZXJyb3JzLmpzPzI5ZjYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYnl0ZXNUb0hleCB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvdXRpbHMnO1xuZXhwb3J0IHZhciBFcnJvcktpbmRFbnVtO1xuKGZ1bmN0aW9uIChFcnJvcktpbmRFbnVtKSB7XG4gICAgRXJyb3JLaW5kRW51bVtcIlRydXN0XCJdID0gXCJUcnVzdFwiO1xuICAgIEVycm9yS2luZEVudW1bXCJQcm90b2NvbFwiXSA9IFwiUHJvdG9jb2xcIjtcbiAgICBFcnJvcktpbmRFbnVtW1wiUmVqZWN0XCJdID0gXCJSZWplY3RcIjtcbiAgICBFcnJvcktpbmRFbnVtW1wiVHJhbnNwb3J0XCJdID0gXCJUcmFuc3BvcnRcIjtcbiAgICBFcnJvcktpbmRFbnVtW1wiRXh0ZXJuYWxcIl0gPSBcIkV4dGVybmFsXCI7XG4gICAgRXJyb3JLaW5kRW51bVtcIkxpbWl0XCJdID0gXCJMaW1pdFwiO1xuICAgIEVycm9yS2luZEVudW1bXCJJbnB1dFwiXSA9IFwiSW5wdXRcIjtcbiAgICBFcnJvcktpbmRFbnVtW1wiVW5rbm93blwiXSA9IFwiVW5rbm93blwiO1xufSkoRXJyb3JLaW5kRW51bSB8fCAoRXJyb3JLaW5kRW51bSA9IHt9KSk7XG5jbGFzcyBFcnJvckNvZGUge1xuICAgIGNvbnN0cnVjdG9yKGlzQ2VydGlmaWVkID0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5pc0NlcnRpZmllZCA9IGlzQ2VydGlmaWVkO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgbGV0IGVycm9yTWVzc2FnZSA9IHRoaXMudG9FcnJvck1lc3NhZ2UoKTtcbiAgICAgICAgaWYgKHRoaXMucmVxdWVzdENvbnRleHQpIHtcbiAgICAgICAgICAgIGVycm9yTWVzc2FnZSArPVxuICAgICAgICAgICAgICAgIGBcXG5SZXF1ZXN0IGNvbnRleHQ6XFxuYCArXG4gICAgICAgICAgICAgICAgICAgIGAgIFJlcXVlc3QgSUQgKGhleCk6ICR7dGhpcy5yZXF1ZXN0Q29udGV4dC5yZXF1ZXN0SWQgPyBieXRlc1RvSGV4KHRoaXMucmVxdWVzdENvbnRleHQucmVxdWVzdElkKSA6ICd1bmRlZmluZWQnfVxcbmAgK1xuICAgICAgICAgICAgICAgICAgICBgICBTZW5kZXIgcHVia2V5IChoZXgpOiAke2J5dGVzVG9IZXgodGhpcy5yZXF1ZXN0Q29udGV4dC5zZW5kZXJQdWJLZXkpfVxcbmAgK1xuICAgICAgICAgICAgICAgICAgICBgICBTZW5kZXIgc2lnbmF0dXJlIChoZXgpOiAke2J5dGVzVG9IZXgodGhpcy5yZXF1ZXN0Q29udGV4dC5zZW5kZXJTaWduYXR1cmUpfVxcbmAgK1xuICAgICAgICAgICAgICAgICAgICBgICBJbmdyZXNzIGV4cGlyeTogJHt0aGlzLnJlcXVlc3RDb250ZXh0LmluZ3Jlc3NFeHBpcnkudG9TdHJpbmcoKX1gO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNhbGxDb250ZXh0KSB7XG4gICAgICAgICAgICBlcnJvck1lc3NhZ2UgKz1cbiAgICAgICAgICAgICAgICBgXFxuQ2FsbCBjb250ZXh0OlxcbmAgK1xuICAgICAgICAgICAgICAgICAgICBgICBDYW5pc3RlciBJRDogJHt0aGlzLmNhbGxDb250ZXh0LmNhbmlzdGVySWQudG9UZXh0KCl9XFxuYCArXG4gICAgICAgICAgICAgICAgICAgIGAgIE1ldGhvZCBuYW1lOiAke3RoaXMuY2FsbENvbnRleHQubWV0aG9kTmFtZX1cXG5gICtcbiAgICAgICAgICAgICAgICAgICAgYCAgSFRUUCBkZXRhaWxzOiAke0pTT04uc3RyaW5naWZ5KHRoaXMuY2FsbENvbnRleHQuaHR0cERldGFpbHMsIG51bGwsIDIpfWA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVycm9yTWVzc2FnZTtcbiAgICB9XG59XG4vKipcbiAqIEFuIGVycm9yIHRoYXQgaGFwcGVucyBpbiB0aGUgQWdlbnQuIFRoaXMgaXMgdGhlIHJvb3Qgb2YgYWxsIGVycm9ycyBhbmQgc2hvdWxkIGJlIHVzZWRcbiAqIGV2ZXJ5d2hlcmUgaW4gdGhlIEFnZW50IGNvZGUgKHRoaXMgcGFja2FnZSkuXG4gKlxuICogVG8ga25vdyBpZiB0aGUgZXJyb3IgaXMgY2VydGlmaWVkLCB1c2UgdGhlIGBpc0NlcnRpZmllZGAgZ2V0dGVyLlxuICovXG5leHBvcnQgY2xhc3MgQWdlbnRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBnZXQgY29kZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2F1c2UuY29kZTtcbiAgICB9XG4gICAgc2V0IGNvZGUoY29kZSkge1xuICAgICAgICB0aGlzLmNhdXNlLmNvZGUgPSBjb2RlO1xuICAgIH1cbiAgICBnZXQga2luZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2F1c2Uua2luZDtcbiAgICB9XG4gICAgc2V0IGtpbmQoa2luZCkge1xuICAgICAgICB0aGlzLmNhdXNlLmtpbmQgPSBraW5kO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkcyB0aGUgYGlzQ2VydGlmaWVkYCBwcm9wZXJ0eSBvZiB0aGUgdW5kZXJseWluZyBlcnJvciBjb2RlLlxuICAgICAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgZXJyb3IgaXMgY2VydGlmaWVkLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBnZXQgaXNDZXJ0aWZpZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvZGUuaXNDZXJ0aWZpZWQ7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGNvZGUsIGtpbmQpIHtcbiAgICAgICAgc3VwZXIoY29kZS50b1N0cmluZygpKTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ0FnZW50RXJyb3InO1xuICAgICAgICB0aGlzLmNhdXNlID0geyBjb2RlLCBraW5kIH07XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBBZ2VudEVycm9yLnByb3RvdHlwZSk7XG4gICAgfVxuICAgIGhhc0NvZGUoY29kZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2RlIGluc3RhbmNlb2YgY29kZTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLm5hbWV9ICgke3RoaXMua2luZH0pOiAke3RoaXMubWVzc2FnZX1gO1xuICAgIH1cbn1cbmNsYXNzIEVycm9yS2luZCBleHRlbmRzIEFnZW50RXJyb3Ige1xuICAgIHN0YXRpYyBmcm9tQ29kZShjb2RlKSB7XG4gICAgICAgIHJldHVybiBuZXcgdGhpcyhjb2RlKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgVHJ1c3RFcnJvciBleHRlbmRzIEVycm9yS2luZCB7XG4gICAgY29uc3RydWN0b3IoY29kZSkge1xuICAgICAgICBzdXBlcihjb2RlLCBFcnJvcktpbmRFbnVtLlRydXN0KTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ1RydXN0RXJyb3InO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgVHJ1c3RFcnJvci5wcm90b3R5cGUpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBQcm90b2NvbEVycm9yIGV4dGVuZHMgRXJyb3JLaW5kIHtcbiAgICBjb25zdHJ1Y3Rvcihjb2RlKSB7XG4gICAgICAgIHN1cGVyKGNvZGUsIEVycm9yS2luZEVudW0uUHJvdG9jb2wpO1xuICAgICAgICB0aGlzLm5hbWUgPSAnUHJvdG9jb2xFcnJvcic7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBQcm90b2NvbEVycm9yLnByb3RvdHlwZSk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFJlamVjdEVycm9yIGV4dGVuZHMgRXJyb3JLaW5kIHtcbiAgICBjb25zdHJ1Y3Rvcihjb2RlKSB7XG4gICAgICAgIHN1cGVyKGNvZGUsIEVycm9yS2luZEVudW0uUmVqZWN0KTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ1JlamVjdEVycm9yJztcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIFJlamVjdEVycm9yLnByb3RvdHlwZSk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFRyYW5zcG9ydEVycm9yIGV4dGVuZHMgRXJyb3JLaW5kIHtcbiAgICBjb25zdHJ1Y3Rvcihjb2RlKSB7XG4gICAgICAgIHN1cGVyKGNvZGUsIEVycm9yS2luZEVudW0uVHJhbnNwb3J0KTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ1RyYW5zcG9ydEVycm9yJztcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIFRyYW5zcG9ydEVycm9yLnByb3RvdHlwZSk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEV4dGVybmFsRXJyb3IgZXh0ZW5kcyBFcnJvcktpbmQge1xuICAgIGNvbnN0cnVjdG9yKGNvZGUpIHtcbiAgICAgICAgc3VwZXIoY29kZSwgRXJyb3JLaW5kRW51bS5FeHRlcm5hbCk7XG4gICAgICAgIHRoaXMubmFtZSA9ICdFeHRlcm5hbEVycm9yJztcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIEV4dGVybmFsRXJyb3IucHJvdG90eXBlKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgTGltaXRFcnJvciBleHRlbmRzIEVycm9yS2luZCB7XG4gICAgY29uc3RydWN0b3IoY29kZSkge1xuICAgICAgICBzdXBlcihjb2RlLCBFcnJvcktpbmRFbnVtLkxpbWl0KTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ0xpbWl0RXJyb3InO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgTGltaXRFcnJvci5wcm90b3R5cGUpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBJbnB1dEVycm9yIGV4dGVuZHMgRXJyb3JLaW5kIHtcbiAgICBjb25zdHJ1Y3Rvcihjb2RlKSB7XG4gICAgICAgIHN1cGVyKGNvZGUsIEVycm9yS2luZEVudW0uSW5wdXQpO1xuICAgICAgICB0aGlzLm5hbWUgPSAnSW5wdXRFcnJvcic7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBJbnB1dEVycm9yLnByb3RvdHlwZSk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFVua25vd25FcnJvciBleHRlbmRzIEVycm9yS2luZCB7XG4gICAgY29uc3RydWN0b3IoY29kZSkge1xuICAgICAgICBzdXBlcihjb2RlLCBFcnJvcktpbmRFbnVtLlVua25vd24pO1xuICAgICAgICB0aGlzLm5hbWUgPSAnVW5rbm93bkVycm9yJztcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIFVua25vd25FcnJvci5wcm90b3R5cGUpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBDZXJ0aWZpY2F0ZVZlcmlmaWNhdGlvbkVycm9yQ29kZSBleHRlbmRzIEVycm9yQ29kZSB7XG4gICAgY29uc3RydWN0b3IocmVhc29uLCBlcnJvcikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnJlYXNvbiA9IHJlYXNvbjtcbiAgICAgICAgdGhpcy5lcnJvciA9IGVycm9yO1xuICAgICAgICB0aGlzLm5hbWUgPSAnQ2VydGlmaWNhdGVWZXJpZmljYXRpb25FcnJvckNvZGUnO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgQ2VydGlmaWNhdGVWZXJpZmljYXRpb25FcnJvckNvZGUucHJvdG90eXBlKTtcbiAgICB9XG4gICAgdG9FcnJvck1lc3NhZ2UoKSB7XG4gICAgICAgIGxldCBlcnJvck1lc3NhZ2UgPSB0aGlzLnJlYXNvbjtcbiAgICAgICAgaWYgKHRoaXMuZXJyb3IpIHtcbiAgICAgICAgICAgIGVycm9yTWVzc2FnZSArPSBgOiAke2Zvcm1hdFVua25vd25FcnJvcih0aGlzLmVycm9yKX1gO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgQ2VydGlmaWNhdGUgdmVyaWZpY2F0aW9uIGVycm9yOiBcIiR7ZXJyb3JNZXNzYWdlfVwiYDtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgQ2VydGlmaWNhdGVUaW1lRXJyb3JDb2RlIGV4dGVuZHMgRXJyb3JDb2RlIHtcbiAgICBjb25zdHJ1Y3RvcihtYXhBZ2VJbk1pbnV0ZXMsIGNlcnRpZmljYXRlVGltZSwgY3VycmVudFRpbWUsIHRpbWVEaWZmTXNlY3MsIGFnZVR5cGUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5tYXhBZ2VJbk1pbnV0ZXMgPSBtYXhBZ2VJbk1pbnV0ZXM7XG4gICAgICAgIHRoaXMuY2VydGlmaWNhdGVUaW1lID0gY2VydGlmaWNhdGVUaW1lO1xuICAgICAgICB0aGlzLmN1cnJlbnRUaW1lID0gY3VycmVudFRpbWU7XG4gICAgICAgIHRoaXMudGltZURpZmZNc2VjcyA9IHRpbWVEaWZmTXNlY3M7XG4gICAgICAgIHRoaXMuYWdlVHlwZSA9IGFnZVR5cGU7XG4gICAgICAgIHRoaXMubmFtZSA9ICdDZXJ0aWZpY2F0ZVRpbWVFcnJvckNvZGUnO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgQ2VydGlmaWNhdGVUaW1lRXJyb3JDb2RlLnByb3RvdHlwZSk7XG4gICAgfVxuICAgIHRvRXJyb3JNZXNzYWdlKCkge1xuICAgICAgICByZXR1cm4gYENlcnRpZmljYXRlIGlzIHNpZ25lZCBtb3JlIHRoYW4gJHt0aGlzLm1heEFnZUluTWludXRlc30gbWludXRlcyBpbiB0aGUgJHt0aGlzLmFnZVR5cGV9LiBDZXJ0aWZpY2F0ZSB0aW1lOiAke3RoaXMuY2VydGlmaWNhdGVUaW1lLnRvSVNPU3RyaW5nKCl9IEN1cnJlbnQgdGltZTogJHt0aGlzLmN1cnJlbnRUaW1lLnRvSVNPU3RyaW5nKCl9IENsb2NrIGRyaWZ0OiAke3RoaXMudGltZURpZmZNc2Vjc31tc2A7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIENlcnRpZmljYXRlSGFzVG9vTWFueURlbGVnYXRpb25zRXJyb3JDb2RlIGV4dGVuZHMgRXJyb3JDb2RlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ0NlcnRpZmljYXRlSGFzVG9vTWFueURlbGVnYXRpb25zRXJyb3JDb2RlJztcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIENlcnRpZmljYXRlSGFzVG9vTWFueURlbGVnYXRpb25zRXJyb3JDb2RlLnByb3RvdHlwZSk7XG4gICAgfVxuICAgIHRvRXJyb3JNZXNzYWdlKCkge1xuICAgICAgICByZXR1cm4gJ0NlcnRpZmljYXRlIGhhcyB0b28gbWFueSBkZWxlZ2F0aW9ucyc7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIENlcnRpZmljYXRlTm90QXV0aG9yaXplZEVycm9yQ29kZSBleHRlbmRzIEVycm9yQ29kZSB7XG4gICAgY29uc3RydWN0b3IoY2FuaXN0ZXJJZCwgc3VibmV0SWQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jYW5pc3RlcklkID0gY2FuaXN0ZXJJZDtcbiAgICAgICAgdGhpcy5zdWJuZXRJZCA9IHN1Ym5ldElkO1xuICAgICAgICB0aGlzLm5hbWUgPSAnQ2VydGlmaWNhdGVOb3RBdXRob3JpemVkRXJyb3JDb2RlJztcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIENlcnRpZmljYXRlTm90QXV0aG9yaXplZEVycm9yQ29kZS5wcm90b3R5cGUpO1xuICAgIH1cbiAgICB0b0Vycm9yTWVzc2FnZSgpIHtcbiAgICAgICAgcmV0dXJuIGBUaGUgY2VydGlmaWNhdGUgY29udGFpbnMgYSBkZWxlZ2F0aW9uIHRoYXQgZG9lcyBub3QgaW5jbHVkZSB0aGUgY2FuaXN0ZXIgJHt0aGlzLmNhbmlzdGVySWQudG9UZXh0KCl9IGluIHRoZSBjYW5pc3Rlcl9yYW5nZXMgZmllbGQuIFN1Ym5ldCBJRDogJHt0aGlzLnN1Ym5ldElkLnRvVGV4dCgpfWA7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIExvb2t1cEVycm9yQ29kZSBleHRlbmRzIEVycm9yQ29kZSB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgbG9va3VwU3RhdHVzKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgIHRoaXMubG9va3VwU3RhdHVzID0gbG9va3VwU3RhdHVzO1xuICAgICAgICB0aGlzLm5hbWUgPSAnTG9va3VwRXJyb3JDb2RlJztcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIExvb2t1cEVycm9yQ29kZS5wcm90b3R5cGUpO1xuICAgIH1cbiAgICB0b0Vycm9yTWVzc2FnZSgpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMubWVzc2FnZX0uIExvb2t1cCBzdGF0dXM6ICR7dGhpcy5sb29rdXBTdGF0dXN9YDtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgTWFsZm9ybWVkTG9va3VwRm91bmRWYWx1ZUVycm9yQ29kZSBleHRlbmRzIEVycm9yQ29kZSB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICB0aGlzLm5hbWUgPSAnTWFsZm9ybWVkTG9va3VwRm91bmRWYWx1ZUVycm9yQ29kZSc7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBNYWxmb3JtZWRMb29rdXBGb3VuZFZhbHVlRXJyb3JDb2RlLnByb3RvdHlwZSk7XG4gICAgfVxuICAgIHRvRXJyb3JNZXNzYWdlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tZXNzYWdlO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBNaXNzaW5nTG9va3VwVmFsdWVFcnJvckNvZGUgZXh0ZW5kcyBFcnJvckNvZGUge1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ01pc3NpbmdMb29rdXBWYWx1ZUVycm9yQ29kZSc7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBNaXNzaW5nTG9va3VwVmFsdWVFcnJvckNvZGUucHJvdG90eXBlKTtcbiAgICB9XG4gICAgdG9FcnJvck1lc3NhZ2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1lc3NhZ2U7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIERlcktleUxlbmd0aE1pc21hdGNoRXJyb3JDb2RlIGV4dGVuZHMgRXJyb3JDb2RlIHtcbiAgICBjb25zdHJ1Y3RvcihleHBlY3RlZExlbmd0aCwgYWN0dWFsTGVuZ3RoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZXhwZWN0ZWRMZW5ndGggPSBleHBlY3RlZExlbmd0aDtcbiAgICAgICAgdGhpcy5hY3R1YWxMZW5ndGggPSBhY3R1YWxMZW5ndGg7XG4gICAgICAgIHRoaXMubmFtZSA9ICdEZXJLZXlMZW5ndGhNaXNtYXRjaEVycm9yQ29kZSc7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBEZXJLZXlMZW5ndGhNaXNtYXRjaEVycm9yQ29kZS5wcm90b3R5cGUpO1xuICAgIH1cbiAgICB0b0Vycm9yTWVzc2FnZSgpIHtcbiAgICAgICAgcmV0dXJuIGBCTFMgREVSLWVuY29kZWQgcHVibGljIGtleSBtdXN0IGJlICR7dGhpcy5leHBlY3RlZExlbmd0aH0gYnl0ZXMgbG9uZywgYnV0IGlzICR7dGhpcy5hY3R1YWxMZW5ndGh9IGJ5dGVzIGxvbmdgO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBEZXJQcmVmaXhNaXNtYXRjaEVycm9yQ29kZSBleHRlbmRzIEVycm9yQ29kZSB7XG4gICAgY29uc3RydWN0b3IoZXhwZWN0ZWRQcmVmaXgsIGFjdHVhbFByZWZpeCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmV4cGVjdGVkUHJlZml4ID0gZXhwZWN0ZWRQcmVmaXg7XG4gICAgICAgIHRoaXMuYWN0dWFsUHJlZml4ID0gYWN0dWFsUHJlZml4O1xuICAgICAgICB0aGlzLm5hbWUgPSAnRGVyUHJlZml4TWlzbWF0Y2hFcnJvckNvZGUnO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgRGVyUHJlZml4TWlzbWF0Y2hFcnJvckNvZGUucHJvdG90eXBlKTtcbiAgICB9XG4gICAgdG9FcnJvck1lc3NhZ2UoKSB7XG4gICAgICAgIHJldHVybiBgQkxTIERFUi1lbmNvZGVkIHB1YmxpYyBrZXkgaXMgaW52YWxpZC4gRXhwZWN0ZWQgdGhlIGZvbGxvd2luZyBwcmVmaXg6ICR7Ynl0ZXNUb0hleCh0aGlzLmV4cGVjdGVkUHJlZml4KX0sIGJ1dCBnb3QgJHtieXRlc1RvSGV4KHRoaXMuYWN0dWFsUHJlZml4KX1gO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBEZXJEZWNvZGVMZW5ndGhNaXNtYXRjaEVycm9yQ29kZSBleHRlbmRzIEVycm9yQ29kZSB7XG4gICAgY29uc3RydWN0b3IoZXhwZWN0ZWRMZW5ndGgsIGFjdHVhbExlbmd0aCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmV4cGVjdGVkTGVuZ3RoID0gZXhwZWN0ZWRMZW5ndGg7XG4gICAgICAgIHRoaXMuYWN0dWFsTGVuZ3RoID0gYWN0dWFsTGVuZ3RoO1xuICAgICAgICB0aGlzLm5hbWUgPSAnRGVyRGVjb2RlTGVuZ3RoTWlzbWF0Y2hFcnJvckNvZGUnO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgRGVyRGVjb2RlTGVuZ3RoTWlzbWF0Y2hFcnJvckNvZGUucHJvdG90eXBlKTtcbiAgICB9XG4gICAgdG9FcnJvck1lc3NhZ2UoKSB7XG4gICAgICAgIHJldHVybiBgREVSIHBheWxvYWQgbWlzbWF0Y2g6IEV4cGVjdGVkIGxlbmd0aCAke3RoaXMuZXhwZWN0ZWRMZW5ndGh9LCBhY3R1YWwgbGVuZ3RoOiAke3RoaXMuYWN0dWFsTGVuZ3RofWA7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIERlckRlY29kZUVycm9yQ29kZSBleHRlbmRzIEVycm9yQ29kZSB7XG4gICAgY29uc3RydWN0b3IoZXJyb3IpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5lcnJvciA9IGVycm9yO1xuICAgICAgICB0aGlzLm5hbWUgPSAnRGVyRGVjb2RlRXJyb3JDb2RlJztcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIERlckRlY29kZUVycm9yQ29kZS5wcm90b3R5cGUpO1xuICAgIH1cbiAgICB0b0Vycm9yTWVzc2FnZSgpIHtcbiAgICAgICAgcmV0dXJuIGBGYWlsZWQgdG8gZGVjb2RlIERFUjogJHt0aGlzLmVycm9yfWA7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIERlckVuY29kZUVycm9yQ29kZSBleHRlbmRzIEVycm9yQ29kZSB7XG4gICAgY29uc3RydWN0b3IoZXJyb3IpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5lcnJvciA9IGVycm9yO1xuICAgICAgICB0aGlzLm5hbWUgPSAnRGVyRW5jb2RlRXJyb3JDb2RlJztcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIERlckVuY29kZUVycm9yQ29kZS5wcm90b3R5cGUpO1xuICAgIH1cbiAgICB0b0Vycm9yTWVzc2FnZSgpIHtcbiAgICAgICAgcmV0dXJuIGBGYWlsZWQgdG8gZW5jb2RlIERFUjogJHt0aGlzLmVycm9yfWA7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIENib3JEZWNvZGVFcnJvckNvZGUgZXh0ZW5kcyBFcnJvckNvZGUge1xuICAgIGNvbnN0cnVjdG9yKGVycm9yLCBpbnB1dCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmVycm9yID0gZXJyb3I7XG4gICAgICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgICAgICAgdGhpcy5uYW1lID0gJ0Nib3JEZWNvZGVFcnJvckNvZGUnO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgQ2JvckRlY29kZUVycm9yQ29kZS5wcm90b3R5cGUpO1xuICAgIH1cbiAgICB0b0Vycm9yTWVzc2FnZSgpIHtcbiAgICAgICAgcmV0dXJuIGBGYWlsZWQgdG8gZGVjb2RlIENCT1I6ICR7Zm9ybWF0VW5rbm93bkVycm9yKHRoaXMuZXJyb3IpfSwgaW5wdXQ6ICR7Ynl0ZXNUb0hleCh0aGlzLmlucHV0KX1gO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBDYm9yRW5jb2RlRXJyb3JDb2RlIGV4dGVuZHMgRXJyb3JDb2RlIHtcbiAgICBjb25zdHJ1Y3RvcihlcnJvciwgdmFsdWUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5lcnJvciA9IGVycm9yO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMubmFtZSA9ICdDYm9yRW5jb2RlRXJyb3JDb2RlJztcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIENib3JFbmNvZGVFcnJvckNvZGUucHJvdG90eXBlKTtcbiAgICB9XG4gICAgdG9FcnJvck1lc3NhZ2UoKSB7XG4gICAgICAgIHJldHVybiBgRmFpbGVkIHRvIGVuY29kZSBDQk9SOiAke2Zvcm1hdFVua25vd25FcnJvcih0aGlzLmVycm9yKX0sIGlucHV0OiAke3RoaXMudmFsdWV9YDtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgSGV4RGVjb2RlRXJyb3JDb2RlIGV4dGVuZHMgRXJyb3JDb2RlIHtcbiAgICBjb25zdHJ1Y3RvcihlcnJvcikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmVycm9yID0gZXJyb3I7XG4gICAgICAgIHRoaXMubmFtZSA9ICdIZXhEZWNvZGVFcnJvckNvZGUnO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgSGV4RGVjb2RlRXJyb3JDb2RlLnByb3RvdHlwZSk7XG4gICAgfVxuICAgIHRvRXJyb3JNZXNzYWdlKCkge1xuICAgICAgICByZXR1cm4gYEZhaWxlZCB0byBkZWNvZGUgaGV4OiAke3RoaXMuZXJyb3J9YDtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgVGltZW91dFdhaXRpbmdGb3JSZXNwb25zZUVycm9yQ29kZSBleHRlbmRzIEVycm9yQ29kZSB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgcmVxdWVzdElkLCBzdGF0dXMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgdGhpcy5yZXF1ZXN0SWQgPSByZXF1ZXN0SWQ7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzO1xuICAgICAgICB0aGlzLm5hbWUgPSAnVGltZW91dFdhaXRpbmdGb3JSZXNwb25zZUVycm9yQ29kZSc7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBUaW1lb3V0V2FpdGluZ0ZvclJlc3BvbnNlRXJyb3JDb2RlLnByb3RvdHlwZSk7XG4gICAgfVxuICAgIHRvRXJyb3JNZXNzYWdlKCkge1xuICAgICAgICBsZXQgZXJyb3JNZXNzYWdlID0gYCR7dGhpcy5tZXNzYWdlfVxcbmA7XG4gICAgICAgIGlmICh0aGlzLnJlcXVlc3RJZCkge1xuICAgICAgICAgICAgZXJyb3JNZXNzYWdlICs9IGAgIFJlcXVlc3QgSUQ6ICR7Ynl0ZXNUb0hleCh0aGlzLnJlcXVlc3RJZCl9XFxuYDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zdGF0dXMpIHtcbiAgICAgICAgICAgIGVycm9yTWVzc2FnZSArPSBgICBSZXF1ZXN0IHN0YXR1czogJHt0aGlzLnN0YXR1c31cXG5gO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlcnJvck1lc3NhZ2U7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIENlcnRpZmljYXRlT3V0ZGF0ZWRFcnJvckNvZGUgZXh0ZW5kcyBFcnJvckNvZGUge1xuICAgIGNvbnN0cnVjdG9yKG1heEluZ3Jlc3NFeHBpcnlJbk1pbnV0ZXMsIHJlcXVlc3RJZCwgcmV0cnlUaW1lcykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm1heEluZ3Jlc3NFeHBpcnlJbk1pbnV0ZXMgPSBtYXhJbmdyZXNzRXhwaXJ5SW5NaW51dGVzO1xuICAgICAgICB0aGlzLnJlcXVlc3RJZCA9IHJlcXVlc3RJZDtcbiAgICAgICAgdGhpcy5yZXRyeVRpbWVzID0gcmV0cnlUaW1lcztcbiAgICAgICAgdGhpcy5uYW1lID0gJ0NlcnRpZmljYXRlT3V0ZGF0ZWRFcnJvckNvZGUnO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgQ2VydGlmaWNhdGVPdXRkYXRlZEVycm9yQ29kZS5wcm90b3R5cGUpO1xuICAgIH1cbiAgICB0b0Vycm9yTWVzc2FnZSgpIHtcbiAgICAgICAgbGV0IGVycm9yTWVzc2FnZSA9IGBDZXJ0aWZpY2F0ZSBpcyBzdGFsZSAob3ZlciAke3RoaXMubWF4SW5ncmVzc0V4cGlyeUluTWludXRlc30gbWludXRlcykuIElzIHRoZSBjb21wdXRlcidzIGNsb2NrIHN5bmNocm9uaXplZD9cXG4gIFJlcXVlc3QgSUQ6ICR7Ynl0ZXNUb0hleCh0aGlzLnJlcXVlc3RJZCl9XFxuYDtcbiAgICAgICAgaWYgKHRoaXMucmV0cnlUaW1lcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBlcnJvck1lc3NhZ2UgKz0gYCAgUmV0cmllZCAke3RoaXMucmV0cnlUaW1lc30gdGltZXMuYDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXJyb3JNZXNzYWdlO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBDZXJ0aWZpZWRSZWplY3RFcnJvckNvZGUgZXh0ZW5kcyBFcnJvckNvZGUge1xuICAgIGNvbnN0cnVjdG9yKHJlcXVlc3RJZCwgcmVqZWN0Q29kZSwgcmVqZWN0TWVzc2FnZSwgcmVqZWN0RXJyb3JDb2RlKSB7XG4gICAgICAgIHN1cGVyKHRydWUpO1xuICAgICAgICB0aGlzLnJlcXVlc3RJZCA9IHJlcXVlc3RJZDtcbiAgICAgICAgdGhpcy5yZWplY3RDb2RlID0gcmVqZWN0Q29kZTtcbiAgICAgICAgdGhpcy5yZWplY3RNZXNzYWdlID0gcmVqZWN0TWVzc2FnZTtcbiAgICAgICAgdGhpcy5yZWplY3RFcnJvckNvZGUgPSByZWplY3RFcnJvckNvZGU7XG4gICAgICAgIHRoaXMubmFtZSA9ICdDZXJ0aWZpZWRSZWplY3RFcnJvckNvZGUnO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgQ2VydGlmaWVkUmVqZWN0RXJyb3JDb2RlLnByb3RvdHlwZSk7XG4gICAgfVxuICAgIHRvRXJyb3JNZXNzYWdlKCkge1xuICAgICAgICByZXR1cm4gKGBUaGUgcmVwbGljYSByZXR1cm5lZCBhIHJlamVjdGlvbiBlcnJvcjpcXG5gICtcbiAgICAgICAgICAgIGAgIFJlcXVlc3QgSUQ6ICR7Ynl0ZXNUb0hleCh0aGlzLnJlcXVlc3RJZCl9XFxuYCArXG4gICAgICAgICAgICBgICBSZWplY3QgY29kZTogJHt0aGlzLnJlamVjdENvZGV9XFxuYCArXG4gICAgICAgICAgICBgICBSZWplY3QgdGV4dDogJHt0aGlzLnJlamVjdE1lc3NhZ2V9XFxuYCArXG4gICAgICAgICAgICBgICBFcnJvciBjb2RlOiAke3RoaXMucmVqZWN0RXJyb3JDb2RlfVxcbmApO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBVbmNlcnRpZmllZFJlamVjdEVycm9yQ29kZSBleHRlbmRzIEVycm9yQ29kZSB7XG4gICAgY29uc3RydWN0b3IocmVxdWVzdElkLCByZWplY3RDb2RlLCByZWplY3RNZXNzYWdlLCByZWplY3RFcnJvckNvZGUsIHNpZ25hdHVyZXMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5yZXF1ZXN0SWQgPSByZXF1ZXN0SWQ7XG4gICAgICAgIHRoaXMucmVqZWN0Q29kZSA9IHJlamVjdENvZGU7XG4gICAgICAgIHRoaXMucmVqZWN0TWVzc2FnZSA9IHJlamVjdE1lc3NhZ2U7XG4gICAgICAgIHRoaXMucmVqZWN0RXJyb3JDb2RlID0gcmVqZWN0RXJyb3JDb2RlO1xuICAgICAgICB0aGlzLnNpZ25hdHVyZXMgPSBzaWduYXR1cmVzO1xuICAgICAgICB0aGlzLm5hbWUgPSAnVW5jZXJ0aWZpZWRSZWplY3RFcnJvckNvZGUnO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgVW5jZXJ0aWZpZWRSZWplY3RFcnJvckNvZGUucHJvdG90eXBlKTtcbiAgICB9XG4gICAgdG9FcnJvck1lc3NhZ2UoKSB7XG4gICAgICAgIHJldHVybiAoYFRoZSByZXBsaWNhIHJldHVybmVkIGEgcmVqZWN0aW9uIGVycm9yOlxcbmAgK1xuICAgICAgICAgICAgYCAgUmVxdWVzdCBJRDogJHtieXRlc1RvSGV4KHRoaXMucmVxdWVzdElkKX1cXG5gICtcbiAgICAgICAgICAgIGAgIFJlamVjdCBjb2RlOiAke3RoaXMucmVqZWN0Q29kZX1cXG5gICtcbiAgICAgICAgICAgIGAgIFJlamVjdCB0ZXh0OiAke3RoaXMucmVqZWN0TWVzc2FnZX1cXG5gICtcbiAgICAgICAgICAgIGAgIEVycm9yIGNvZGU6ICR7dGhpcy5yZWplY3RFcnJvckNvZGV9XFxuYCk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFVuY2VydGlmaWVkUmVqZWN0VXBkYXRlRXJyb3JDb2RlIGV4dGVuZHMgRXJyb3JDb2RlIHtcbiAgICBjb25zdHJ1Y3RvcihyZXF1ZXN0SWQsIHJlamVjdENvZGUsIHJlamVjdE1lc3NhZ2UsIHJlamVjdEVycm9yQ29kZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnJlcXVlc3RJZCA9IHJlcXVlc3RJZDtcbiAgICAgICAgdGhpcy5yZWplY3RDb2RlID0gcmVqZWN0Q29kZTtcbiAgICAgICAgdGhpcy5yZWplY3RNZXNzYWdlID0gcmVqZWN0TWVzc2FnZTtcbiAgICAgICAgdGhpcy5yZWplY3RFcnJvckNvZGUgPSByZWplY3RFcnJvckNvZGU7XG4gICAgICAgIHRoaXMubmFtZSA9ICdVbmNlcnRpZmllZFJlamVjdFVwZGF0ZUVycm9yQ29kZSc7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBVbmNlcnRpZmllZFJlamVjdFVwZGF0ZUVycm9yQ29kZS5wcm90b3R5cGUpO1xuICAgIH1cbiAgICB0b0Vycm9yTWVzc2FnZSgpIHtcbiAgICAgICAgcmV0dXJuIChgVGhlIHJlcGxpY2EgcmV0dXJuZWQgYSByZWplY3Rpb24gZXJyb3I6XFxuYCArXG4gICAgICAgICAgICBgICBSZXF1ZXN0IElEOiAke2J5dGVzVG9IZXgodGhpcy5yZXF1ZXN0SWQpfVxcbmAgK1xuICAgICAgICAgICAgYCAgUmVqZWN0IGNvZGU6ICR7dGhpcy5yZWplY3RDb2RlfVxcbmAgK1xuICAgICAgICAgICAgYCAgUmVqZWN0IHRleHQ6ICR7dGhpcy5yZWplY3RNZXNzYWdlfVxcbmAgK1xuICAgICAgICAgICAgYCAgRXJyb3IgY29kZTogJHt0aGlzLnJlamVjdEVycm9yQ29kZX1cXG5gKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgUmVxdWVzdFN0YXR1c0RvbmVOb1JlcGx5RXJyb3JDb2RlIGV4dGVuZHMgRXJyb3JDb2RlIHtcbiAgICBjb25zdHJ1Y3RvcihyZXF1ZXN0SWQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5yZXF1ZXN0SWQgPSByZXF1ZXN0SWQ7XG4gICAgICAgIHRoaXMubmFtZSA9ICdSZXF1ZXN0U3RhdHVzRG9uZU5vUmVwbHlFcnJvckNvZGUnO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgUmVxdWVzdFN0YXR1c0RvbmVOb1JlcGx5RXJyb3JDb2RlLnByb3RvdHlwZSk7XG4gICAgfVxuICAgIHRvRXJyb3JNZXNzYWdlKCkge1xuICAgICAgICByZXR1cm4gKGBDYWxsIHdhcyBtYXJrZWQgYXMgZG9uZSBidXQgd2UgbmV2ZXIgc2F3IHRoZSByZXBseTpcXG5gICtcbiAgICAgICAgICAgIGAgIFJlcXVlc3QgSUQ6ICR7Ynl0ZXNUb0hleCh0aGlzLnJlcXVlc3RJZCl9XFxuYCk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIE1pc3NpbmdSb290S2V5RXJyb3JDb2RlIGV4dGVuZHMgRXJyb3JDb2RlIHtcbiAgICBjb25zdHJ1Y3RvcihzaG91bGRGZXRjaFJvb3RLZXkpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5zaG91bGRGZXRjaFJvb3RLZXkgPSBzaG91bGRGZXRjaFJvb3RLZXk7XG4gICAgICAgIHRoaXMubmFtZSA9ICdNaXNzaW5nUm9vdEtleUVycm9yQ29kZSc7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBNaXNzaW5nUm9vdEtleUVycm9yQ29kZS5wcm90b3R5cGUpO1xuICAgIH1cbiAgICB0b0Vycm9yTWVzc2FnZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuc2hvdWxkRmV0Y2hSb290S2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiAnQWdlbnQgaXMgbWlzc2luZyByb290IGtleSc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGBBZ2VudCBpcyBtaXNzaW5nIHJvb3Qga2V5IGFuZCB0aGUgc2hvdWxkRmV0Y2hSb290S2V5IHZhbHVlIGlzIHNldCB0byAke3RoaXMuc2hvdWxkRmV0Y2hSb290S2V5fS4gVGhlIHJvb3Qga2V5IHNob3VsZCBvbmx5IGJlIHVua25vd24gaWYgeW91IGFyZSBpbiBsb2NhbCBkZXZlbG9wbWVudC4gT3RoZXJ3aXNlIHlvdSBzaG91bGQgYXZvaWQgZmV0Y2hpbmcgYW5kIHVzZSB0aGUgZGVmYXVsdCBJQyBSb290IEtleSBvciB0aGUga25vd24gcm9vdCBrZXkgb2YgeW91ciBlbnZpcm9ubWVudC5gO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBIYXNoVmFsdWVFcnJvckNvZGUgZXh0ZW5kcyBFcnJvckNvZGUge1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ0hhc2hWYWx1ZUVycm9yQ29kZSc7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBIYXNoVmFsdWVFcnJvckNvZGUucHJvdG90eXBlKTtcbiAgICB9XG4gICAgdG9FcnJvck1lc3NhZ2UoKSB7XG4gICAgICAgIHJldHVybiBgQXR0ZW1wdCB0byBoYXNoIGEgdmFsdWUgb2YgdW5zdXBwb3J0ZWQgdHlwZTogJHt0aGlzLnZhbHVlfWA7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEh0dHBEZWZhdWx0RmV0Y2hFcnJvckNvZGUgZXh0ZW5kcyBFcnJvckNvZGUge1xuICAgIGNvbnN0cnVjdG9yKGVycm9yKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgdGhpcy5uYW1lID0gJ0h0dHBEZWZhdWx0RmV0Y2hFcnJvckNvZGUnO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgSHR0cERlZmF1bHRGZXRjaEVycm9yQ29kZS5wcm90b3R5cGUpO1xuICAgIH1cbiAgICB0b0Vycm9yTWVzc2FnZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3I7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIElkZW50aXR5SW52YWxpZEVycm9yQ29kZSBleHRlbmRzIEVycm9yQ29kZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubmFtZSA9ICdJZGVudGl0eUludmFsaWRFcnJvckNvZGUnO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgSWRlbnRpdHlJbnZhbGlkRXJyb3JDb2RlLnByb3RvdHlwZSk7XG4gICAgfVxuICAgIHRvRXJyb3JNZXNzYWdlKCkge1xuICAgICAgICByZXR1cm4gXCJUaGlzIGlkZW50aXR5IGhhcyBleHBpcmVkIGR1ZSB0aGlzIGFwcGxpY2F0aW9uJ3Mgc2VjdXJpdHkgcG9saWN5LiBQbGVhc2UgcmVmcmVzaCB5b3VyIGF1dGhlbnRpY2F0aW9uLlwiO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBJbmdyZXNzRXhwaXJ5SW52YWxpZEVycm9yQ29kZSBleHRlbmRzIEVycm9yQ29kZSB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgcHJvdmlkZWRJbmdyZXNzRXhwaXJ5SW5NaW51dGVzKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgIHRoaXMucHJvdmlkZWRJbmdyZXNzRXhwaXJ5SW5NaW51dGVzID0gcHJvdmlkZWRJbmdyZXNzRXhwaXJ5SW5NaW51dGVzO1xuICAgICAgICB0aGlzLm5hbWUgPSAnSW5ncmVzc0V4cGlyeUludmFsaWRFcnJvckNvZGUnO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgSW5ncmVzc0V4cGlyeUludmFsaWRFcnJvckNvZGUucHJvdG90eXBlKTtcbiAgICB9XG4gICAgdG9FcnJvck1lc3NhZ2UoKSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLm1lc3NhZ2V9LiBQcm92aWRlZCBpbmdyZXNzIGV4cGlyeSB0aW1lIGlzICR7dGhpcy5wcm92aWRlZEluZ3Jlc3NFeHBpcnlJbk1pbnV0ZXN9IG1pbnV0ZXMuYDtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgQ3JlYXRlSHR0cEFnZW50RXJyb3JDb2RlIGV4dGVuZHMgRXJyb3JDb2RlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ0NyZWF0ZUh0dHBBZ2VudEVycm9yQ29kZSc7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBDcmVhdGVIdHRwQWdlbnRFcnJvckNvZGUucHJvdG90eXBlKTtcbiAgICB9XG4gICAgdG9FcnJvck1lc3NhZ2UoKSB7XG4gICAgICAgIHJldHVybiAnRmFpbGVkIHRvIGNyZWF0ZSBhZ2VudCBmcm9tIHByb3ZpZGVkIGFnZW50JztcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgTWFsZm9ybWVkU2lnbmF0dXJlRXJyb3JDb2RlIGV4dGVuZHMgRXJyb3JDb2RlIHtcbiAgICBjb25zdHJ1Y3RvcihlcnJvcikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmVycm9yID0gZXJyb3I7XG4gICAgICAgIHRoaXMubmFtZSA9ICdNYWxmb3JtZWRTaWduYXR1cmVFcnJvckNvZGUnO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgTWFsZm9ybWVkU2lnbmF0dXJlRXJyb3JDb2RlLnByb3RvdHlwZSk7XG4gICAgfVxuICAgIHRvRXJyb3JNZXNzYWdlKCkge1xuICAgICAgICByZXR1cm4gYFF1ZXJ5IHJlc3BvbnNlIGNvbnRhaW5lZCBhIG1hbGZvcm1lZCBzaWduYXR1cmU6ICR7dGhpcy5lcnJvcn1gO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBNaXNzaW5nU2lnbmF0dXJlRXJyb3JDb2RlIGV4dGVuZHMgRXJyb3JDb2RlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ01pc3NpbmdTaWduYXR1cmVFcnJvckNvZGUnO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgTWlzc2luZ1NpZ25hdHVyZUVycm9yQ29kZS5wcm90b3R5cGUpO1xuICAgIH1cbiAgICB0b0Vycm9yTWVzc2FnZSgpIHtcbiAgICAgICAgcmV0dXJuICdRdWVyeSByZXNwb25zZSBkaWQgbm90IGNvbnRhaW4gYW55IG5vZGUgc2lnbmF0dXJlcyc7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIE1hbGZvcm1lZFB1YmxpY0tleUVycm9yQ29kZSBleHRlbmRzIEVycm9yQ29kZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubmFtZSA9ICdNYWxmb3JtZWRQdWJsaWNLZXlFcnJvckNvZGUnO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgTWFsZm9ybWVkUHVibGljS2V5RXJyb3JDb2RlLnByb3RvdHlwZSk7XG4gICAgfVxuICAgIHRvRXJyb3JNZXNzYWdlKCkge1xuICAgICAgICByZXR1cm4gJ1JlYWQgc3RhdGUgcmVzcG9uc2UgY29udGFpbmVkIGEgbWFsZm9ybWVkIHB1YmxpYyBrZXknO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBRdWVyeVNpZ25hdHVyZVZlcmlmaWNhdGlvbkZhaWxlZEVycm9yQ29kZSBleHRlbmRzIEVycm9yQ29kZSB7XG4gICAgY29uc3RydWN0b3Iobm9kZUlkKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubm9kZUlkID0gbm9kZUlkO1xuICAgICAgICB0aGlzLm5hbWUgPSAnUXVlcnlTaWduYXR1cmVWZXJpZmljYXRpb25GYWlsZWRFcnJvckNvZGUnO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgUXVlcnlTaWduYXR1cmVWZXJpZmljYXRpb25GYWlsZWRFcnJvckNvZGUucHJvdG90eXBlKTtcbiAgICB9XG4gICAgdG9FcnJvck1lc3NhZ2UoKSB7XG4gICAgICAgIHJldHVybiBgUXVlcnkgc2lnbmF0dXJlIHZlcmlmaWNhdGlvbiBmYWlsZWQuIE5vZGUgSUQ6ICR7dGhpcy5ub2RlSWR9YDtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgVW5leHBlY3RlZEVycm9yQ29kZSBleHRlbmRzIEVycm9yQ29kZSB7XG4gICAgY29uc3RydWN0b3IoZXJyb3IpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5lcnJvciA9IGVycm9yO1xuICAgICAgICB0aGlzLm5hbWUgPSAnVW5leHBlY3RlZEVycm9yQ29kZSc7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBVbmV4cGVjdGVkRXJyb3JDb2RlLnByb3RvdHlwZSk7XG4gICAgfVxuICAgIHRvRXJyb3JNZXNzYWdlKCkge1xuICAgICAgICByZXR1cm4gYFVuZXhwZWN0ZWQgZXJyb3I6ICR7Zm9ybWF0VW5rbm93bkVycm9yKHRoaXMuZXJyb3IpfWA7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEhhc2hUcmVlRGVjb2RlRXJyb3JDb2RlIGV4dGVuZHMgRXJyb3JDb2RlIHtcbiAgICBjb25zdHJ1Y3RvcihlcnJvcikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmVycm9yID0gZXJyb3I7XG4gICAgICAgIHRoaXMubmFtZSA9ICdIYXNoVHJlZURlY29kZUVycm9yQ29kZSc7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBIYXNoVHJlZURlY29kZUVycm9yQ29kZS5wcm90b3R5cGUpO1xuICAgIH1cbiAgICB0b0Vycm9yTWVzc2FnZSgpIHtcbiAgICAgICAgcmV0dXJuIGBGYWlsZWQgdG8gZGVjb2RlIGNlcnRpZmljYXRlOiAke3RoaXMuZXJyb3J9YDtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgSHR0cEVycm9yQ29kZSBleHRlbmRzIEVycm9yQ29kZSB7XG4gICAgY29uc3RydWN0b3Ioc3RhdHVzLCBzdGF0dXNUZXh0LCBoZWFkZXJzLCBib2R5VGV4dCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cztcbiAgICAgICAgdGhpcy5zdGF0dXNUZXh0ID0gc3RhdHVzVGV4dDtcbiAgICAgICAgdGhpcy5oZWFkZXJzID0gaGVhZGVycztcbiAgICAgICAgdGhpcy5ib2R5VGV4dCA9IGJvZHlUZXh0O1xuICAgICAgICB0aGlzLm5hbWUgPSAnSHR0cEVycm9yQ29kZSc7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBIdHRwRXJyb3JDb2RlLnByb3RvdHlwZSk7XG4gICAgfVxuICAgIHRvRXJyb3JNZXNzYWdlKCkge1xuICAgICAgICBsZXQgZXJyb3JNZXNzYWdlID0gJ0hUVFAgcmVxdWVzdCBmYWlsZWQ6XFxuJyArXG4gICAgICAgICAgICBgICBTdGF0dXM6ICR7dGhpcy5zdGF0dXN9ICgke3RoaXMuc3RhdHVzVGV4dH0pXFxuYCArXG4gICAgICAgICAgICBgICBIZWFkZXJzOiAke0pTT04uc3RyaW5naWZ5KHRoaXMuaGVhZGVycyl9XFxuYDtcbiAgICAgICAgaWYgKHRoaXMuYm9keVRleHQpIHtcbiAgICAgICAgICAgIGVycm9yTWVzc2FnZSArPSBgICBCb2R5OiAke3RoaXMuYm9keVRleHR9XFxuYDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXJyb3JNZXNzYWdlO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBIdHRwVjNBcGlOb3RTdXBwb3J0ZWRFcnJvckNvZGUgZXh0ZW5kcyBFcnJvckNvZGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm5hbWUgPSAnSHR0cFYzQXBpTm90U3VwcG9ydGVkRXJyb3JDb2RlJztcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIEh0dHBWM0FwaU5vdFN1cHBvcnRlZEVycm9yQ29kZS5wcm90b3R5cGUpO1xuICAgIH1cbiAgICB0b0Vycm9yTWVzc2FnZSgpIHtcbiAgICAgICAgcmV0dXJuICdIVFRQIHJlcXVlc3QgZmFpbGVkOiB2MyBBUEkgaXMgbm90IHN1cHBvcnRlZCc7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEh0dHBGZXRjaEVycm9yQ29kZSBleHRlbmRzIEVycm9yQ29kZSB7XG4gICAgY29uc3RydWN0b3IoZXJyb3IpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5lcnJvciA9IGVycm9yO1xuICAgICAgICB0aGlzLm5hbWUgPSAnSHR0cEZldGNoRXJyb3JDb2RlJztcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIEh0dHBGZXRjaEVycm9yQ29kZS5wcm90b3R5cGUpO1xuICAgIH1cbiAgICB0b0Vycm9yTWVzc2FnZSgpIHtcbiAgICAgICAgcmV0dXJuIGBGYWlsZWQgdG8gZmV0Y2ggSFRUUCByZXF1ZXN0OiAke2Zvcm1hdFVua25vd25FcnJvcih0aGlzLmVycm9yKX1gO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBNaXNzaW5nQ2FuaXN0ZXJJZEVycm9yQ29kZSBleHRlbmRzIEVycm9yQ29kZSB7XG4gICAgY29uc3RydWN0b3IocmVjZWl2ZWRDYW5pc3RlcklkKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMucmVjZWl2ZWRDYW5pc3RlcklkID0gcmVjZWl2ZWRDYW5pc3RlcklkO1xuICAgICAgICB0aGlzLm5hbWUgPSAnTWlzc2luZ0NhbmlzdGVySWRFcnJvckNvZGUnO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgTWlzc2luZ0NhbmlzdGVySWRFcnJvckNvZGUucHJvdG90eXBlKTtcbiAgICB9XG4gICAgdG9FcnJvck1lc3NhZ2UoKSB7XG4gICAgICAgIHJldHVybiBgQ2FuaXN0ZXIgSUQgaXMgcmVxdWlyZWQsIGJ1dCByZWNlaXZlZCAke3R5cGVvZiB0aGlzLnJlY2VpdmVkQ2FuaXN0ZXJJZH0gaW5zdGVhZC4gSWYgeW91IGFyZSB1c2luZyBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlZCBkZWNsYXJhdGlvbnMsIHRoaXMgbWF5IGJlIGJlY2F1c2UgeW91ciBhcHBsaWNhdGlvbiBpcyBub3Qgc2V0dGluZyB0aGUgY2FuaXN0ZXIgSUQgaW4gcHJvY2Vzcy5lbnYgY29ycmVjdGx5LmA7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEludmFsaWRSZWFkU3RhdGVSZXF1ZXN0RXJyb3JDb2RlIGV4dGVuZHMgRXJyb3JDb2RlIHtcbiAgICBjb25zdHJ1Y3RvcihyZXF1ZXN0KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMucmVxdWVzdCA9IHJlcXVlc3Q7XG4gICAgICAgIHRoaXMubmFtZSA9ICdJbnZhbGlkUmVhZFN0YXRlUmVxdWVzdEVycm9yQ29kZSc7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBJbnZhbGlkUmVhZFN0YXRlUmVxdWVzdEVycm9yQ29kZS5wcm90b3R5cGUpO1xuICAgIH1cbiAgICB0b0Vycm9yTWVzc2FnZSgpIHtcbiAgICAgICAgcmV0dXJuIGBJbnZhbGlkIHJlYWQgc3RhdGUgcmVxdWVzdDogJHt0aGlzLnJlcXVlc3R9YDtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgRXhwaXJ5SnNvbkRlc2VyaWFsaXplRXJyb3JDb2RlIGV4dGVuZHMgRXJyb3JDb2RlIHtcbiAgICBjb25zdHJ1Y3RvcihlcnJvcikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmVycm9yID0gZXJyb3I7XG4gICAgICAgIHRoaXMubmFtZSA9ICdFeHBpcnlKc29uRGVzZXJpYWxpemVFcnJvckNvZGUnO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgRXhwaXJ5SnNvbkRlc2VyaWFsaXplRXJyb3JDb2RlLnByb3RvdHlwZSk7XG4gICAgfVxuICAgIHRvRXJyb3JNZXNzYWdlKCkge1xuICAgICAgICByZXR1cm4gYEZhaWxlZCB0byBkZXNlcmlhbGl6ZSBleHBpcnk6ICR7dGhpcy5lcnJvcn1gO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZvcm1hdFVua25vd25FcnJvcihlcnJvcikge1xuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHJldHVybiBlcnJvci5zdGFjayA/PyBlcnJvci5tZXNzYWdlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoZXJyb3IpO1xuICAgIH1cbiAgICBjYXRjaCB7XG4gICAgICAgIHJldHVybiBTdHJpbmcoZXJyb3IpO1xuICAgIH1cbn1cbi8qKlxuICogU3BlY2lhbCBlcnJvciB1c2VkIHRvIGluZGljYXRlIHRoYXQgYSBjb2RlIHBhdGggaXMgdW5yZWFjaGFibGUuXG4gKlxuICogRm9yIGludGVybmFsIHVzZSBvbmx5LlxuICovXG5leHBvcnQgY29uc3QgVU5SRUFDSEFCTEVfRVJST1IgPSBuZXcgRXJyb3IoJ3VucmVhY2hhYmxlJyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lcnJvcnMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/errors.js\n");

/***/ }),

/***/ "(ssr)/../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/observable.js":
/*!*******************************************************************************!*\
  !*** ../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/observable.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Observable: () => (/* binding */ Observable),\n/* harmony export */   ObservableLog: () => (/* binding */ ObservableLog)\n/* harmony export */ });\nclass Observable {\n    constructor() {\n        this.observers = [];\n    }\n    subscribe(func) {\n        this.observers.push(func);\n    }\n    unsubscribe(func) {\n        this.observers = this.observers.filter(observer => observer !== func);\n    }\n    notify(data, ...rest) {\n        this.observers.forEach(observer => observer(data, ...rest));\n    }\n}\nclass ObservableLog extends Observable {\n    constructor() {\n        super();\n    }\n    print(message, ...rest) {\n        this.notify({ message, level: 'info' }, ...rest);\n    }\n    warn(message, ...rest) {\n        this.notify({ message, level: 'warn' }, ...rest);\n    }\n    error(message, error, ...rest) {\n        this.notify({ message, level: 'error', error }, ...rest);\n    }\n}\n//# sourceMappingURL=observable.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vcGFja2FnZXMvc2RrLWpzL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL29ic2VydmFibGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix3QkFBd0I7QUFDOUM7QUFDQTtBQUNBLHNCQUFzQix3QkFBd0I7QUFDOUM7QUFDQTtBQUNBLHNCQUFzQixnQ0FBZ0M7QUFDdEQ7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGlxdWJlL29wcy1jb25zb2xlLy4uLy4uL3BhY2thZ2VzL3Nkay1qcy9ub2RlX21vZHVsZXMvQGRmaW5pdHkvYWdlbnQvbGliL2VzbS9vYnNlcnZhYmxlLmpzP2I3ZWEiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNsYXNzIE9ic2VydmFibGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLm9ic2VydmVycyA9IFtdO1xuICAgIH1cbiAgICBzdWJzY3JpYmUoZnVuYykge1xuICAgICAgICB0aGlzLm9ic2VydmVycy5wdXNoKGZ1bmMpO1xuICAgIH1cbiAgICB1bnN1YnNjcmliZShmdW5jKSB7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXJzID0gdGhpcy5vYnNlcnZlcnMuZmlsdGVyKG9ic2VydmVyID0+IG9ic2VydmVyICE9PSBmdW5jKTtcbiAgICB9XG4gICAgbm90aWZ5KGRhdGEsIC4uLnJlc3QpIHtcbiAgICAgICAgdGhpcy5vYnNlcnZlcnMuZm9yRWFjaChvYnNlcnZlciA9PiBvYnNlcnZlcihkYXRhLCAuLi5yZXN0KSk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIE9ic2VydmFibGVMb2cgZXh0ZW5kcyBPYnNlcnZhYmxlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICB9XG4gICAgcHJpbnQobWVzc2FnZSwgLi4ucmVzdCkge1xuICAgICAgICB0aGlzLm5vdGlmeSh7IG1lc3NhZ2UsIGxldmVsOiAnaW5mbycgfSwgLi4ucmVzdCk7XG4gICAgfVxuICAgIHdhcm4obWVzc2FnZSwgLi4ucmVzdCkge1xuICAgICAgICB0aGlzLm5vdGlmeSh7IG1lc3NhZ2UsIGxldmVsOiAnd2FybicgfSwgLi4ucmVzdCk7XG4gICAgfVxuICAgIGVycm9yKG1lc3NhZ2UsIGVycm9yLCAuLi5yZXN0KSB7XG4gICAgICAgIHRoaXMubm90aWZ5KHsgbWVzc2FnZSwgbGV2ZWw6ICdlcnJvcicsIGVycm9yIH0sIC4uLnJlc3QpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9ic2VydmFibGUuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/observable.js\n");

/***/ }),

/***/ "(ssr)/../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/polling/backoff.js":
/*!************************************************************************************!*\
  !*** ../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/polling/backoff.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ExponentialBackoff: () => (/* binding */ ExponentialBackoff),\n/* harmony export */   exponentialBackoff: () => (/* binding */ exponentialBackoff)\n/* harmony export */ });\nconst RANDOMIZATION_FACTOR = 0.5;\nconst MULTIPLIER = 1.5;\nconst INITIAL_INTERVAL_MSEC = 500;\nconst MAX_INTERVAL_MSEC = 60_000;\nconst MAX_ELAPSED_TIME_MSEC = 900_000;\nconst MAX_ITERATIONS = 10;\n/**\n * Exponential backoff strategy.\n */\nclass ExponentialBackoff {\n    #currentInterval;\n    #randomizationFactor;\n    #multiplier;\n    #maxInterval;\n    #startTime;\n    #maxElapsedTime;\n    #maxIterations;\n    #date;\n    #count = 0;\n    static { this.default = {\n        initialInterval: INITIAL_INTERVAL_MSEC,\n        randomizationFactor: RANDOMIZATION_FACTOR,\n        multiplier: MULTIPLIER,\n        maxInterval: MAX_INTERVAL_MSEC,\n        // 1 minute\n        maxElapsedTime: MAX_ELAPSED_TIME_MSEC,\n        maxIterations: MAX_ITERATIONS,\n        date: Date,\n    }; }\n    constructor(options = ExponentialBackoff.default) {\n        const { initialInterval = INITIAL_INTERVAL_MSEC, randomizationFactor = RANDOMIZATION_FACTOR, multiplier = MULTIPLIER, maxInterval = MAX_INTERVAL_MSEC, maxElapsedTime = MAX_ELAPSED_TIME_MSEC, maxIterations = MAX_ITERATIONS, date = Date, } = options;\n        this.#currentInterval = initialInterval;\n        this.#randomizationFactor = randomizationFactor;\n        this.#multiplier = multiplier;\n        this.#maxInterval = maxInterval;\n        this.#date = date;\n        this.#startTime = date.now();\n        this.#maxElapsedTime = maxElapsedTime;\n        this.#maxIterations = maxIterations;\n    }\n    get ellapsedTimeInMsec() {\n        return this.#date.now() - this.#startTime;\n    }\n    get currentInterval() {\n        return this.#currentInterval;\n    }\n    get count() {\n        return this.#count;\n    }\n    get randomValueFromInterval() {\n        const delta = this.#randomizationFactor * this.#currentInterval;\n        const min = this.#currentInterval - delta;\n        const max = this.#currentInterval + delta;\n        return Math.random() * (max - min) + min;\n    }\n    incrementCurrentInterval() {\n        this.#currentInterval = Math.min(this.#currentInterval * this.#multiplier, this.#maxInterval);\n        this.#count++;\n        return this.#currentInterval;\n    }\n    next() {\n        if (this.ellapsedTimeInMsec >= this.#maxElapsedTime || this.#count >= this.#maxIterations) {\n            return null;\n        }\n        else {\n            this.incrementCurrentInterval();\n            return this.randomValueFromInterval;\n        }\n    }\n}\n/**\n * Utility function to create an exponential backoff iterator.\n * @param options - for the exponential backoff\n * @returns an iterator that yields the next delay in the exponential backoff\n * @yields the next delay in the exponential backoff\n */\nfunction* exponentialBackoff(options = ExponentialBackoff.default) {\n    const backoff = new ExponentialBackoff(options);\n    let next = backoff.next();\n    while (next) {\n        yield next;\n        next = backoff.next();\n    }\n}\n//# sourceMappingURL=backoff.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vcGFja2FnZXMvc2RrLWpzL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL3BvbGxpbmcvYmFja29mZi5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHNPQUFzTztBQUN0UDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AaXF1YmUvb3BzLWNvbnNvbGUvLi4vLi4vcGFja2FnZXMvc2RrLWpzL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL3BvbGxpbmcvYmFja29mZi5qcz83ZWFkIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IFJBTkRPTUlaQVRJT05fRkFDVE9SID0gMC41O1xuY29uc3QgTVVMVElQTElFUiA9IDEuNTtcbmNvbnN0IElOSVRJQUxfSU5URVJWQUxfTVNFQyA9IDUwMDtcbmNvbnN0IE1BWF9JTlRFUlZBTF9NU0VDID0gNjBfMDAwO1xuY29uc3QgTUFYX0VMQVBTRURfVElNRV9NU0VDID0gOTAwXzAwMDtcbmNvbnN0IE1BWF9JVEVSQVRJT05TID0gMTA7XG4vKipcbiAqIEV4cG9uZW50aWFsIGJhY2tvZmYgc3RyYXRlZ3kuXG4gKi9cbmV4cG9ydCBjbGFzcyBFeHBvbmVudGlhbEJhY2tvZmYge1xuICAgICNjdXJyZW50SW50ZXJ2YWw7XG4gICAgI3JhbmRvbWl6YXRpb25GYWN0b3I7XG4gICAgI211bHRpcGxpZXI7XG4gICAgI21heEludGVydmFsO1xuICAgICNzdGFydFRpbWU7XG4gICAgI21heEVsYXBzZWRUaW1lO1xuICAgICNtYXhJdGVyYXRpb25zO1xuICAgICNkYXRlO1xuICAgICNjb3VudCA9IDA7XG4gICAgc3RhdGljIHsgdGhpcy5kZWZhdWx0ID0ge1xuICAgICAgICBpbml0aWFsSW50ZXJ2YWw6IElOSVRJQUxfSU5URVJWQUxfTVNFQyxcbiAgICAgICAgcmFuZG9taXphdGlvbkZhY3RvcjogUkFORE9NSVpBVElPTl9GQUNUT1IsXG4gICAgICAgIG11bHRpcGxpZXI6IE1VTFRJUExJRVIsXG4gICAgICAgIG1heEludGVydmFsOiBNQVhfSU5URVJWQUxfTVNFQyxcbiAgICAgICAgLy8gMSBtaW51dGVcbiAgICAgICAgbWF4RWxhcHNlZFRpbWU6IE1BWF9FTEFQU0VEX1RJTUVfTVNFQyxcbiAgICAgICAgbWF4SXRlcmF0aW9uczogTUFYX0lURVJBVElPTlMsXG4gICAgICAgIGRhdGU6IERhdGUsXG4gICAgfTsgfVxuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSBFeHBvbmVudGlhbEJhY2tvZmYuZGVmYXVsdCkge1xuICAgICAgICBjb25zdCB7IGluaXRpYWxJbnRlcnZhbCA9IElOSVRJQUxfSU5URVJWQUxfTVNFQywgcmFuZG9taXphdGlvbkZhY3RvciA9IFJBTkRPTUlaQVRJT05fRkFDVE9SLCBtdWx0aXBsaWVyID0gTVVMVElQTElFUiwgbWF4SW50ZXJ2YWwgPSBNQVhfSU5URVJWQUxfTVNFQywgbWF4RWxhcHNlZFRpbWUgPSBNQVhfRUxBUFNFRF9USU1FX01TRUMsIG1heEl0ZXJhdGlvbnMgPSBNQVhfSVRFUkFUSU9OUywgZGF0ZSA9IERhdGUsIH0gPSBvcHRpb25zO1xuICAgICAgICB0aGlzLiNjdXJyZW50SW50ZXJ2YWwgPSBpbml0aWFsSW50ZXJ2YWw7XG4gICAgICAgIHRoaXMuI3JhbmRvbWl6YXRpb25GYWN0b3IgPSByYW5kb21pemF0aW9uRmFjdG9yO1xuICAgICAgICB0aGlzLiNtdWx0aXBsaWVyID0gbXVsdGlwbGllcjtcbiAgICAgICAgdGhpcy4jbWF4SW50ZXJ2YWwgPSBtYXhJbnRlcnZhbDtcbiAgICAgICAgdGhpcy4jZGF0ZSA9IGRhdGU7XG4gICAgICAgIHRoaXMuI3N0YXJ0VGltZSA9IGRhdGUubm93KCk7XG4gICAgICAgIHRoaXMuI21heEVsYXBzZWRUaW1lID0gbWF4RWxhcHNlZFRpbWU7XG4gICAgICAgIHRoaXMuI21heEl0ZXJhdGlvbnMgPSBtYXhJdGVyYXRpb25zO1xuICAgIH1cbiAgICBnZXQgZWxsYXBzZWRUaW1lSW5Nc2VjKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jZGF0ZS5ub3coKSAtIHRoaXMuI3N0YXJ0VGltZTtcbiAgICB9XG4gICAgZ2V0IGN1cnJlbnRJbnRlcnZhbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2N1cnJlbnRJbnRlcnZhbDtcbiAgICB9XG4gICAgZ2V0IGNvdW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jY291bnQ7XG4gICAgfVxuICAgIGdldCByYW5kb21WYWx1ZUZyb21JbnRlcnZhbCgpIHtcbiAgICAgICAgY29uc3QgZGVsdGEgPSB0aGlzLiNyYW5kb21pemF0aW9uRmFjdG9yICogdGhpcy4jY3VycmVudEludGVydmFsO1xuICAgICAgICBjb25zdCBtaW4gPSB0aGlzLiNjdXJyZW50SW50ZXJ2YWwgLSBkZWx0YTtcbiAgICAgICAgY29uc3QgbWF4ID0gdGhpcy4jY3VycmVudEludGVydmFsICsgZGVsdGE7XG4gICAgICAgIHJldHVybiBNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbikgKyBtaW47XG4gICAgfVxuICAgIGluY3JlbWVudEN1cnJlbnRJbnRlcnZhbCgpIHtcbiAgICAgICAgdGhpcy4jY3VycmVudEludGVydmFsID0gTWF0aC5taW4odGhpcy4jY3VycmVudEludGVydmFsICogdGhpcy4jbXVsdGlwbGllciwgdGhpcy4jbWF4SW50ZXJ2YWwpO1xuICAgICAgICB0aGlzLiNjb3VudCsrO1xuICAgICAgICByZXR1cm4gdGhpcy4jY3VycmVudEludGVydmFsO1xuICAgIH1cbiAgICBuZXh0KCkge1xuICAgICAgICBpZiAodGhpcy5lbGxhcHNlZFRpbWVJbk1zZWMgPj0gdGhpcy4jbWF4RWxhcHNlZFRpbWUgfHwgdGhpcy4jY291bnQgPj0gdGhpcy4jbWF4SXRlcmF0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmluY3JlbWVudEN1cnJlbnRJbnRlcnZhbCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmFuZG9tVmFsdWVGcm9tSW50ZXJ2YWw7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIFV0aWxpdHkgZnVuY3Rpb24gdG8gY3JlYXRlIGFuIGV4cG9uZW50aWFsIGJhY2tvZmYgaXRlcmF0b3IuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIGZvciB0aGUgZXhwb25lbnRpYWwgYmFja29mZlxuICogQHJldHVybnMgYW4gaXRlcmF0b3IgdGhhdCB5aWVsZHMgdGhlIG5leHQgZGVsYXkgaW4gdGhlIGV4cG9uZW50aWFsIGJhY2tvZmZcbiAqIEB5aWVsZHMgdGhlIG5leHQgZGVsYXkgaW4gdGhlIGV4cG9uZW50aWFsIGJhY2tvZmZcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uKiBleHBvbmVudGlhbEJhY2tvZmYob3B0aW9ucyA9IEV4cG9uZW50aWFsQmFja29mZi5kZWZhdWx0KSB7XG4gICAgY29uc3QgYmFja29mZiA9IG5ldyBFeHBvbmVudGlhbEJhY2tvZmYob3B0aW9ucyk7XG4gICAgbGV0IG5leHQgPSBiYWNrb2ZmLm5leHQoKTtcbiAgICB3aGlsZSAobmV4dCkge1xuICAgICAgICB5aWVsZCBuZXh0O1xuICAgICAgICBuZXh0ID0gYmFja29mZi5uZXh0KCk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmFja29mZi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/polling/backoff.js\n");

/***/ }),

/***/ "(ssr)/../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/polling/index.js":
/*!**********************************************************************************!*\
  !*** ../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/polling/index.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_POLLING_OPTIONS: () => (/* binding */ DEFAULT_POLLING_OPTIONS),\n/* harmony export */   constructRequest: () => (/* binding */ constructRequest),\n/* harmony export */   defaultStrategy: () => (/* reexport safe */ _strategy_js__WEBPACK_IMPORTED_MODULE_0__.defaultStrategy),\n/* harmony export */   pollForResponse: () => (/* binding */ pollForResponse),\n/* harmony export */   strategy: () => (/* reexport module object */ _strategy_js__WEBPACK_IMPORTED_MODULE_0__)\n/* harmony export */ });\n/* harmony import */ var _certificate_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../certificate.js */ \"(ssr)/../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/certificate.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../errors.js */ \"(ssr)/../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/errors.js\");\n/* harmony import */ var _strategy_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./strategy.js */ \"(ssr)/../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/polling/strategy.js\");\n/* harmony import */ var _agent_http_types_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../agent/http/types.js */ \"(ssr)/../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/agent/http/types.js\");\n/* harmony import */ var _agent_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../agent/index.js */ \"(ssr)/../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/agent/http/index.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @noble/hashes/utils */ \"(ssr)/../../packages/sdk-js/node_modules/@noble/hashes/esm/utils.js\");\n\n\n\n\n\n\n\n\nconst DEFAULT_POLLING_OPTIONS = {\n    strategy: (0,_strategy_js__WEBPACK_IMPORTED_MODULE_0__.defaultStrategy)(),\n    preSignReadStateRequest: false,\n};\n/**\n * Check if an object has a property\n * @param value the object that might have the property\n * @param property the key of property we're looking for\n */\nfunction hasProperty(value, property) {\n    return Object.prototype.hasOwnProperty.call(value, property);\n}\nfunction isObjectWithProperty(value, property) {\n    return value !== null && typeof value === 'object' && hasProperty(value, property);\n}\nfunction hasFunction(value, property) {\n    return hasProperty(value, property) && typeof value[property] === 'function';\n}\n/**\n * Check if value is a signed read state request with expiry\n * @param value to check\n */\nfunction isSignedReadStateRequestWithExpiry(value) {\n    return (isObjectWithProperty(value, 'body') &&\n        isObjectWithProperty(value.body, 'content') &&\n        value.body.content.request_type ===\n            _agent_http_types_js__WEBPACK_IMPORTED_MODULE_1__.ReadRequestType.ReadState &&\n        isObjectWithProperty(value.body.content, 'ingress_expiry') &&\n        typeof value.body.content.ingress_expiry === 'object' &&\n        value.body.content.ingress_expiry !== null &&\n        hasFunction(value.body.content.ingress_expiry, 'toHash'));\n}\n/**\n * Polls the IC to check the status of the given request then\n * returns the response bytes once the request has been processed.\n * @param agent The agent to use to poll read_state.\n * @param canisterId The effective canister ID.\n * @param requestId The Request ID to poll status for.\n * @param options polling options to control behavior\n */\nasync function pollForResponse(agent, canisterId, requestId, options = {}) {\n    const path = [(0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_2__.utf8ToBytes)('request_status'), requestId];\n    let state;\n    let currentRequest;\n    const preSignReadStateRequest = options.preSignReadStateRequest ?? false;\n    if (preSignReadStateRequest) {\n        // If preSignReadStateRequest is true, we need to create a new request\n        currentRequest = await constructRequest({\n            paths: [path],\n            agent,\n            pollingOptions: options,\n        });\n        state = await agent.readState(canisterId, { paths: [path] }, undefined, currentRequest);\n    }\n    else {\n        // If preSignReadStateRequest is false, we use the default strategy and sign the request each time\n        state = await agent.readState(canisterId, { paths: [path] });\n    }\n    if (agent.rootKey == null) {\n        throw _errors_js__WEBPACK_IMPORTED_MODULE_3__.ExternalError.fromCode(new _errors_js__WEBPACK_IMPORTED_MODULE_3__.MissingRootKeyErrorCode());\n    }\n    const cert = await _certificate_js__WEBPACK_IMPORTED_MODULE_4__.Certificate.create({\n        certificate: state.certificate,\n        rootKey: agent.rootKey,\n        canisterId: canisterId,\n        blsVerify: options.blsVerify,\n        agent,\n    });\n    const maybeBuf = (0,_certificate_js__WEBPACK_IMPORTED_MODULE_4__.lookupResultToBuffer)(cert.lookup_path([...path, (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_2__.utf8ToBytes)('status')]));\n    let status;\n    if (typeof maybeBuf === 'undefined') {\n        // Missing requestId means we need to wait\n        status = _agent_index_js__WEBPACK_IMPORTED_MODULE_5__.RequestStatusResponseStatus.Unknown;\n    }\n    else {\n        status = new TextDecoder().decode(maybeBuf);\n    }\n    switch (status) {\n        case _agent_index_js__WEBPACK_IMPORTED_MODULE_5__.RequestStatusResponseStatus.Replied: {\n            return {\n                reply: (0,_certificate_js__WEBPACK_IMPORTED_MODULE_4__.lookupResultToBuffer)(cert.lookup_path([...path, 'reply'])),\n                certificate: cert,\n            };\n        }\n        case _agent_index_js__WEBPACK_IMPORTED_MODULE_5__.RequestStatusResponseStatus.Received:\n        case _agent_index_js__WEBPACK_IMPORTED_MODULE_5__.RequestStatusResponseStatus.Unknown:\n        case _agent_index_js__WEBPACK_IMPORTED_MODULE_5__.RequestStatusResponseStatus.Processing: {\n            // Execute the polling strategy, then retry.\n            const strategy = options.strategy ?? (0,_strategy_js__WEBPACK_IMPORTED_MODULE_0__.defaultStrategy)();\n            await strategy(canisterId, requestId, status);\n            return pollForResponse(agent, canisterId, requestId, {\n                ...options,\n                request: currentRequest,\n            });\n        }\n        case _agent_index_js__WEBPACK_IMPORTED_MODULE_5__.RequestStatusResponseStatus.Rejected: {\n            const rejectCode = new Uint8Array((0,_certificate_js__WEBPACK_IMPORTED_MODULE_4__.lookupResultToBuffer)(cert.lookup_path([...path, 'reject_code'])))[0];\n            const rejectMessage = new TextDecoder().decode((0,_certificate_js__WEBPACK_IMPORTED_MODULE_4__.lookupResultToBuffer)(cert.lookup_path([...path, 'reject_message'])));\n            const errorCodeBuf = (0,_certificate_js__WEBPACK_IMPORTED_MODULE_4__.lookupResultToBuffer)(cert.lookup_path([...path, 'error_code']));\n            const errorCode = errorCodeBuf ? new TextDecoder().decode(errorCodeBuf) : undefined;\n            throw _errors_js__WEBPACK_IMPORTED_MODULE_3__.RejectError.fromCode(new _errors_js__WEBPACK_IMPORTED_MODULE_3__.CertifiedRejectErrorCode(requestId, rejectCode, rejectMessage, errorCode));\n        }\n        case _agent_index_js__WEBPACK_IMPORTED_MODULE_5__.RequestStatusResponseStatus.Done:\n            // This is _technically_ not an error, but we still didn't see the `Replied` status so\n            // we don't know the result and cannot decode it.\n            throw _errors_js__WEBPACK_IMPORTED_MODULE_3__.UnknownError.fromCode(new _errors_js__WEBPACK_IMPORTED_MODULE_3__.RequestStatusDoneNoReplyErrorCode(requestId));\n    }\n    throw _errors_js__WEBPACK_IMPORTED_MODULE_3__.UNREACHABLE_ERROR;\n}\n// Determine if we should reuse the read state request or create a new one\n// based on the options provided.\n/**\n * Constructs a read state request for the given paths.\n * If the request is already signed and has an expiry, it will be returned as is.\n * Otherwise, a new request will be created.\n * @param options The options to use for creating the request.\n * @param options.paths The paths to read from.\n * @param options.agent The agent to use to create the request.\n * @param options.pollingOptions The options to use for creating the request.\n * @returns The read state request.\n */\nasync function constructRequest(options) {\n    const { paths, agent, pollingOptions } = options;\n    if (pollingOptions.request && isSignedReadStateRequestWithExpiry(pollingOptions.request)) {\n        return pollingOptions.request;\n    }\n    const request = await agent.createReadStateRequest?.({\n        paths,\n    }, undefined);\n    if (!isSignedReadStateRequestWithExpiry(request)) {\n        throw _errors_js__WEBPACK_IMPORTED_MODULE_3__.InputError.fromCode(new _errors_js__WEBPACK_IMPORTED_MODULE_3__.InvalidReadStateRequestErrorCode(request));\n    }\n    return request;\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vcGFja2FnZXMvc2RrLWpzL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL3BvbGxpbmcvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBdUU7QUFDeUo7QUFDdEw7QUFDTTtBQUNTO0FBQ087QUFDZDtBQUNGO0FBQ3pDO0FBQ1AsY0FBYyw2REFBZTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGlFQUFlO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08seUVBQXlFO0FBQ2hGLGtCQUFrQixnRUFBVztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Qsb0RBQW9ELGVBQWU7QUFDbkU7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGVBQWU7QUFDbkU7QUFDQTtBQUNBLGNBQWMscURBQWEsY0FBYywrREFBdUI7QUFDaEU7QUFDQSx1QkFBdUIsd0RBQVc7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxxQkFBcUIscUVBQW9CLDRCQUE0QixnRUFBVztBQUNoRjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsd0VBQTJCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHdFQUEyQjtBQUN4QztBQUNBLHVCQUF1QixxRUFBb0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsYUFBYSx3RUFBMkI7QUFDeEMsYUFBYSx3RUFBMkI7QUFDeEMsYUFBYSx3RUFBMkI7QUFDeEM7QUFDQSxpREFBaUQsNkRBQWU7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhLHdFQUEyQjtBQUN4Qyw4Q0FBOEMscUVBQW9CO0FBQ2xFLDJEQUEyRCxxRUFBb0I7QUFDL0UsaUNBQWlDLHFFQUFvQjtBQUNyRDtBQUNBLGtCQUFrQixtREFBVyxjQUFjLGdFQUF3QjtBQUNuRTtBQUNBLGFBQWEsd0VBQTJCO0FBQ3hDO0FBQ0E7QUFDQSxrQkFBa0Isb0RBQVksY0FBYyx5RUFBaUM7QUFDN0U7QUFDQSxVQUFVLHlEQUFpQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsWUFBWSwrQkFBK0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGNBQWMsa0RBQVUsY0FBYyx3RUFBZ0M7QUFDdEU7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AaXF1YmUvb3BzLWNvbnNvbGUvLi4vLi4vcGFja2FnZXMvc2RrLWpzL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL3BvbGxpbmcvaW5kZXguanM/OWYwMSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDZXJ0aWZpY2F0ZSwgbG9va3VwUmVzdWx0VG9CdWZmZXIsIH0gZnJvbSBcIi4uL2NlcnRpZmljYXRlLmpzXCI7XG5pbXBvcnQgeyBDZXJ0aWZpZWRSZWplY3RFcnJvckNvZGUsIEV4dGVybmFsRXJyb3IsIElucHV0RXJyb3IsIEludmFsaWRSZWFkU3RhdGVSZXF1ZXN0RXJyb3JDb2RlLCBNaXNzaW5nUm9vdEtleUVycm9yQ29kZSwgUmVqZWN0RXJyb3IsIFJlcXVlc3RTdGF0dXNEb25lTm9SZXBseUVycm9yQ29kZSwgVW5rbm93bkVycm9yLCBVTlJFQUNIQUJMRV9FUlJPUiwgfSBmcm9tIFwiLi4vZXJyb3JzLmpzXCI7XG5leHBvcnQgKiBhcyBzdHJhdGVneSBmcm9tIFwiLi9zdHJhdGVneS5qc1wiO1xuaW1wb3J0IHsgZGVmYXVsdFN0cmF0ZWd5IH0gZnJvbSBcIi4vc3RyYXRlZ3kuanNcIjtcbmltcG9ydCB7IFJlYWRSZXF1ZXN0VHlwZSB9IGZyb20gXCIuLi9hZ2VudC9odHRwL3R5cGVzLmpzXCI7XG5pbXBvcnQgeyBSZXF1ZXN0U3RhdHVzUmVzcG9uc2VTdGF0dXMgfSBmcm9tIFwiLi4vYWdlbnQvaW5kZXguanNcIjtcbmltcG9ydCB7IHV0ZjhUb0J5dGVzIH0gZnJvbSAnQG5vYmxlL2hhc2hlcy91dGlscyc7XG5leHBvcnQgeyBkZWZhdWx0U3RyYXRlZ3kgfSBmcm9tIFwiLi9zdHJhdGVneS5qc1wiO1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfUE9MTElOR19PUFRJT05TID0ge1xuICAgIHN0cmF0ZWd5OiBkZWZhdWx0U3RyYXRlZ3koKSxcbiAgICBwcmVTaWduUmVhZFN0YXRlUmVxdWVzdDogZmFsc2UsXG59O1xuLyoqXG4gKiBDaGVjayBpZiBhbiBvYmplY3QgaGFzIGEgcHJvcGVydHlcbiAqIEBwYXJhbSB2YWx1ZSB0aGUgb2JqZWN0IHRoYXQgbWlnaHQgaGF2ZSB0aGUgcHJvcGVydHlcbiAqIEBwYXJhbSBwcm9wZXJ0eSB0aGUga2V5IG9mIHByb3BlcnR5IHdlJ3JlIGxvb2tpbmcgZm9yXG4gKi9cbmZ1bmN0aW9uIGhhc1Byb3BlcnR5KHZhbHVlLCBwcm9wZXJ0eSkge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIHByb3BlcnR5KTtcbn1cbmZ1bmN0aW9uIGlzT2JqZWN0V2l0aFByb3BlcnR5KHZhbHVlLCBwcm9wZXJ0eSkge1xuICAgIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIGhhc1Byb3BlcnR5KHZhbHVlLCBwcm9wZXJ0eSk7XG59XG5mdW5jdGlvbiBoYXNGdW5jdGlvbih2YWx1ZSwgcHJvcGVydHkpIHtcbiAgICByZXR1cm4gaGFzUHJvcGVydHkodmFsdWUsIHByb3BlcnR5KSAmJiB0eXBlb2YgdmFsdWVbcHJvcGVydHldID09PSAnZnVuY3Rpb24nO1xufVxuLyoqXG4gKiBDaGVjayBpZiB2YWx1ZSBpcyBhIHNpZ25lZCByZWFkIHN0YXRlIHJlcXVlc3Qgd2l0aCBleHBpcnlcbiAqIEBwYXJhbSB2YWx1ZSB0byBjaGVja1xuICovXG5mdW5jdGlvbiBpc1NpZ25lZFJlYWRTdGF0ZVJlcXVlc3RXaXRoRXhwaXJ5KHZhbHVlKSB7XG4gICAgcmV0dXJuIChpc09iamVjdFdpdGhQcm9wZXJ0eSh2YWx1ZSwgJ2JvZHknKSAmJlxuICAgICAgICBpc09iamVjdFdpdGhQcm9wZXJ0eSh2YWx1ZS5ib2R5LCAnY29udGVudCcpICYmXG4gICAgICAgIHZhbHVlLmJvZHkuY29udGVudC5yZXF1ZXN0X3R5cGUgPT09XG4gICAgICAgICAgICBSZWFkUmVxdWVzdFR5cGUuUmVhZFN0YXRlICYmXG4gICAgICAgIGlzT2JqZWN0V2l0aFByb3BlcnR5KHZhbHVlLmJvZHkuY29udGVudCwgJ2luZ3Jlc3NfZXhwaXJ5JykgJiZcbiAgICAgICAgdHlwZW9mIHZhbHVlLmJvZHkuY29udGVudC5pbmdyZXNzX2V4cGlyeSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgdmFsdWUuYm9keS5jb250ZW50LmluZ3Jlc3NfZXhwaXJ5ICE9PSBudWxsICYmXG4gICAgICAgIGhhc0Z1bmN0aW9uKHZhbHVlLmJvZHkuY29udGVudC5pbmdyZXNzX2V4cGlyeSwgJ3RvSGFzaCcpKTtcbn1cbi8qKlxuICogUG9sbHMgdGhlIElDIHRvIGNoZWNrIHRoZSBzdGF0dXMgb2YgdGhlIGdpdmVuIHJlcXVlc3QgdGhlblxuICogcmV0dXJucyB0aGUgcmVzcG9uc2UgYnl0ZXMgb25jZSB0aGUgcmVxdWVzdCBoYXMgYmVlbiBwcm9jZXNzZWQuXG4gKiBAcGFyYW0gYWdlbnQgVGhlIGFnZW50IHRvIHVzZSB0byBwb2xsIHJlYWRfc3RhdGUuXG4gKiBAcGFyYW0gY2FuaXN0ZXJJZCBUaGUgZWZmZWN0aXZlIGNhbmlzdGVyIElELlxuICogQHBhcmFtIHJlcXVlc3RJZCBUaGUgUmVxdWVzdCBJRCB0byBwb2xsIHN0YXR1cyBmb3IuXG4gKiBAcGFyYW0gb3B0aW9ucyBwb2xsaW5nIG9wdGlvbnMgdG8gY29udHJvbCBiZWhhdmlvclxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcG9sbEZvclJlc3BvbnNlKGFnZW50LCBjYW5pc3RlcklkLCByZXF1ZXN0SWQsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHBhdGggPSBbdXRmOFRvQnl0ZXMoJ3JlcXVlc3Rfc3RhdHVzJyksIHJlcXVlc3RJZF07XG4gICAgbGV0IHN0YXRlO1xuICAgIGxldCBjdXJyZW50UmVxdWVzdDtcbiAgICBjb25zdCBwcmVTaWduUmVhZFN0YXRlUmVxdWVzdCA9IG9wdGlvbnMucHJlU2lnblJlYWRTdGF0ZVJlcXVlc3QgPz8gZmFsc2U7XG4gICAgaWYgKHByZVNpZ25SZWFkU3RhdGVSZXF1ZXN0KSB7XG4gICAgICAgIC8vIElmIHByZVNpZ25SZWFkU3RhdGVSZXF1ZXN0IGlzIHRydWUsIHdlIG5lZWQgdG8gY3JlYXRlIGEgbmV3IHJlcXVlc3RcbiAgICAgICAgY3VycmVudFJlcXVlc3QgPSBhd2FpdCBjb25zdHJ1Y3RSZXF1ZXN0KHtcbiAgICAgICAgICAgIHBhdGhzOiBbcGF0aF0sXG4gICAgICAgICAgICBhZ2VudCxcbiAgICAgICAgICAgIHBvbGxpbmdPcHRpb25zOiBvcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgc3RhdGUgPSBhd2FpdCBhZ2VudC5yZWFkU3RhdGUoY2FuaXN0ZXJJZCwgeyBwYXRoczogW3BhdGhdIH0sIHVuZGVmaW5lZCwgY3VycmVudFJlcXVlc3QpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gSWYgcHJlU2lnblJlYWRTdGF0ZVJlcXVlc3QgaXMgZmFsc2UsIHdlIHVzZSB0aGUgZGVmYXVsdCBzdHJhdGVneSBhbmQgc2lnbiB0aGUgcmVxdWVzdCBlYWNoIHRpbWVcbiAgICAgICAgc3RhdGUgPSBhd2FpdCBhZ2VudC5yZWFkU3RhdGUoY2FuaXN0ZXJJZCwgeyBwYXRoczogW3BhdGhdIH0pO1xuICAgIH1cbiAgICBpZiAoYWdlbnQucm9vdEtleSA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IEV4dGVybmFsRXJyb3IuZnJvbUNvZGUobmV3IE1pc3NpbmdSb290S2V5RXJyb3JDb2RlKCkpO1xuICAgIH1cbiAgICBjb25zdCBjZXJ0ID0gYXdhaXQgQ2VydGlmaWNhdGUuY3JlYXRlKHtcbiAgICAgICAgY2VydGlmaWNhdGU6IHN0YXRlLmNlcnRpZmljYXRlLFxuICAgICAgICByb290S2V5OiBhZ2VudC5yb290S2V5LFxuICAgICAgICBjYW5pc3RlcklkOiBjYW5pc3RlcklkLFxuICAgICAgICBibHNWZXJpZnk6IG9wdGlvbnMuYmxzVmVyaWZ5LFxuICAgICAgICBhZ2VudCxcbiAgICB9KTtcbiAgICBjb25zdCBtYXliZUJ1ZiA9IGxvb2t1cFJlc3VsdFRvQnVmZmVyKGNlcnQubG9va3VwX3BhdGgoWy4uLnBhdGgsIHV0ZjhUb0J5dGVzKCdzdGF0dXMnKV0pKTtcbiAgICBsZXQgc3RhdHVzO1xuICAgIGlmICh0eXBlb2YgbWF5YmVCdWYgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIC8vIE1pc3NpbmcgcmVxdWVzdElkIG1lYW5zIHdlIG5lZWQgdG8gd2FpdFxuICAgICAgICBzdGF0dXMgPSBSZXF1ZXN0U3RhdHVzUmVzcG9uc2VTdGF0dXMuVW5rbm93bjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHN0YXR1cyA9IG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShtYXliZUJ1Zik7XG4gICAgfVxuICAgIHN3aXRjaCAoc3RhdHVzKSB7XG4gICAgICAgIGNhc2UgUmVxdWVzdFN0YXR1c1Jlc3BvbnNlU3RhdHVzLlJlcGxpZWQ6IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcmVwbHk6IGxvb2t1cFJlc3VsdFRvQnVmZmVyKGNlcnQubG9va3VwX3BhdGgoWy4uLnBhdGgsICdyZXBseSddKSksXG4gICAgICAgICAgICAgICAgY2VydGlmaWNhdGU6IGNlcnQsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgUmVxdWVzdFN0YXR1c1Jlc3BvbnNlU3RhdHVzLlJlY2VpdmVkOlxuICAgICAgICBjYXNlIFJlcXVlc3RTdGF0dXNSZXNwb25zZVN0YXR1cy5Vbmtub3duOlxuICAgICAgICBjYXNlIFJlcXVlc3RTdGF0dXNSZXNwb25zZVN0YXR1cy5Qcm9jZXNzaW5nOiB7XG4gICAgICAgICAgICAvLyBFeGVjdXRlIHRoZSBwb2xsaW5nIHN0cmF0ZWd5LCB0aGVuIHJldHJ5LlxuICAgICAgICAgICAgY29uc3Qgc3RyYXRlZ3kgPSBvcHRpb25zLnN0cmF0ZWd5ID8/IGRlZmF1bHRTdHJhdGVneSgpO1xuICAgICAgICAgICAgYXdhaXQgc3RyYXRlZ3koY2FuaXN0ZXJJZCwgcmVxdWVzdElkLCBzdGF0dXMpO1xuICAgICAgICAgICAgcmV0dXJuIHBvbGxGb3JSZXNwb25zZShhZ2VudCwgY2FuaXN0ZXJJZCwgcmVxdWVzdElkLCB7XG4gICAgICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgICAgICByZXF1ZXN0OiBjdXJyZW50UmVxdWVzdCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgUmVxdWVzdFN0YXR1c1Jlc3BvbnNlU3RhdHVzLlJlamVjdGVkOiB7XG4gICAgICAgICAgICBjb25zdCByZWplY3RDb2RlID0gbmV3IFVpbnQ4QXJyYXkobG9va3VwUmVzdWx0VG9CdWZmZXIoY2VydC5sb29rdXBfcGF0aChbLi4ucGF0aCwgJ3JlamVjdF9jb2RlJ10pKSlbMF07XG4gICAgICAgICAgICBjb25zdCByZWplY3RNZXNzYWdlID0gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKGxvb2t1cFJlc3VsdFRvQnVmZmVyKGNlcnQubG9va3VwX3BhdGgoWy4uLnBhdGgsICdyZWplY3RfbWVzc2FnZSddKSkpO1xuICAgICAgICAgICAgY29uc3QgZXJyb3JDb2RlQnVmID0gbG9va3VwUmVzdWx0VG9CdWZmZXIoY2VydC5sb29rdXBfcGF0aChbLi4ucGF0aCwgJ2Vycm9yX2NvZGUnXSkpO1xuICAgICAgICAgICAgY29uc3QgZXJyb3JDb2RlID0gZXJyb3JDb2RlQnVmID8gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKGVycm9yQ29kZUJ1ZikgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aHJvdyBSZWplY3RFcnJvci5mcm9tQ29kZShuZXcgQ2VydGlmaWVkUmVqZWN0RXJyb3JDb2RlKHJlcXVlc3RJZCwgcmVqZWN0Q29kZSwgcmVqZWN0TWVzc2FnZSwgZXJyb3JDb2RlKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBSZXF1ZXN0U3RhdHVzUmVzcG9uc2VTdGF0dXMuRG9uZTpcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgX3RlY2huaWNhbGx5XyBub3QgYW4gZXJyb3IsIGJ1dCB3ZSBzdGlsbCBkaWRuJ3Qgc2VlIHRoZSBgUmVwbGllZGAgc3RhdHVzIHNvXG4gICAgICAgICAgICAvLyB3ZSBkb24ndCBrbm93IHRoZSByZXN1bHQgYW5kIGNhbm5vdCBkZWNvZGUgaXQuXG4gICAgICAgICAgICB0aHJvdyBVbmtub3duRXJyb3IuZnJvbUNvZGUobmV3IFJlcXVlc3RTdGF0dXNEb25lTm9SZXBseUVycm9yQ29kZShyZXF1ZXN0SWQpKTtcbiAgICB9XG4gICAgdGhyb3cgVU5SRUFDSEFCTEVfRVJST1I7XG59XG4vLyBEZXRlcm1pbmUgaWYgd2Ugc2hvdWxkIHJldXNlIHRoZSByZWFkIHN0YXRlIHJlcXVlc3Qgb3IgY3JlYXRlIGEgbmV3IG9uZVxuLy8gYmFzZWQgb24gdGhlIG9wdGlvbnMgcHJvdmlkZWQuXG4vKipcbiAqIENvbnN0cnVjdHMgYSByZWFkIHN0YXRlIHJlcXVlc3QgZm9yIHRoZSBnaXZlbiBwYXRocy5cbiAqIElmIHRoZSByZXF1ZXN0IGlzIGFscmVhZHkgc2lnbmVkIGFuZCBoYXMgYW4gZXhwaXJ5LCBpdCB3aWxsIGJlIHJldHVybmVkIGFzIGlzLlxuICogT3RoZXJ3aXNlLCBhIG5ldyByZXF1ZXN0IHdpbGwgYmUgY3JlYXRlZC5cbiAqIEBwYXJhbSBvcHRpb25zIFRoZSBvcHRpb25zIHRvIHVzZSBmb3IgY3JlYXRpbmcgdGhlIHJlcXVlc3QuXG4gKiBAcGFyYW0gb3B0aW9ucy5wYXRocyBUaGUgcGF0aHMgdG8gcmVhZCBmcm9tLlxuICogQHBhcmFtIG9wdGlvbnMuYWdlbnQgVGhlIGFnZW50IHRvIHVzZSB0byBjcmVhdGUgdGhlIHJlcXVlc3QuXG4gKiBAcGFyYW0gb3B0aW9ucy5wb2xsaW5nT3B0aW9ucyBUaGUgb3B0aW9ucyB0byB1c2UgZm9yIGNyZWF0aW5nIHRoZSByZXF1ZXN0LlxuICogQHJldHVybnMgVGhlIHJlYWQgc3RhdGUgcmVxdWVzdC5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNvbnN0cnVjdFJlcXVlc3Qob3B0aW9ucykge1xuICAgIGNvbnN0IHsgcGF0aHMsIGFnZW50LCBwb2xsaW5nT3B0aW9ucyB9ID0gb3B0aW9ucztcbiAgICBpZiAocG9sbGluZ09wdGlvbnMucmVxdWVzdCAmJiBpc1NpZ25lZFJlYWRTdGF0ZVJlcXVlc3RXaXRoRXhwaXJ5KHBvbGxpbmdPcHRpb25zLnJlcXVlc3QpKSB7XG4gICAgICAgIHJldHVybiBwb2xsaW5nT3B0aW9ucy5yZXF1ZXN0O1xuICAgIH1cbiAgICBjb25zdCByZXF1ZXN0ID0gYXdhaXQgYWdlbnQuY3JlYXRlUmVhZFN0YXRlUmVxdWVzdD8uKHtcbiAgICAgICAgcGF0aHMsXG4gICAgfSwgdW5kZWZpbmVkKTtcbiAgICBpZiAoIWlzU2lnbmVkUmVhZFN0YXRlUmVxdWVzdFdpdGhFeHBpcnkocmVxdWVzdCkpIHtcbiAgICAgICAgdGhyb3cgSW5wdXRFcnJvci5mcm9tQ29kZShuZXcgSW52YWxpZFJlYWRTdGF0ZVJlcXVlc3RFcnJvckNvZGUocmVxdWVzdCkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVxdWVzdDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/polling/index.js\n");

/***/ }),

/***/ "(ssr)/../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/polling/strategy.js":
/*!*************************************************************************************!*\
  !*** ../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/polling/strategy.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   backoff: () => (/* binding */ backoff),\n/* harmony export */   chain: () => (/* binding */ chain),\n/* harmony export */   conditionalDelay: () => (/* binding */ conditionalDelay),\n/* harmony export */   defaultStrategy: () => (/* binding */ defaultStrategy),\n/* harmony export */   maxAttempts: () => (/* binding */ maxAttempts),\n/* harmony export */   once: () => (/* binding */ once),\n/* harmony export */   throttle: () => (/* binding */ throttle),\n/* harmony export */   timeout: () => (/* binding */ timeout)\n/* harmony export */ });\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../errors.js */ \"(ssr)/../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/errors.js\");\n\nconst FIVE_MINUTES_IN_MSEC = 5 * 60 * 1000;\n/**\n * A best practices polling strategy: wait 2 seconds before the first poll, then 1 second\n * with an exponential backoff factor of 1.2. Timeout after 5 minutes.\n */\nfunction defaultStrategy() {\n    return chain(conditionalDelay(once(), 1000), backoff(1000, 1.2), timeout(FIVE_MINUTES_IN_MSEC));\n}\n/**\n * Predicate that returns true once.\n */\nfunction once() {\n    let first = true;\n    return async () => {\n        if (first) {\n            first = false;\n            return true;\n        }\n        return false;\n    };\n}\n/**\n * Delay the polling once.\n * @param condition A predicate that indicates when to delay.\n * @param timeInMsec The amount of time to delay.\n */\nfunction conditionalDelay(condition, timeInMsec) {\n    return async (canisterId, requestId, status) => {\n        if (await condition(canisterId, requestId, status)) {\n            return new Promise(resolve => setTimeout(resolve, timeInMsec));\n        }\n    };\n}\n/**\n * Error out after a maximum number of polling has been done.\n * @param count The maximum attempts to poll.\n */\nfunction maxAttempts(count) {\n    let attempts = count;\n    return async (_canisterId, requestId, status) => {\n        if (--attempts <= 0) {\n            throw _errors_js__WEBPACK_IMPORTED_MODULE_0__.ProtocolError.fromCode(new _errors_js__WEBPACK_IMPORTED_MODULE_0__.TimeoutWaitingForResponseErrorCode(`Failed to retrieve a reply for request after ${count} attempts`, requestId, status));\n        }\n    };\n}\n/**\n * Throttle polling.\n * @param throttleInMsec Amount in millisecond to wait between each polling.\n */\nfunction throttle(throttleInMsec) {\n    return () => new Promise(resolve => setTimeout(resolve, throttleInMsec));\n}\n/**\n * Reject a call after a certain amount of time.\n * @param timeInMsec Time in milliseconds before the polling should be rejected.\n */\nfunction timeout(timeInMsec) {\n    const end = Date.now() + timeInMsec;\n    return async (_canisterId, requestId, status) => {\n        if (Date.now() > end) {\n            throw _errors_js__WEBPACK_IMPORTED_MODULE_0__.ProtocolError.fromCode(new _errors_js__WEBPACK_IMPORTED_MODULE_0__.TimeoutWaitingForResponseErrorCode(`Request timed out after ${timeInMsec} msec`, requestId, status));\n        }\n    };\n}\n/**\n * A strategy that throttle, but using an exponential backoff strategy.\n * @param startingThrottleInMsec The throttle in milliseconds to start with.\n * @param backoffFactor The factor to multiple the throttle time between every poll. For\n *   example if using 2, the throttle will double between every run.\n */\nfunction backoff(startingThrottleInMsec, backoffFactor) {\n    let currentThrottling = startingThrottleInMsec;\n    return () => new Promise(resolve => setTimeout(() => {\n        currentThrottling *= backoffFactor;\n        resolve();\n    }, currentThrottling));\n}\n/**\n * Chain multiple polling strategy. This _chains_ the strategies, so if you pass in,\n * say, two throttling strategy of 1 second, it will result in a throttle of 2 seconds.\n * @param strategies A strategy list to chain.\n */\nfunction chain(...strategies) {\n    return async (canisterId, requestId, status) => {\n        for (const a of strategies) {\n            await a(canisterId, requestId, status);\n        }\n    };\n}\n//# sourceMappingURL=strategy.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vcGFja2FnZXMvc2RrLWpzL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL3BvbGxpbmcvc3RyYXRlZ3kuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQWlGO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IscURBQWEsY0FBYywwRUFBa0MsaURBQWlELE9BQU87QUFDdkk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHFEQUFhLGNBQWMsMEVBQWtDLDRCQUE0QixZQUFZO0FBQ3ZIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BpcXViZS9vcHMtY29uc29sZS8uLi8uLi9wYWNrYWdlcy9zZGstanMvbm9kZV9tb2R1bGVzL0BkZmluaXR5L2FnZW50L2xpYi9lc20vcG9sbGluZy9zdHJhdGVneS5qcz8zZTM3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFByb3RvY29sRXJyb3IsIFRpbWVvdXRXYWl0aW5nRm9yUmVzcG9uc2VFcnJvckNvZGUgfSBmcm9tIFwiLi4vZXJyb3JzLmpzXCI7XG5jb25zdCBGSVZFX01JTlVURVNfSU5fTVNFQyA9IDUgKiA2MCAqIDEwMDA7XG4vKipcbiAqIEEgYmVzdCBwcmFjdGljZXMgcG9sbGluZyBzdHJhdGVneTogd2FpdCAyIHNlY29uZHMgYmVmb3JlIHRoZSBmaXJzdCBwb2xsLCB0aGVuIDEgc2Vjb25kXG4gKiB3aXRoIGFuIGV4cG9uZW50aWFsIGJhY2tvZmYgZmFjdG9yIG9mIDEuMi4gVGltZW91dCBhZnRlciA1IG1pbnV0ZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0U3RyYXRlZ3koKSB7XG4gICAgcmV0dXJuIGNoYWluKGNvbmRpdGlvbmFsRGVsYXkob25jZSgpLCAxMDAwKSwgYmFja29mZigxMDAwLCAxLjIpLCB0aW1lb3V0KEZJVkVfTUlOVVRFU19JTl9NU0VDKSk7XG59XG4vKipcbiAqIFByZWRpY2F0ZSB0aGF0IHJldHVybnMgdHJ1ZSBvbmNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gb25jZSgpIHtcbiAgICBsZXQgZmlyc3QgPSB0cnVlO1xuICAgIHJldHVybiBhc3luYyAoKSA9PiB7XG4gICAgICAgIGlmIChmaXJzdCkge1xuICAgICAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xufVxuLyoqXG4gKiBEZWxheSB0aGUgcG9sbGluZyBvbmNlLlxuICogQHBhcmFtIGNvbmRpdGlvbiBBIHByZWRpY2F0ZSB0aGF0IGluZGljYXRlcyB3aGVuIHRvIGRlbGF5LlxuICogQHBhcmFtIHRpbWVJbk1zZWMgVGhlIGFtb3VudCBvZiB0aW1lIHRvIGRlbGF5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29uZGl0aW9uYWxEZWxheShjb25kaXRpb24sIHRpbWVJbk1zZWMpIHtcbiAgICByZXR1cm4gYXN5bmMgKGNhbmlzdGVySWQsIHJlcXVlc3RJZCwgc3RhdHVzKSA9PiB7XG4gICAgICAgIGlmIChhd2FpdCBjb25kaXRpb24oY2FuaXN0ZXJJZCwgcmVxdWVzdElkLCBzdGF0dXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIHRpbWVJbk1zZWMpKTtcbiAgICAgICAgfVxuICAgIH07XG59XG4vKipcbiAqIEVycm9yIG91dCBhZnRlciBhIG1heGltdW0gbnVtYmVyIG9mIHBvbGxpbmcgaGFzIGJlZW4gZG9uZS5cbiAqIEBwYXJhbSBjb3VudCBUaGUgbWF4aW11bSBhdHRlbXB0cyB0byBwb2xsLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWF4QXR0ZW1wdHMoY291bnQpIHtcbiAgICBsZXQgYXR0ZW1wdHMgPSBjb3VudDtcbiAgICByZXR1cm4gYXN5bmMgKF9jYW5pc3RlcklkLCByZXF1ZXN0SWQsIHN0YXR1cykgPT4ge1xuICAgICAgICBpZiAoLS1hdHRlbXB0cyA8PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBQcm90b2NvbEVycm9yLmZyb21Db2RlKG5ldyBUaW1lb3V0V2FpdGluZ0ZvclJlc3BvbnNlRXJyb3JDb2RlKGBGYWlsZWQgdG8gcmV0cmlldmUgYSByZXBseSBmb3IgcmVxdWVzdCBhZnRlciAke2NvdW50fSBhdHRlbXB0c2AsIHJlcXVlc3RJZCwgc3RhdHVzKSk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuLyoqXG4gKiBUaHJvdHRsZSBwb2xsaW5nLlxuICogQHBhcmFtIHRocm90dGxlSW5Nc2VjIEFtb3VudCBpbiBtaWxsaXNlY29uZCB0byB3YWl0IGJldHdlZW4gZWFjaCBwb2xsaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdGhyb3R0bGUodGhyb3R0bGVJbk1zZWMpIHtcbiAgICByZXR1cm4gKCkgPT4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIHRocm90dGxlSW5Nc2VjKSk7XG59XG4vKipcbiAqIFJlamVjdCBhIGNhbGwgYWZ0ZXIgYSBjZXJ0YWluIGFtb3VudCBvZiB0aW1lLlxuICogQHBhcmFtIHRpbWVJbk1zZWMgVGltZSBpbiBtaWxsaXNlY29uZHMgYmVmb3JlIHRoZSBwb2xsaW5nIHNob3VsZCBiZSByZWplY3RlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRpbWVvdXQodGltZUluTXNlYykge1xuICAgIGNvbnN0IGVuZCA9IERhdGUubm93KCkgKyB0aW1lSW5Nc2VjO1xuICAgIHJldHVybiBhc3luYyAoX2NhbmlzdGVySWQsIHJlcXVlc3RJZCwgc3RhdHVzKSA9PiB7XG4gICAgICAgIGlmIChEYXRlLm5vdygpID4gZW5kKSB7XG4gICAgICAgICAgICB0aHJvdyBQcm90b2NvbEVycm9yLmZyb21Db2RlKG5ldyBUaW1lb3V0V2FpdGluZ0ZvclJlc3BvbnNlRXJyb3JDb2RlKGBSZXF1ZXN0IHRpbWVkIG91dCBhZnRlciAke3RpbWVJbk1zZWN9IG1zZWNgLCByZXF1ZXN0SWQsIHN0YXR1cykpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbi8qKlxuICogQSBzdHJhdGVneSB0aGF0IHRocm90dGxlLCBidXQgdXNpbmcgYW4gZXhwb25lbnRpYWwgYmFja29mZiBzdHJhdGVneS5cbiAqIEBwYXJhbSBzdGFydGluZ1Rocm90dGxlSW5Nc2VjIFRoZSB0aHJvdHRsZSBpbiBtaWxsaXNlY29uZHMgdG8gc3RhcnQgd2l0aC5cbiAqIEBwYXJhbSBiYWNrb2ZmRmFjdG9yIFRoZSBmYWN0b3IgdG8gbXVsdGlwbGUgdGhlIHRocm90dGxlIHRpbWUgYmV0d2VlbiBldmVyeSBwb2xsLiBGb3JcbiAqICAgZXhhbXBsZSBpZiB1c2luZyAyLCB0aGUgdGhyb3R0bGUgd2lsbCBkb3VibGUgYmV0d2VlbiBldmVyeSBydW4uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiYWNrb2ZmKHN0YXJ0aW5nVGhyb3R0bGVJbk1zZWMsIGJhY2tvZmZGYWN0b3IpIHtcbiAgICBsZXQgY3VycmVudFRocm90dGxpbmcgPSBzdGFydGluZ1Rocm90dGxlSW5Nc2VjO1xuICAgIHJldHVybiAoKSA9PiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBjdXJyZW50VGhyb3R0bGluZyAqPSBiYWNrb2ZmRmFjdG9yO1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgfSwgY3VycmVudFRocm90dGxpbmcpKTtcbn1cbi8qKlxuICogQ2hhaW4gbXVsdGlwbGUgcG9sbGluZyBzdHJhdGVneS4gVGhpcyBfY2hhaW5zXyB0aGUgc3RyYXRlZ2llcywgc28gaWYgeW91IHBhc3MgaW4sXG4gKiBzYXksIHR3byB0aHJvdHRsaW5nIHN0cmF0ZWd5IG9mIDEgc2Vjb25kLCBpdCB3aWxsIHJlc3VsdCBpbiBhIHRocm90dGxlIG9mIDIgc2Vjb25kcy5cbiAqIEBwYXJhbSBzdHJhdGVnaWVzIEEgc3RyYXRlZ3kgbGlzdCB0byBjaGFpbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNoYWluKC4uLnN0cmF0ZWdpZXMpIHtcbiAgICByZXR1cm4gYXN5bmMgKGNhbmlzdGVySWQsIHJlcXVlc3RJZCwgc3RhdHVzKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgYSBvZiBzdHJhdGVnaWVzKSB7XG4gICAgICAgICAgICBhd2FpdCBhKGNhbmlzdGVySWQsIHJlcXVlc3RJZCwgc3RhdHVzKTtcbiAgICAgICAgfVxuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdHJhdGVneS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/polling/strategy.js\n");

/***/ }),

/***/ "(ssr)/../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/public_key.js":
/*!*******************************************************************************!*\
  !*** ../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/public_key.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Ed25519PublicKey: () => (/* binding */ Ed25519PublicKey)\n/* harmony export */ });\n/* harmony import */ var _der_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./der.js */ \"(ssr)/../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/der.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./errors.js */ \"(ssr)/../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/errors.js\");\n\n\nclass Ed25519PublicKey {\n    static from(key) {\n        return this.fromDer(key.toDer());\n    }\n    static fromRaw(rawKey) {\n        return new Ed25519PublicKey(rawKey);\n    }\n    static fromDer(derKey) {\n        return new Ed25519PublicKey(this.derDecode(derKey));\n    }\n    // The length of Ed25519 public keys is always 32 bytes.\n    static { this.RAW_KEY_LENGTH = 32; }\n    static derEncode(publicKey) {\n        return (0,_der_js__WEBPACK_IMPORTED_MODULE_0__.wrapDER)(publicKey, _der_js__WEBPACK_IMPORTED_MODULE_0__.ED25519_OID);\n    }\n    static derDecode(key) {\n        const unwrapped = (0,_der_js__WEBPACK_IMPORTED_MODULE_0__.unwrapDER)(key, _der_js__WEBPACK_IMPORTED_MODULE_0__.ED25519_OID);\n        if (unwrapped.length !== this.RAW_KEY_LENGTH) {\n            throw _errors_js__WEBPACK_IMPORTED_MODULE_1__.InputError.fromCode(new _errors_js__WEBPACK_IMPORTED_MODULE_1__.DerDecodeErrorCode('An Ed25519 public key must be exactly 32 bytes long'));\n        }\n        return unwrapped;\n    }\n    #rawKey;\n    get rawKey() {\n        return this.#rawKey;\n    }\n    #derKey;\n    get derKey() {\n        return this.#derKey;\n    }\n    // `fromRaw` and `fromDer` should be used for instantiation, not this constructor.\n    constructor(key) {\n        if (key.byteLength !== Ed25519PublicKey.RAW_KEY_LENGTH) {\n            throw _errors_js__WEBPACK_IMPORTED_MODULE_1__.InputError.fromCode(new _errors_js__WEBPACK_IMPORTED_MODULE_1__.DerDecodeErrorCode('An Ed25519 public key must be exactly 32 bytes long'));\n        }\n        this.#rawKey = key;\n        this.#derKey = Ed25519PublicKey.derEncode(key);\n    }\n    toDer() {\n        return this.derKey;\n    }\n    toRaw() {\n        return this.rawKey;\n    }\n}\n//# sourceMappingURL=public_key.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vcGFja2FnZXMvc2RrLWpzL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL3B1YmxpY19rZXkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTJEO0FBQ0U7QUFDdEQ7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGVBQWUsZ0RBQU8sWUFBWSxnREFBVztBQUM3QztBQUNBO0FBQ0EsMEJBQTBCLGtEQUFTLE1BQU0sZ0RBQVc7QUFDcEQ7QUFDQSxrQkFBa0Isa0RBQVUsY0FBYywwREFBa0I7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrREFBVSxjQUFjLDBEQUFrQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AaXF1YmUvb3BzLWNvbnNvbGUvLi4vLi4vcGFja2FnZXMvc2RrLWpzL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL3B1YmxpY19rZXkuanM/ZTMxZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFRDI1NTE5X09JRCwgdW53cmFwREVSLCB3cmFwREVSIH0gZnJvbSBcIi4vZGVyLmpzXCI7XG5pbXBvcnQgeyBEZXJEZWNvZGVFcnJvckNvZGUsIElucHV0RXJyb3IgfSBmcm9tIFwiLi9lcnJvcnMuanNcIjtcbmV4cG9ydCBjbGFzcyBFZDI1NTE5UHVibGljS2V5IHtcbiAgICBzdGF0aWMgZnJvbShrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnJvbURlcihrZXkudG9EZXIoKSk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tUmF3KHJhd0tleSkge1xuICAgICAgICByZXR1cm4gbmV3IEVkMjU1MTlQdWJsaWNLZXkocmF3S2V5KTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21EZXIoZGVyS2V5KSB7XG4gICAgICAgIHJldHVybiBuZXcgRWQyNTUxOVB1YmxpY0tleSh0aGlzLmRlckRlY29kZShkZXJLZXkpKTtcbiAgICB9XG4gICAgLy8gVGhlIGxlbmd0aCBvZiBFZDI1NTE5IHB1YmxpYyBrZXlzIGlzIGFsd2F5cyAzMiBieXRlcy5cbiAgICBzdGF0aWMgeyB0aGlzLlJBV19LRVlfTEVOR1RIID0gMzI7IH1cbiAgICBzdGF0aWMgZGVyRW5jb2RlKHB1YmxpY0tleSkge1xuICAgICAgICByZXR1cm4gd3JhcERFUihwdWJsaWNLZXksIEVEMjU1MTlfT0lEKTtcbiAgICB9XG4gICAgc3RhdGljIGRlckRlY29kZShrZXkpIHtcbiAgICAgICAgY29uc3QgdW53cmFwcGVkID0gdW53cmFwREVSKGtleSwgRUQyNTUxOV9PSUQpO1xuICAgICAgICBpZiAodW53cmFwcGVkLmxlbmd0aCAhPT0gdGhpcy5SQVdfS0VZX0xFTkdUSCkge1xuICAgICAgICAgICAgdGhyb3cgSW5wdXRFcnJvci5mcm9tQ29kZShuZXcgRGVyRGVjb2RlRXJyb3JDb2RlKCdBbiBFZDI1NTE5IHB1YmxpYyBrZXkgbXVzdCBiZSBleGFjdGx5IDMyIGJ5dGVzIGxvbmcnKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVud3JhcHBlZDtcbiAgICB9XG4gICAgI3Jhd0tleTtcbiAgICBnZXQgcmF3S2V5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jcmF3S2V5O1xuICAgIH1cbiAgICAjZGVyS2V5O1xuICAgIGdldCBkZXJLZXkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNkZXJLZXk7XG4gICAgfVxuICAgIC8vIGBmcm9tUmF3YCBhbmQgYGZyb21EZXJgIHNob3VsZCBiZSB1c2VkIGZvciBpbnN0YW50aWF0aW9uLCBub3QgdGhpcyBjb25zdHJ1Y3Rvci5cbiAgICBjb25zdHJ1Y3RvcihrZXkpIHtcbiAgICAgICAgaWYgKGtleS5ieXRlTGVuZ3RoICE9PSBFZDI1NTE5UHVibGljS2V5LlJBV19LRVlfTEVOR1RIKSB7XG4gICAgICAgICAgICB0aHJvdyBJbnB1dEVycm9yLmZyb21Db2RlKG5ldyBEZXJEZWNvZGVFcnJvckNvZGUoJ0FuIEVkMjU1MTkgcHVibGljIGtleSBtdXN0IGJlIGV4YWN0bHkgMzIgYnl0ZXMgbG9uZycpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNyYXdLZXkgPSBrZXk7XG4gICAgICAgIHRoaXMuI2RlcktleSA9IEVkMjU1MTlQdWJsaWNLZXkuZGVyRW5jb2RlKGtleSk7XG4gICAgfVxuICAgIHRvRGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZXJLZXk7XG4gICAgfVxuICAgIHRvUmF3KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yYXdLZXk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHVibGljX2tleS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/public_key.js\n");

/***/ }),

/***/ "(ssr)/../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/request_id.js":
/*!*******************************************************************************!*\
  !*** ../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/request_id.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   hashOfMap: () => (/* binding */ hashOfMap),\n/* harmony export */   hashValue: () => (/* binding */ hashValue),\n/* harmony export */   requestIdOf: () => (/* binding */ requestIdOf)\n/* harmony export */ });\n/* harmony import */ var _dfinity_candid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @dfinity/candid */ \"(ssr)/../../packages/sdk-js/node_modules/@dfinity/candid/lib/esm/utils/leb128.js\");\n/* harmony import */ var _dfinity_candid__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @dfinity/candid */ \"(ssr)/../../packages/sdk-js/node_modules/@dfinity/candid/lib/esm/utils/buffer.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./errors.js */ \"(ssr)/../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/errors.js\");\n/* harmony import */ var _utils_buffer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/buffer.js */ \"(ssr)/../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/utils/buffer.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @noble/hashes/utils */ \"(ssr)/../../packages/sdk-js/node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _noble_hashes_sha2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/sha2 */ \"(ssr)/../../packages/sdk-js/node_modules/@noble/hashes/esm/sha2.js\");\n\n\n\n\n\n/**\n *\n * @param value unknown value\n * @returns Uint8Array\n */\nfunction hashValue(value) {\n    if (typeof value === 'string') {\n        return hashString(value);\n    }\n    else if (typeof value === 'number') {\n        return (0,_noble_hashes_sha2__WEBPACK_IMPORTED_MODULE_0__.sha256)((0,_dfinity_candid__WEBPACK_IMPORTED_MODULE_1__.lebEncode)(value));\n    }\n    else if (value instanceof Uint8Array || ArrayBuffer.isView(value)) {\n        return (0,_noble_hashes_sha2__WEBPACK_IMPORTED_MODULE_0__.sha256)((0,_utils_buffer_js__WEBPACK_IMPORTED_MODULE_2__.uint8FromBufLike)(value));\n    }\n    else if (Array.isArray(value)) {\n        const vals = value.map(hashValue);\n        return (0,_noble_hashes_sha2__WEBPACK_IMPORTED_MODULE_0__.sha256)((0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_3__.concatBytes)(...vals));\n    }\n    else if (value && typeof value === 'object' && value._isPrincipal) {\n        return (0,_noble_hashes_sha2__WEBPACK_IMPORTED_MODULE_0__.sha256)(value.toUint8Array());\n    }\n    else if (typeof value === 'object' &&\n        value !== null &&\n        typeof value.toHash === 'function') {\n        return hashValue(value.toHash());\n        // TODO This should be move to a specific async method as the webauthn flow required\n        // the flow to be synchronous to ensure Safari touch id works.\n        // } else if (value instanceof Promise) {\n        //   return value.then(x => hashValue(x));\n    }\n    else if (typeof value === 'object') {\n        return hashOfMap(value);\n    }\n    else if (typeof value === 'bigint') {\n        // Do this check much later than the other bigint check because this one is much less\n        // type-safe.\n        // So we want to try all the high-assurance type guards before this 'probable' one.\n        return (0,_noble_hashes_sha2__WEBPACK_IMPORTED_MODULE_0__.sha256)((0,_dfinity_candid__WEBPACK_IMPORTED_MODULE_1__.lebEncode)(value));\n    }\n    throw _errors_js__WEBPACK_IMPORTED_MODULE_4__.InputError.fromCode(new _errors_js__WEBPACK_IMPORTED_MODULE_4__.HashValueErrorCode(value));\n}\nconst hashString = (value) => {\n    const encoded = new TextEncoder().encode(value);\n    return (0,_noble_hashes_sha2__WEBPACK_IMPORTED_MODULE_0__.sha256)(encoded);\n};\n/**\n * Get the RequestId of the provided ic-ref request.\n * RequestId is the result of the representation-independent-hash function.\n * https://sdk.dfinity.org/docs/interface-spec/index.html#hash-of-map\n * @param request - ic-ref request to hash into RequestId\n */\nfunction requestIdOf(request) {\n    return hashOfMap(request);\n}\n/**\n * Hash a map into a Uint8Array using the representation-independent-hash function.\n * https://sdk.dfinity.org/docs/interface-spec/index.html#hash-of-map\n * @param map - Any non-nested object\n * @returns Uint8Array\n */\nfunction hashOfMap(map) {\n    const hashed = Object.entries(map)\n        .filter(([, value]) => value !== undefined)\n        .map(([key, value]) => {\n        const hashedKey = hashString(key);\n        const hashedValue = hashValue(value);\n        return [hashedKey, hashedValue];\n    });\n    const traversed = hashed;\n    const sorted = traversed.sort(([k1], [k2]) => {\n        return (0,_dfinity_candid__WEBPACK_IMPORTED_MODULE_5__.compare)(k1, k2);\n    });\n    const concatenated = (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_3__.concatBytes)(...sorted.map(x => (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_3__.concatBytes)(...x)));\n    const result = (0,_noble_hashes_sha2__WEBPACK_IMPORTED_MODULE_0__.sha256)(concatenated);\n    return result;\n}\n//# sourceMappingURL=request_id.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vcGFja2FnZXMvc2RrLWpzL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL3JlcXVlc3RfaWQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQXFEO0FBQ1E7QUFDUjtBQUNIO0FBQ047QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDBEQUFNLENBQUMsMERBQVM7QUFDL0I7QUFDQTtBQUNBLGVBQWUsMERBQU0sQ0FBQyxrRUFBZ0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsZUFBZSwwREFBTSxDQUFDLGdFQUFXO0FBQ2pDO0FBQ0E7QUFDQSxlQUFlLDBEQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMERBQU0sQ0FBQywwREFBUztBQUMvQjtBQUNBLFVBQVUsa0RBQVUsY0FBYywwREFBa0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0EsV0FBVywwREFBTTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxlQUFlLHdEQUFPO0FBQ3RCLEtBQUs7QUFDTCx5QkFBeUIsZ0VBQVcsb0JBQW9CLGdFQUFXO0FBQ25FLG1CQUFtQiwwREFBTTtBQUN6QjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AaXF1YmUvb3BzLWNvbnNvbGUvLi4vLi4vcGFja2FnZXMvc2RrLWpzL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL3JlcXVlc3RfaWQuanM/MGYyNyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBsZWJFbmNvZGUsIGNvbXBhcmUgfSBmcm9tICdAZGZpbml0eS9jYW5kaWQnO1xuaW1wb3J0IHsgSGFzaFZhbHVlRXJyb3JDb2RlLCBJbnB1dEVycm9yIH0gZnJvbSBcIi4vZXJyb3JzLmpzXCI7XG5pbXBvcnQgeyB1aW50OEZyb21CdWZMaWtlIH0gZnJvbSBcIi4vdXRpbHMvYnVmZmVyLmpzXCI7XG5pbXBvcnQgeyBjb25jYXRCeXRlcyB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvdXRpbHMnO1xuaW1wb3J0IHsgc2hhMjU2IH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9zaGEyJztcbi8qKlxuICpcbiAqIEBwYXJhbSB2YWx1ZSB1bmtub3duIHZhbHVlXG4gKiBAcmV0dXJucyBVaW50OEFycmF5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYXNoVmFsdWUodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gaGFzaFN0cmluZyh2YWx1ZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIHNoYTI1NihsZWJFbmNvZGUodmFsdWUpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8IEFycmF5QnVmZmVyLmlzVmlldyh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHNoYTI1Nih1aW50OEZyb21CdWZMaWtlKHZhbHVlKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIGNvbnN0IHZhbHMgPSB2YWx1ZS5tYXAoaGFzaFZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHNoYTI1Nihjb25jYXRCeXRlcyguLi52YWxzKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUuX2lzUHJpbmNpcGFsKSB7XG4gICAgICAgIHJldHVybiBzaGEyNTYodmFsdWUudG9VaW50OEFycmF5KCkpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG4gICAgICAgIHZhbHVlICE9PSBudWxsICYmXG4gICAgICAgIHR5cGVvZiB2YWx1ZS50b0hhc2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGhhc2hWYWx1ZSh2YWx1ZS50b0hhc2goKSk7XG4gICAgICAgIC8vIFRPRE8gVGhpcyBzaG91bGQgYmUgbW92ZSB0byBhIHNwZWNpZmljIGFzeW5jIG1ldGhvZCBhcyB0aGUgd2ViYXV0aG4gZmxvdyByZXF1aXJlZFxuICAgICAgICAvLyB0aGUgZmxvdyB0byBiZSBzeW5jaHJvbm91cyB0byBlbnN1cmUgU2FmYXJpIHRvdWNoIGlkIHdvcmtzLlxuICAgICAgICAvLyB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAvLyAgIHJldHVybiB2YWx1ZS50aGVuKHggPT4gaGFzaFZhbHVlKHgpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gaGFzaE9mTWFwKHZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYmlnaW50Jykge1xuICAgICAgICAvLyBEbyB0aGlzIGNoZWNrIG11Y2ggbGF0ZXIgdGhhbiB0aGUgb3RoZXIgYmlnaW50IGNoZWNrIGJlY2F1c2UgdGhpcyBvbmUgaXMgbXVjaCBsZXNzXG4gICAgICAgIC8vIHR5cGUtc2FmZS5cbiAgICAgICAgLy8gU28gd2Ugd2FudCB0byB0cnkgYWxsIHRoZSBoaWdoLWFzc3VyYW5jZSB0eXBlIGd1YXJkcyBiZWZvcmUgdGhpcyAncHJvYmFibGUnIG9uZS5cbiAgICAgICAgcmV0dXJuIHNoYTI1NihsZWJFbmNvZGUodmFsdWUpKTtcbiAgICB9XG4gICAgdGhyb3cgSW5wdXRFcnJvci5mcm9tQ29kZShuZXcgSGFzaFZhbHVlRXJyb3JDb2RlKHZhbHVlKSk7XG59XG5jb25zdCBoYXNoU3RyaW5nID0gKHZhbHVlKSA9PiB7XG4gICAgY29uc3QgZW5jb2RlZCA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZSh2YWx1ZSk7XG4gICAgcmV0dXJuIHNoYTI1NihlbmNvZGVkKTtcbn07XG4vKipcbiAqIEdldCB0aGUgUmVxdWVzdElkIG9mIHRoZSBwcm92aWRlZCBpYy1yZWYgcmVxdWVzdC5cbiAqIFJlcXVlc3RJZCBpcyB0aGUgcmVzdWx0IG9mIHRoZSByZXByZXNlbnRhdGlvbi1pbmRlcGVuZGVudC1oYXNoIGZ1bmN0aW9uLlxuICogaHR0cHM6Ly9zZGsuZGZpbml0eS5vcmcvZG9jcy9pbnRlcmZhY2Utc3BlYy9pbmRleC5odG1sI2hhc2gtb2YtbWFwXG4gKiBAcGFyYW0gcmVxdWVzdCAtIGljLXJlZiByZXF1ZXN0IHRvIGhhc2ggaW50byBSZXF1ZXN0SWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlcXVlc3RJZE9mKHJlcXVlc3QpIHtcbiAgICByZXR1cm4gaGFzaE9mTWFwKHJlcXVlc3QpO1xufVxuLyoqXG4gKiBIYXNoIGEgbWFwIGludG8gYSBVaW50OEFycmF5IHVzaW5nIHRoZSByZXByZXNlbnRhdGlvbi1pbmRlcGVuZGVudC1oYXNoIGZ1bmN0aW9uLlxuICogaHR0cHM6Ly9zZGsuZGZpbml0eS5vcmcvZG9jcy9pbnRlcmZhY2Utc3BlYy9pbmRleC5odG1sI2hhc2gtb2YtbWFwXG4gKiBAcGFyYW0gbWFwIC0gQW55IG5vbi1uZXN0ZWQgb2JqZWN0XG4gKiBAcmV0dXJucyBVaW50OEFycmF5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYXNoT2ZNYXAobWFwKSB7XG4gICAgY29uc3QgaGFzaGVkID0gT2JqZWN0LmVudHJpZXMobWFwKVxuICAgICAgICAuZmlsdGVyKChbLCB2YWx1ZV0pID0+IHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgIC5tYXAoKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICBjb25zdCBoYXNoZWRLZXkgPSBoYXNoU3RyaW5nKGtleSk7XG4gICAgICAgIGNvbnN0IGhhc2hlZFZhbHVlID0gaGFzaFZhbHVlKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIFtoYXNoZWRLZXksIGhhc2hlZFZhbHVlXTtcbiAgICB9KTtcbiAgICBjb25zdCB0cmF2ZXJzZWQgPSBoYXNoZWQ7XG4gICAgY29uc3Qgc29ydGVkID0gdHJhdmVyc2VkLnNvcnQoKFtrMV0sIFtrMl0pID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbXBhcmUoazEsIGsyKTtcbiAgICB9KTtcbiAgICBjb25zdCBjb25jYXRlbmF0ZWQgPSBjb25jYXRCeXRlcyguLi5zb3J0ZWQubWFwKHggPT4gY29uY2F0Qnl0ZXMoLi4ueCkpKTtcbiAgICBjb25zdCByZXN1bHQgPSBzaGEyNTYoY29uY2F0ZW5hdGVkKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVxdWVzdF9pZC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/request_id.js\n");

/***/ }),

/***/ "(ssr)/../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/utils/bls.js":
/*!******************************************************************************!*\
  !*** ../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/utils/bls.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   blsVerify: () => (/* binding */ blsVerify),\n/* harmony export */   verify: () => (/* binding */ verify)\n/* harmony export */ });\n/* harmony import */ var _noble_curves_bls12_381__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/curves/bls12-381 */ \"(ssr)/../../packages/sdk-js/node_modules/@noble/curves/esm/bls12-381.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/utils */ \"(ssr)/../../packages/sdk-js/node_modules/@noble/hashes/esm/utils.js\");\n\n\nlet verify;\n/**\n *\n * @param pk primary key: Uint8Array\n * @param sig signature: Uint8Array\n * @param msg message: Uint8Array\n * @returns boolean\n */\nfunction blsVerify(pk, sig, msg) {\n    const primaryKey = typeof pk === 'string' ? pk : (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(pk);\n    const signature = typeof sig === 'string' ? sig : (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(sig);\n    const message = typeof msg === 'string' ? msg : (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(msg);\n    return _noble_curves_bls12_381__WEBPACK_IMPORTED_MODULE_1__.bls12_381.verifyShortSignature(signature, message, primaryKey);\n}\n//# sourceMappingURL=bls.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vcGFja2FnZXMvc2RrLWpzL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL3V0aWxzL2Jscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQW9EO0FBQ0g7QUFDMUM7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AscURBQXFELCtEQUFVO0FBQy9ELHNEQUFzRCwrREFBVTtBQUNoRSxvREFBb0QsK0RBQVU7QUFDOUQsV0FBVyw4REFBUztBQUNwQjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGlxdWJlL29wcy1jb25zb2xlLy4uLy4uL3BhY2thZ2VzL3Nkay1qcy9ub2RlX21vZHVsZXMvQGRmaW5pdHkvYWdlbnQvbGliL2VzbS91dGlscy9ibHMuanM/NmYyYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBibHMxMl8zODEgfSBmcm9tICdAbm9ibGUvY3VydmVzL2JsczEyLTM4MSc7XG5pbXBvcnQgeyBieXRlc1RvSGV4IH0gZnJvbSAnQG5vYmxlL2hhc2hlcy91dGlscyc7XG5leHBvcnQgbGV0IHZlcmlmeTtcbi8qKlxuICpcbiAqIEBwYXJhbSBwayBwcmltYXJ5IGtleTogVWludDhBcnJheVxuICogQHBhcmFtIHNpZyBzaWduYXR1cmU6IFVpbnQ4QXJyYXlcbiAqIEBwYXJhbSBtc2cgbWVzc2FnZTogVWludDhBcnJheVxuICogQHJldHVybnMgYm9vbGVhblxuICovXG5leHBvcnQgZnVuY3Rpb24gYmxzVmVyaWZ5KHBrLCBzaWcsIG1zZykge1xuICAgIGNvbnN0IHByaW1hcnlLZXkgPSB0eXBlb2YgcGsgPT09ICdzdHJpbmcnID8gcGsgOiBieXRlc1RvSGV4KHBrKTtcbiAgICBjb25zdCBzaWduYXR1cmUgPSB0eXBlb2Ygc2lnID09PSAnc3RyaW5nJyA/IHNpZyA6IGJ5dGVzVG9IZXgoc2lnKTtcbiAgICBjb25zdCBtZXNzYWdlID0gdHlwZW9mIG1zZyA9PT0gJ3N0cmluZycgPyBtc2cgOiBieXRlc1RvSGV4KG1zZyk7XG4gICAgcmV0dXJuIGJsczEyXzM4MS52ZXJpZnlTaG9ydFNpZ25hdHVyZShzaWduYXR1cmUsIG1lc3NhZ2UsIHByaW1hcnlLZXkpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmxzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/utils/bls.js\n");

/***/ }),

/***/ "(ssr)/../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/utils/buffer.js":
/*!*********************************************************************************!*\
  !*** ../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/utils/buffer.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   uint8Equals: () => (/* binding */ uint8Equals),\n/* harmony export */   uint8FromBufLike: () => (/* binding */ uint8FromBufLike),\n/* harmony export */   uint8ToBuf: () => (/* binding */ uint8ToBuf)\n/* harmony export */ });\n/**\n * Returns a true Uint8Array from an ArrayBufferLike object.\n * @param bufLike a buffer-like object\n * @returns Uint8Array\n */\nfunction uint8FromBufLike(bufLike) {\n    if (!bufLike) {\n        throw new Error('Input cannot be null or undefined');\n    }\n    if (bufLike instanceof Uint8Array) {\n        return bufLike;\n    }\n    if (bufLike instanceof ArrayBuffer) {\n        return new Uint8Array(bufLike);\n    }\n    if (Array.isArray(bufLike)) {\n        return new Uint8Array(bufLike);\n    }\n    if ('buffer' in bufLike) {\n        return uint8FromBufLike(bufLike.buffer);\n    }\n    return new Uint8Array(bufLike);\n}\n/**\n * Returns a true ArrayBuffer from a Uint8Array, as Uint8Array.buffer is unsafe.\n * @param {Uint8Array} arr Uint8Array to convert\n * @returns ArrayBuffer\n */\nfunction uint8ToBuf(arr) {\n    const buf = new ArrayBuffer(arr.byteLength);\n    const view = new Uint8Array(buf);\n    view.set(arr);\n    return buf;\n}\n/**\n * Compares two Uint8Arrays for equality.\n * @param a The first Uint8Array.\n * @param b The second Uint8Array.\n * @returns True if the Uint8Arrays are equal, false otherwise.\n */\nfunction uint8Equals(a, b) {\n    if (a.length !== b.length)\n        return false;\n    for (let i = 0; i < a.length; i++) {\n        if (a[i] !== b[i])\n            return false;\n    }\n    return true;\n}\n//# sourceMappingURL=buffer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vcGFja2FnZXMvc2RrLWpzL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL3V0aWxzL2J1ZmZlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QjtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGlxdWJlL29wcy1jb25zb2xlLy4uLy4uL3BhY2thZ2VzL3Nkay1qcy9ub2RlX21vZHVsZXMvQGRmaW5pdHkvYWdlbnQvbGliL2VzbS91dGlscy9idWZmZXIuanM/N2Q0NyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFJldHVybnMgYSB0cnVlIFVpbnQ4QXJyYXkgZnJvbSBhbiBBcnJheUJ1ZmZlckxpa2Ugb2JqZWN0LlxuICogQHBhcmFtIGJ1Zkxpa2UgYSBidWZmZXItbGlrZSBvYmplY3RcbiAqIEByZXR1cm5zIFVpbnQ4QXJyYXlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVpbnQ4RnJvbUJ1Zkxpa2UoYnVmTGlrZSkge1xuICAgIGlmICghYnVmTGlrZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IGNhbm5vdCBiZSBudWxsIG9yIHVuZGVmaW5lZCcpO1xuICAgIH1cbiAgICBpZiAoYnVmTGlrZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIGJ1Zkxpa2U7XG4gICAgfVxuICAgIGlmIChidWZMaWtlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJ1Zkxpa2UpO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShidWZMaWtlKSkge1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnVmTGlrZSk7XG4gICAgfVxuICAgIGlmICgnYnVmZmVyJyBpbiBidWZMaWtlKSB7XG4gICAgICAgIHJldHVybiB1aW50OEZyb21CdWZMaWtlKGJ1Zkxpa2UuYnVmZmVyKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJ1Zkxpa2UpO1xufVxuLyoqXG4gKiBSZXR1cm5zIGEgdHJ1ZSBBcnJheUJ1ZmZlciBmcm9tIGEgVWludDhBcnJheSwgYXMgVWludDhBcnJheS5idWZmZXIgaXMgdW5zYWZlLlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBhcnIgVWludDhBcnJheSB0byBjb252ZXJ0XG4gKiBAcmV0dXJucyBBcnJheUJ1ZmZlclxuICovXG5leHBvcnQgZnVuY3Rpb24gdWludDhUb0J1ZihhcnIpIHtcbiAgICBjb25zdCBidWYgPSBuZXcgQXJyYXlCdWZmZXIoYXJyLmJ5dGVMZW5ndGgpO1xuICAgIGNvbnN0IHZpZXcgPSBuZXcgVWludDhBcnJheShidWYpO1xuICAgIHZpZXcuc2V0KGFycik7XG4gICAgcmV0dXJuIGJ1Zjtcbn1cbi8qKlxuICogQ29tcGFyZXMgdHdvIFVpbnQ4QXJyYXlzIGZvciBlcXVhbGl0eS5cbiAqIEBwYXJhbSBhIFRoZSBmaXJzdCBVaW50OEFycmF5LlxuICogQHBhcmFtIGIgVGhlIHNlY29uZCBVaW50OEFycmF5LlxuICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgVWludDhBcnJheXMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1aW50OEVxdWFscyhhLCBiKSB7XG4gICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoYVtpXSAhPT0gYltpXSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1idWZmZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/utils/buffer.js\n");

/***/ }),

/***/ "(ssr)/../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/utils/expirableMap.js":
/*!***************************************************************************************!*\
  !*** ../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/utils/expirableMap.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ExpirableMap: () => (/* binding */ ExpirableMap)\n/* harmony export */ });\nvar _a, _b;\n/**\n * A map that expires entries after a given time.\n * Defaults to 10 minutes.\n */\nclass ExpirableMap {\n    static { _a = Symbol.iterator, _b = Symbol.toStringTag; }\n    // Internals\n    #inner;\n    #expirationTime;\n    /**\n     * Create a new ExpirableMap.\n     * @param {ExpirableMapOptions<any, any>} options - options for the map.\n     * @param {Iterable<[any, any]>} options.source - an optional source of entries to initialize the map with.\n     * @param {number} options.expirationTime - the time in milliseconds after which entries will expire.\n     */\n    constructor(options = {}) {\n        this[_a] = this.entries.bind(this);\n        this[_b] = 'ExpirableMap';\n        const { source = [], expirationTime = 10 * 60 * 1000 } = options;\n        const currentTime = Date.now();\n        this.#inner = new Map([...source].map(([key, value]) => [key, { value, timestamp: currentTime }]));\n        this.#expirationTime = expirationTime;\n    }\n    /**\n     * Prune removes all expired entries.\n     */\n    prune() {\n        const currentTime = Date.now();\n        for (const [key, entry] of this.#inner.entries()) {\n            if (currentTime - entry.timestamp > this.#expirationTime) {\n                this.#inner.delete(key);\n            }\n        }\n        return this;\n    }\n    // Implementing the Map interface\n    /**\n     * Set the value for the given key. Prunes expired entries.\n     * @param key for the entry\n     * @param value of the entry\n     * @returns this\n     */\n    set(key, value) {\n        this.prune();\n        const entry = {\n            value,\n            timestamp: Date.now(),\n        };\n        this.#inner.set(key, entry);\n        return this;\n    }\n    /**\n     * Get the value associated with the key, if it exists and has not expired.\n     * @param key K\n     * @returns the value associated with the key, or undefined if the key is not present or has expired.\n     */\n    get(key) {\n        const entry = this.#inner.get(key);\n        if (entry === undefined) {\n            return undefined;\n        }\n        if (Date.now() - entry.timestamp > this.#expirationTime) {\n            this.#inner.delete(key);\n            return undefined;\n        }\n        return entry.value;\n    }\n    /**\n     * Clear all entries.\n     */\n    clear() {\n        this.#inner.clear();\n    }\n    /**\n     * Entries returns the entries of the map, without the expiration time.\n     * @returns an iterator over the entries of the map.\n     */\n    entries() {\n        const iterator = this.#inner.entries();\n        const generator = function* () {\n            for (const [key, value] of iterator) {\n                yield [key, value.value];\n            }\n            return undefined;\n        };\n        return generator();\n    }\n    /**\n     * Values returns the values of the map, without the expiration time.\n     * @returns an iterator over the values of the map.\n     */\n    values() {\n        const iterator = this.#inner.values();\n        const generator = function* () {\n            for (const value of iterator) {\n                yield value.value;\n            }\n            return undefined;\n        };\n        return generator();\n    }\n    /**\n     * Keys returns the keys of the map\n     * @returns an iterator over the keys of the map.\n     */\n    keys() {\n        return this.#inner.keys();\n    }\n    /**\n     * forEach calls the callbackfn on each entry of the map.\n     * @param callbackfn to call on each entry\n     * @param thisArg to use as this when calling the callbackfn\n     */\n    forEach(callbackfn, thisArg) {\n        for (const [key, value] of this.#inner.entries()) {\n            callbackfn.call(thisArg, value.value, key, this);\n        }\n    }\n    /**\n     * has returns true if the key exists and has not expired.\n     * @param key K\n     * @returns true if the key exists and has not expired.\n     */\n    has(key) {\n        return this.#inner.has(key);\n    }\n    /**\n     * delete the entry for the given key.\n     * @param key K\n     * @returns true if the key existed and has been deleted.\n     */\n    delete(key) {\n        return this.#inner.delete(key);\n    }\n    /**\n     * get size of the map.\n     * @returns the size of the map.\n     */\n    get size() {\n        return this.#inner.size;\n    }\n}\n//# sourceMappingURL=expirableMap.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vcGFja2FnZXMvc2RrLWpzL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL3V0aWxzL2V4cGlyYWJsZU1hcC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLCtCQUErQjtBQUM5QyxlQUFlLHNCQUFzQjtBQUNyQyxlQUFlLFFBQVE7QUFDdkI7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBLGdCQUFnQiwrQ0FBK0M7QUFDL0Q7QUFDQSx3RUFBd0UsK0JBQStCO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AaXF1YmUvb3BzLWNvbnNvbGUvLi4vLi4vcGFja2FnZXMvc2RrLWpzL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL3V0aWxzL2V4cGlyYWJsZU1hcC5qcz9hMGI4Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBfYSwgX2I7XG4vKipcbiAqIEEgbWFwIHRoYXQgZXhwaXJlcyBlbnRyaWVzIGFmdGVyIGEgZ2l2ZW4gdGltZS5cbiAqIERlZmF1bHRzIHRvIDEwIG1pbnV0ZXMuXG4gKi9cbmV4cG9ydCBjbGFzcyBFeHBpcmFibGVNYXAge1xuICAgIHN0YXRpYyB7IF9hID0gU3ltYm9sLml0ZXJhdG9yLCBfYiA9IFN5bWJvbC50b1N0cmluZ1RhZzsgfVxuICAgIC8vIEludGVybmFsc1xuICAgICNpbm5lcjtcbiAgICAjZXhwaXJhdGlvblRpbWU7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IEV4cGlyYWJsZU1hcC5cbiAgICAgKiBAcGFyYW0ge0V4cGlyYWJsZU1hcE9wdGlvbnM8YW55LCBhbnk+fSBvcHRpb25zIC0gb3B0aW9ucyBmb3IgdGhlIG1hcC5cbiAgICAgKiBAcGFyYW0ge0l0ZXJhYmxlPFthbnksIGFueV0+fSBvcHRpb25zLnNvdXJjZSAtIGFuIG9wdGlvbmFsIHNvdXJjZSBvZiBlbnRyaWVzIHRvIGluaXRpYWxpemUgdGhlIG1hcCB3aXRoLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLmV4cGlyYXRpb25UaW1lIC0gdGhlIHRpbWUgaW4gbWlsbGlzZWNvbmRzIGFmdGVyIHdoaWNoIGVudHJpZXMgd2lsbCBleHBpcmUuXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHRoaXNbX2FdID0gdGhpcy5lbnRyaWVzLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXNbX2JdID0gJ0V4cGlyYWJsZU1hcCc7XG4gICAgICAgIGNvbnN0IHsgc291cmNlID0gW10sIGV4cGlyYXRpb25UaW1lID0gMTAgKiA2MCAqIDEwMDAgfSA9IG9wdGlvbnM7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdGhpcy4jaW5uZXIgPSBuZXcgTWFwKFsuLi5zb3VyY2VdLm1hcCgoW2tleSwgdmFsdWVdKSA9PiBba2V5LCB7IHZhbHVlLCB0aW1lc3RhbXA6IGN1cnJlbnRUaW1lIH1dKSk7XG4gICAgICAgIHRoaXMuI2V4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBydW5lIHJlbW92ZXMgYWxsIGV4cGlyZWQgZW50cmllcy5cbiAgICAgKi9cbiAgICBwcnVuZSgpIHtcbiAgICAgICAgY29uc3QgY3VycmVudFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIGVudHJ5XSBvZiB0aGlzLiNpbm5lci5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50VGltZSAtIGVudHJ5LnRpbWVzdGFtcCA+IHRoaXMuI2V4cGlyYXRpb25UaW1lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4jaW5uZXIuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vIEltcGxlbWVudGluZyB0aGUgTWFwIGludGVyZmFjZVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgdmFsdWUgZm9yIHRoZSBnaXZlbiBrZXkuIFBydW5lcyBleHBpcmVkIGVudHJpZXMuXG4gICAgICogQHBhcmFtIGtleSBmb3IgdGhlIGVudHJ5XG4gICAgICogQHBhcmFtIHZhbHVlIG9mIHRoZSBlbnRyeVxuICAgICAqIEByZXR1cm5zIHRoaXNcbiAgICAgKi9cbiAgICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLnBydW5lKCk7XG4gICAgICAgIGNvbnN0IGVudHJ5ID0ge1xuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuI2lubmVyLnNldChrZXksIGVudHJ5KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIHRoZSBrZXksIGlmIGl0IGV4aXN0cyBhbmQgaGFzIG5vdCBleHBpcmVkLlxuICAgICAqIEBwYXJhbSBrZXkgS1xuICAgICAqIEByZXR1cm5zIHRoZSB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggdGhlIGtleSwgb3IgdW5kZWZpbmVkIGlmIHRoZSBrZXkgaXMgbm90IHByZXNlbnQgb3IgaGFzIGV4cGlyZWQuXG4gICAgICovXG4gICAgZ2V0KGtleSkge1xuICAgICAgICBjb25zdCBlbnRyeSA9IHRoaXMuI2lubmVyLmdldChrZXkpO1xuICAgICAgICBpZiAoZW50cnkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoRGF0ZS5ub3coKSAtIGVudHJ5LnRpbWVzdGFtcCA+IHRoaXMuI2V4cGlyYXRpb25UaW1lKSB7XG4gICAgICAgICAgICB0aGlzLiNpbm5lci5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVudHJ5LnZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbGVhciBhbGwgZW50cmllcy5cbiAgICAgKi9cbiAgICBjbGVhcigpIHtcbiAgICAgICAgdGhpcy4jaW5uZXIuY2xlYXIoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW50cmllcyByZXR1cm5zIHRoZSBlbnRyaWVzIG9mIHRoZSBtYXAsIHdpdGhvdXQgdGhlIGV4cGlyYXRpb24gdGltZS5cbiAgICAgKiBAcmV0dXJucyBhbiBpdGVyYXRvciBvdmVyIHRoZSBlbnRyaWVzIG9mIHRoZSBtYXAuXG4gICAgICovXG4gICAgZW50cmllcygpIHtcbiAgICAgICAgY29uc3QgaXRlcmF0b3IgPSB0aGlzLiNpbm5lci5lbnRyaWVzKCk7XG4gICAgICAgIGNvbnN0IGdlbmVyYXRvciA9IGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBpdGVyYXRvcikge1xuICAgICAgICAgICAgICAgIHlpZWxkIFtrZXksIHZhbHVlLnZhbHVlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBnZW5lcmF0b3IoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVmFsdWVzIHJldHVybnMgdGhlIHZhbHVlcyBvZiB0aGUgbWFwLCB3aXRob3V0IHRoZSBleHBpcmF0aW9uIHRpbWUuXG4gICAgICogQHJldHVybnMgYW4gaXRlcmF0b3Igb3ZlciB0aGUgdmFsdWVzIG9mIHRoZSBtYXAuXG4gICAgICovXG4gICAgdmFsdWVzKCkge1xuICAgICAgICBjb25zdCBpdGVyYXRvciA9IHRoaXMuI2lubmVyLnZhbHVlcygpO1xuICAgICAgICBjb25zdCBnZW5lcmF0b3IgPSBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiBpdGVyYXRvcikge1xuICAgICAgICAgICAgICAgIHlpZWxkIHZhbHVlLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGdlbmVyYXRvcigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBLZXlzIHJldHVybnMgdGhlIGtleXMgb2YgdGhlIG1hcFxuICAgICAqIEByZXR1cm5zIGFuIGl0ZXJhdG9yIG92ZXIgdGhlIGtleXMgb2YgdGhlIG1hcC5cbiAgICAgKi9cbiAgICBrZXlzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jaW5uZXIua2V5cygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBmb3JFYWNoIGNhbGxzIHRoZSBjYWxsYmFja2ZuIG9uIGVhY2ggZW50cnkgb2YgdGhlIG1hcC5cbiAgICAgKiBAcGFyYW0gY2FsbGJhY2tmbiB0byBjYWxsIG9uIGVhY2ggZW50cnlcbiAgICAgKiBAcGFyYW0gdGhpc0FyZyB0byB1c2UgYXMgdGhpcyB3aGVuIGNhbGxpbmcgdGhlIGNhbGxiYWNrZm5cbiAgICAgKi9cbiAgICBmb3JFYWNoKGNhbGxiYWNrZm4sIHRoaXNBcmcpIHtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgdGhpcy4jaW5uZXIuZW50cmllcygpKSB7XG4gICAgICAgICAgICBjYWxsYmFja2ZuLmNhbGwodGhpc0FyZywgdmFsdWUudmFsdWUsIGtleSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogaGFzIHJldHVybnMgdHJ1ZSBpZiB0aGUga2V5IGV4aXN0cyBhbmQgaGFzIG5vdCBleHBpcmVkLlxuICAgICAqIEBwYXJhbSBrZXkgS1xuICAgICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIGtleSBleGlzdHMgYW5kIGhhcyBub3QgZXhwaXJlZC5cbiAgICAgKi9cbiAgICBoYXMoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNpbm5lci5oYXMoa2V5KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogZGVsZXRlIHRoZSBlbnRyeSBmb3IgdGhlIGdpdmVuIGtleS5cbiAgICAgKiBAcGFyYW0ga2V5IEtcbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBrZXkgZXhpc3RlZCBhbmQgaGFzIGJlZW4gZGVsZXRlZC5cbiAgICAgKi9cbiAgICBkZWxldGUoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNpbm5lci5kZWxldGUoa2V5KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogZ2V0IHNpemUgb2YgdGhlIG1hcC5cbiAgICAgKiBAcmV0dXJucyB0aGUgc2l6ZSBvZiB0aGUgbWFwLlxuICAgICAqL1xuICAgIGdldCBzaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jaW5uZXIuc2l6ZTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1leHBpcmFibGVNYXAuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/utils/expirableMap.js\n");

/***/ }),

/***/ "(ssr)/../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/utils/leb.js":
/*!******************************************************************************!*\
  !*** ../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/utils/leb.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decodeLeb128: () => (/* binding */ decodeLeb128),\n/* harmony export */   decodeTime: () => (/* binding */ decodeTime)\n/* harmony export */ });\n/* harmony import */ var _dfinity_candid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @dfinity/candid */ \"(ssr)/../../packages/sdk-js/node_modules/@dfinity/candid/lib/esm/utils/leb128.js\");\n/* harmony import */ var _dfinity_candid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @dfinity/candid */ \"(ssr)/../../packages/sdk-js/node_modules/@dfinity/candid/lib/esm/utils/buffer.js\");\n\nconst MILLISECOND_TO_NANOSECONDS = BigInt(1_000_000);\nconst decodeLeb128 = (buf) => {\n    return (0,_dfinity_candid__WEBPACK_IMPORTED_MODULE_0__.lebDecode)(new _dfinity_candid__WEBPACK_IMPORTED_MODULE_1__.PipeArrayBuffer(buf));\n};\n// time is a LEB128-encoded Nat\nconst decodeTime = (buf) => {\n    const timestampNs = decodeLeb128(buf);\n    const timestampMs = timestampNs / MILLISECOND_TO_NANOSECONDS;\n    return new Date(Number(timestampMs));\n};\n//# sourceMappingURL=leb.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vcGFja2FnZXMvc2RrLWpzL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL3V0aWxzL2xlYi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQTZEO0FBQzdEO0FBQ087QUFDUCxXQUFXLDBEQUFTLEtBQUssNERBQWU7QUFDeEM7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BpcXViZS9vcHMtY29uc29sZS8uLi8uLi9wYWNrYWdlcy9zZGstanMvbm9kZV9tb2R1bGVzL0BkZmluaXR5L2FnZW50L2xpYi9lc20vdXRpbHMvbGViLmpzP2JkZmEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUGlwZUFycmF5QnVmZmVyLCBsZWJEZWNvZGUgfSBmcm9tICdAZGZpbml0eS9jYW5kaWQnO1xuY29uc3QgTUlMTElTRUNPTkRfVE9fTkFOT1NFQ09ORFMgPSBCaWdJbnQoMV8wMDBfMDAwKTtcbmV4cG9ydCBjb25zdCBkZWNvZGVMZWIxMjggPSAoYnVmKSA9PiB7XG4gICAgcmV0dXJuIGxlYkRlY29kZShuZXcgUGlwZUFycmF5QnVmZmVyKGJ1ZikpO1xufTtcbi8vIHRpbWUgaXMgYSBMRUIxMjgtZW5jb2RlZCBOYXRcbmV4cG9ydCBjb25zdCBkZWNvZGVUaW1lID0gKGJ1ZikgPT4ge1xuICAgIGNvbnN0IHRpbWVzdGFtcE5zID0gZGVjb2RlTGViMTI4KGJ1Zik7XG4gICAgY29uc3QgdGltZXN0YW1wTXMgPSB0aW1lc3RhbXBOcyAvIE1JTExJU0VDT05EX1RPX05BTk9TRUNPTkRTO1xuICAgIHJldHVybiBuZXcgRGF0ZShOdW1iZXIodGltZXN0YW1wTXMpKTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sZWIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/utils/leb.js\n");

/***/ }),

/***/ "(ssr)/../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/utils/random.js":
/*!*********************************************************************************!*\
  !*** ../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/utils/random.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   randomNumber: () => (/* binding */ randomNumber)\n/* harmony export */ });\n/**\n * Generates a random unsigned 32-bit integer between 0 and 0xffffffff\n * @returns {number} a random number\n */\nconst randomNumber = () => {\n    // determine whether browser crypto is available\n    if (typeof window !== 'undefined' && !!window.crypto && !!window.crypto.getRandomValues) {\n        const array = new Uint32Array(1);\n        window.crypto.getRandomValues(array);\n        return array[0];\n    }\n    // A second check for webcrypto, in case it is loaded under global instead of window\n    if (typeof crypto !== 'undefined' && crypto.getRandomValues) {\n        const array = new Uint32Array(1);\n        crypto.getRandomValues(array);\n        return array[0];\n    }\n    // determine whether node crypto is available\n    if (typeof crypto !== 'undefined' && crypto.randomInt) {\n        return crypto.randomInt(0, 0xffffffff);\n    }\n    // fall back to Math.random\n    return Math.floor(Math.random() * 0xffffffff);\n};\n//# sourceMappingURL=random.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vcGFja2FnZXMvc2RrLWpzL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL3V0aWxzL3JhbmRvbS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BpcXViZS9vcHMtY29uc29sZS8uLi8uLi9wYWNrYWdlcy9zZGstanMvbm9kZV9tb2R1bGVzL0BkZmluaXR5L2FnZW50L2xpYi9lc20vdXRpbHMvcmFuZG9tLmpzP2QxMGYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBHZW5lcmF0ZXMgYSByYW5kb20gdW5zaWduZWQgMzItYml0IGludGVnZXIgYmV0d2VlbiAwIGFuZCAweGZmZmZmZmZmXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBhIHJhbmRvbSBudW1iZXJcbiAqL1xuZXhwb3J0IGNvbnN0IHJhbmRvbU51bWJlciA9ICgpID0+IHtcbiAgICAvLyBkZXRlcm1pbmUgd2hldGhlciBicm93c2VyIGNyeXB0byBpcyBhdmFpbGFibGVcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgISF3aW5kb3cuY3J5cHRvICYmICEhd2luZG93LmNyeXB0by5nZXRSYW5kb21WYWx1ZXMpIHtcbiAgICAgICAgY29uc3QgYXJyYXkgPSBuZXcgVWludDMyQXJyYXkoMSk7XG4gICAgICAgIHdpbmRvdy5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGFycmF5KTtcbiAgICAgICAgcmV0dXJuIGFycmF5WzBdO1xuICAgIH1cbiAgICAvLyBBIHNlY29uZCBjaGVjayBmb3Igd2ViY3J5cHRvLCBpbiBjYXNlIGl0IGlzIGxvYWRlZCB1bmRlciBnbG9iYWwgaW5zdGVhZCBvZiB3aW5kb3dcbiAgICBpZiAodHlwZW9mIGNyeXB0byAhPT0gJ3VuZGVmaW5lZCcgJiYgY3J5cHRvLmdldFJhbmRvbVZhbHVlcykge1xuICAgICAgICBjb25zdCBhcnJheSA9IG5ldyBVaW50MzJBcnJheSgxKTtcbiAgICAgICAgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhhcnJheSk7XG4gICAgICAgIHJldHVybiBhcnJheVswXTtcbiAgICB9XG4gICAgLy8gZGV0ZXJtaW5lIHdoZXRoZXIgbm9kZSBjcnlwdG8gaXMgYXZhaWxhYmxlXG4gICAgaWYgKHR5cGVvZiBjcnlwdG8gIT09ICd1bmRlZmluZWQnICYmIGNyeXB0by5yYW5kb21JbnQpIHtcbiAgICAgICAgcmV0dXJuIGNyeXB0by5yYW5kb21JbnQoMCwgMHhmZmZmZmZmZik7XG4gICAgfVxuICAgIC8vIGZhbGwgYmFjayB0byBNYXRoLnJhbmRvbVxuICAgIHJldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAweGZmZmZmZmZmKTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yYW5kb20uanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/utils/random.js\n");

/***/ }),

/***/ "(ssr)/../../packages/sdk-js/node_modules/@dfinity/candid/lib/esm/idl.js":
/*!*************************************************************************!*\
  !*** ../../packages/sdk-js/node_modules/@dfinity/candid/lib/esm/idl.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Bool: () => (/* binding */ Bool),\n/* harmony export */   BoolClass: () => (/* binding */ BoolClass),\n/* harmony export */   ConstructType: () => (/* binding */ ConstructType),\n/* harmony export */   Empty: () => (/* binding */ Empty),\n/* harmony export */   EmptyClass: () => (/* binding */ EmptyClass),\n/* harmony export */   FixedIntClass: () => (/* binding */ FixedIntClass),\n/* harmony export */   FixedNatClass: () => (/* binding */ FixedNatClass),\n/* harmony export */   Float32: () => (/* binding */ Float32),\n/* harmony export */   Float64: () => (/* binding */ Float64),\n/* harmony export */   FloatClass: () => (/* binding */ FloatClass),\n/* harmony export */   Func: () => (/* binding */ Func),\n/* harmony export */   FuncClass: () => (/* binding */ FuncClass),\n/* harmony export */   Int: () => (/* binding */ Int),\n/* harmony export */   Int16: () => (/* binding */ Int16),\n/* harmony export */   Int32: () => (/* binding */ Int32),\n/* harmony export */   Int64: () => (/* binding */ Int64),\n/* harmony export */   Int8: () => (/* binding */ Int8),\n/* harmony export */   IntClass: () => (/* binding */ IntClass),\n/* harmony export */   Nat: () => (/* binding */ Nat),\n/* harmony export */   Nat16: () => (/* binding */ Nat16),\n/* harmony export */   Nat32: () => (/* binding */ Nat32),\n/* harmony export */   Nat64: () => (/* binding */ Nat64),\n/* harmony export */   Nat8: () => (/* binding */ Nat8),\n/* harmony export */   NatClass: () => (/* binding */ NatClass),\n/* harmony export */   Null: () => (/* binding */ Null),\n/* harmony export */   NullClass: () => (/* binding */ NullClass),\n/* harmony export */   Opt: () => (/* binding */ Opt),\n/* harmony export */   OptClass: () => (/* binding */ OptClass),\n/* harmony export */   PrimitiveType: () => (/* binding */ PrimitiveType),\n/* harmony export */   Principal: () => (/* binding */ Principal),\n/* harmony export */   PrincipalClass: () => (/* binding */ PrincipalClass),\n/* harmony export */   Rec: () => (/* binding */ Rec),\n/* harmony export */   RecClass: () => (/* binding */ RecClass),\n/* harmony export */   Record: () => (/* binding */ Record),\n/* harmony export */   RecordClass: () => (/* binding */ RecordClass),\n/* harmony export */   Reserved: () => (/* binding */ Reserved),\n/* harmony export */   ReservedClass: () => (/* binding */ ReservedClass),\n/* harmony export */   Service: () => (/* binding */ Service),\n/* harmony export */   ServiceClass: () => (/* binding */ ServiceClass),\n/* harmony export */   Text: () => (/* binding */ Text),\n/* harmony export */   TextClass: () => (/* binding */ TextClass),\n/* harmony export */   Tuple: () => (/* binding */ Tuple),\n/* harmony export */   TupleClass: () => (/* binding */ TupleClass),\n/* harmony export */   Type: () => (/* binding */ Type),\n/* harmony export */   Unknown: () => (/* binding */ Unknown),\n/* harmony export */   UnknownClass: () => (/* binding */ UnknownClass),\n/* harmony export */   Variant: () => (/* binding */ Variant),\n/* harmony export */   VariantClass: () => (/* binding */ VariantClass),\n/* harmony export */   Vec: () => (/* binding */ Vec),\n/* harmony export */   VecClass: () => (/* binding */ VecClass),\n/* harmony export */   Visitor: () => (/* binding */ Visitor),\n/* harmony export */   decode: () => (/* binding */ decode),\n/* harmony export */   encode: () => (/* binding */ encode),\n/* harmony export */   resetSubtypeCache: () => (/* binding */ resetSubtypeCache),\n/* harmony export */   subtype: () => (/* binding */ subtype)\n/* harmony export */ });\n/* harmony import */ var _dfinity_principal__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @dfinity/principal */ \"(ssr)/../../packages/sdk-js/node_modules/@dfinity/principal/lib/esm/principal.js\");\n/* harmony import */ var _utils_buffer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/buffer.js */ \"(ssr)/../../packages/sdk-js/node_modules/@dfinity/candid/lib/esm/utils/buffer.js\");\n/* harmony import */ var _utils_hash_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/hash.js */ \"(ssr)/../../packages/sdk-js/node_modules/@dfinity/candid/lib/esm/utils/hash.js\");\n/* harmony import */ var _utils_leb128_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/leb128.js */ \"(ssr)/../../packages/sdk-js/node_modules/@dfinity/candid/lib/esm/utils/leb128.js\");\n/* harmony import */ var _utils_bigint_math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/bigint-math.js */ \"(ssr)/../../packages/sdk-js/node_modules/@dfinity/candid/lib/esm/utils/bigint-math.js\");\n/* eslint-disable @typescript-eslint/no-unused-vars */\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\n\n\n\n\n/**\n * This module provides a combinator library to create serializers/deserializers\n * between JavaScript values and IDL used by canisters on the Internet Computer,\n * as documented at https://github.com/dfinity/candid/blob/119703ba342d2fef6ab4972d2541b9fe36ae8e36/spec/Candid.md\n */\nvar IDLTypeIds;\n(function (IDLTypeIds) {\n    IDLTypeIds[IDLTypeIds[\"Null\"] = -1] = \"Null\";\n    IDLTypeIds[IDLTypeIds[\"Bool\"] = -2] = \"Bool\";\n    IDLTypeIds[IDLTypeIds[\"Nat\"] = -3] = \"Nat\";\n    IDLTypeIds[IDLTypeIds[\"Int\"] = -4] = \"Int\";\n    IDLTypeIds[IDLTypeIds[\"Float32\"] = -13] = \"Float32\";\n    IDLTypeIds[IDLTypeIds[\"Float64\"] = -14] = \"Float64\";\n    IDLTypeIds[IDLTypeIds[\"Text\"] = -15] = \"Text\";\n    IDLTypeIds[IDLTypeIds[\"Reserved\"] = -16] = \"Reserved\";\n    IDLTypeIds[IDLTypeIds[\"Empty\"] = -17] = \"Empty\";\n    IDLTypeIds[IDLTypeIds[\"Opt\"] = -18] = \"Opt\";\n    IDLTypeIds[IDLTypeIds[\"Vector\"] = -19] = \"Vector\";\n    IDLTypeIds[IDLTypeIds[\"Record\"] = -20] = \"Record\";\n    IDLTypeIds[IDLTypeIds[\"Variant\"] = -21] = \"Variant\";\n    IDLTypeIds[IDLTypeIds[\"Func\"] = -22] = \"Func\";\n    IDLTypeIds[IDLTypeIds[\"Service\"] = -23] = \"Service\";\n    IDLTypeIds[IDLTypeIds[\"Principal\"] = -24] = \"Principal\";\n})(IDLTypeIds || (IDLTypeIds = {}));\nconst magicNumber = 'DIDL';\nconst toReadableString_max = 400; // will not display arguments after 400chars. Makes sure 2mb blobs don't get inside the error\nfunction zipWith(xs, ys, f) {\n    return xs.map((x, i) => f(x, ys[i]));\n}\n/**\n * An IDL Type Table, which precedes the data in the stream.\n */\nclass TypeTable {\n    constructor() {\n        // List of types. Needs to be an array as the index needs to be stable.\n        this._typs = [];\n        this._idx = new Map();\n        this._idxRefCount = new Map();\n    }\n    has(obj) {\n        return this._idx.has(obj.name);\n    }\n    add(type, buf) {\n        const idx = this._typs.length;\n        this._idx.set(type.name, idx);\n        this._idxRefCount.set(idx, 1);\n        this._typs.push(buf);\n    }\n    merge(obj, knot) {\n        const idx = this._idx.get(obj.name);\n        const knotIdx = this._idx.get(knot);\n        if (idx === undefined) {\n            throw new Error('Missing type index for ' + obj);\n        }\n        if (knotIdx === undefined) {\n            throw new Error('Missing type index for ' + knot);\n        }\n        this._typs[idx] = this._typs[knotIdx];\n        // Decrement reference count since we're removing the knot name mapping\n        const knotRefCount = this._getIdxRefCount(knotIdx);\n        this._idxRefCount.set(knotIdx, knotRefCount - 1);\n        this._idx.delete(knot);\n        this._compactFromEnd();\n    }\n    _getIdxRefCount(idx) {\n        return this._idxRefCount.get(idx) || 0;\n    }\n    _compactFromEnd() {\n        // Remove unused entries from the end of the array\n        while (this._typs.length > 0) {\n            const lastIndex = this._typs.length - 1;\n            if (this._getIdxRefCount(lastIndex) > 0) {\n                break;\n            }\n            this._typs.pop();\n            this._idxRefCount.delete(lastIndex);\n        }\n    }\n    encode() {\n        const len = (0,_utils_leb128_js__WEBPACK_IMPORTED_MODULE_0__.lebEncode)(this._typs.length);\n        const buf = (0,_utils_buffer_js__WEBPACK_IMPORTED_MODULE_1__.concat)(...this._typs);\n        return (0,_utils_buffer_js__WEBPACK_IMPORTED_MODULE_1__.concat)(len, buf);\n    }\n    indexOf(typeName) {\n        if (!this._idx.has(typeName)) {\n            throw new Error('Missing type index for ' + typeName);\n        }\n        return (0,_utils_leb128_js__WEBPACK_IMPORTED_MODULE_0__.slebEncode)(this._idx.get(typeName) || 0);\n    }\n}\nclass Visitor {\n    visitType(_t, _data) {\n        throw new Error('Not implemented');\n    }\n    visitPrimitive(t, data) {\n        return this.visitType(t, data);\n    }\n    visitEmpty(t, data) {\n        return this.visitPrimitive(t, data);\n    }\n    visitBool(t, data) {\n        return this.visitPrimitive(t, data);\n    }\n    visitNull(t, data) {\n        return this.visitPrimitive(t, data);\n    }\n    visitReserved(t, data) {\n        return this.visitPrimitive(t, data);\n    }\n    visitText(t, data) {\n        return this.visitPrimitive(t, data);\n    }\n    visitNumber(t, data) {\n        return this.visitPrimitive(t, data);\n    }\n    visitInt(t, data) {\n        return this.visitNumber(t, data);\n    }\n    visitNat(t, data) {\n        return this.visitNumber(t, data);\n    }\n    visitFloat(t, data) {\n        return this.visitPrimitive(t, data);\n    }\n    visitFixedInt(t, data) {\n        return this.visitNumber(t, data);\n    }\n    visitFixedNat(t, data) {\n        return this.visitNumber(t, data);\n    }\n    visitPrincipal(t, data) {\n        return this.visitPrimitive(t, data);\n    }\n    visitConstruct(t, data) {\n        return this.visitType(t, data);\n    }\n    visitVec(t, _ty, data) {\n        return this.visitConstruct(t, data);\n    }\n    visitOpt(t, _ty, data) {\n        return this.visitConstruct(t, data);\n    }\n    visitRecord(t, _fields, data) {\n        return this.visitConstruct(t, data);\n    }\n    visitTuple(t, components, data) {\n        const fields = components.map((ty, i) => [`_${i}_`, ty]);\n        return this.visitRecord(t, fields, data);\n    }\n    visitVariant(t, _fields, data) {\n        return this.visitConstruct(t, data);\n    }\n    visitRec(_t, ty, data) {\n        return this.visitConstruct(ty, data);\n    }\n    visitFunc(t, data) {\n        return this.visitConstruct(t, data);\n    }\n    visitService(t, data) {\n        return this.visitConstruct(t, data);\n    }\n}\n// We try to use hard-to-accidentally-pick names to avoid potential collisions with other types.\nvar IdlTypeName;\n(function (IdlTypeName) {\n    IdlTypeName[\"EmptyClass\"] = \"__IDL_EmptyClass__\";\n    IdlTypeName[\"UnknownClass\"] = \"__IDL_UnknownClass__\";\n    IdlTypeName[\"BoolClass\"] = \"__IDL_BoolClass__\";\n    IdlTypeName[\"NullClass\"] = \"__IDL_NullClass__\";\n    IdlTypeName[\"ReservedClass\"] = \"__IDL_ReservedClass__\";\n    IdlTypeName[\"TextClass\"] = \"__IDL_TextClass__\";\n    IdlTypeName[\"IntClass\"] = \"__IDL_IntClass__\";\n    IdlTypeName[\"NatClass\"] = \"__IDL_NatClass__\";\n    IdlTypeName[\"FloatClass\"] = \"__IDL_FloatClass__\";\n    IdlTypeName[\"FixedIntClass\"] = \"__IDL_FixedIntClass__\";\n    IdlTypeName[\"FixedNatClass\"] = \"__IDL_FixedNatClass__\";\n    IdlTypeName[\"VecClass\"] = \"__IDL_VecClass__\";\n    IdlTypeName[\"OptClass\"] = \"__IDL_OptClass__\";\n    IdlTypeName[\"RecordClass\"] = \"__IDL_RecordClass__\";\n    IdlTypeName[\"TupleClass\"] = \"__IDL_TupleClass__\";\n    IdlTypeName[\"VariantClass\"] = \"__IDL_VariantClass__\";\n    IdlTypeName[\"RecClass\"] = \"__IDL_RecClass__\";\n    IdlTypeName[\"PrincipalClass\"] = \"__IDL_PrincipalClass__\";\n    IdlTypeName[\"FuncClass\"] = \"__IDL_FuncClass__\";\n    IdlTypeName[\"ServiceClass\"] = \"__IDL_ServiceClass__\";\n})(IdlTypeName || (IdlTypeName = {}));\n/**\n * Represents an IDL type.\n */\nclass Type {\n    /* Display type name */\n    display() {\n        return this.name;\n    }\n    valueToString(x) {\n        return toReadableString(x);\n    }\n    /* Implement `T` in the IDL spec, only needed for non-primitive types */\n    buildTypeTable(typeTable) {\n        if (!typeTable.has(this)) {\n            this._buildTypeTableImpl(typeTable);\n        }\n    }\n}\nclass PrimitiveType extends Type {\n    checkType(t) {\n        if (this.name !== t.name) {\n            throw new Error(`type mismatch: type on the wire ${t.name}, expect type ${this.name}`);\n        }\n        return t;\n    }\n    _buildTypeTableImpl(_typeTable) {\n        // No type table encoding for Primitive types.\n        return;\n    }\n}\nclass ConstructType extends Type {\n    checkType(t) {\n        if (t instanceof RecClass) {\n            const ty = t.getType();\n            if (typeof ty === 'undefined') {\n                throw new Error('type mismatch with uninitialized type');\n            }\n            return ty;\n        }\n        throw new Error(`type mismatch: type on the wire ${t.name}, expect type ${this.name}`);\n    }\n    encodeType(typeTable) {\n        return typeTable.indexOf(this.name);\n    }\n}\n/**\n * Represents an IDL Empty, a type which has no inhabitants.\n * Since no values exist for this type, it cannot be serialised or deserialised.\n * Result types like `Result<Text, Empty>` should always succeed.\n */\nclass EmptyClass extends PrimitiveType {\n    get typeName() {\n        return IdlTypeName.EmptyClass;\n    }\n    static [Symbol.hasInstance](instance) {\n        return instance.typeName === IdlTypeName.EmptyClass;\n    }\n    accept(v, d) {\n        return v.visitEmpty(this, d);\n    }\n    covariant(x) {\n        throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n    }\n    encodeValue() {\n        throw new Error('Empty cannot appear as a function argument');\n    }\n    valueToString() {\n        throw new Error('Empty cannot appear as a value');\n    }\n    encodeType() {\n        return (0,_utils_leb128_js__WEBPACK_IMPORTED_MODULE_0__.slebEncode)(IDLTypeIds.Empty);\n    }\n    decodeValue() {\n        throw new Error('Empty cannot appear as an output');\n    }\n    get name() {\n        return 'empty';\n    }\n}\n/**\n * Represents an IDL Unknown, a placeholder type for deserialization only.\n * When decoding a value as Unknown, all fields will be retained but the names are only available in\n * hashed form.\n * A deserialized unknown will offer it's actual type by calling the `type()` function.\n * Unknown cannot be serialized and attempting to do so will throw an error.\n */\nclass UnknownClass extends Type {\n    get typeName() {\n        return IdlTypeName.UnknownClass;\n    }\n    static [Symbol.hasInstance](instance) {\n        return instance.typeName === IdlTypeName.UnknownClass;\n    }\n    checkType(_t) {\n        throw new Error('Method not implemented for unknown.');\n    }\n    accept(v, d) {\n        throw v.visitType(this, d);\n    }\n    covariant(x) {\n        throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n    }\n    encodeValue() {\n        throw new Error('Unknown cannot appear as a function argument');\n    }\n    valueToString() {\n        throw new Error('Unknown cannot appear as a value');\n    }\n    encodeType() {\n        throw new Error('Unknown cannot be serialized');\n    }\n    decodeValue(b, t) {\n        let decodedValue = t.decodeValue(b, t);\n        if (Object(decodedValue) !== decodedValue) {\n            // decodedValue is primitive. Box it, otherwise we cannot add the type() function.\n            // The type() function is important for primitives because otherwise we cannot tell apart the\n            // different number types.\n            decodedValue = Object(decodedValue);\n        }\n        let typeFunc;\n        if (t instanceof RecClass) {\n            typeFunc = () => t.getType();\n        }\n        else {\n            typeFunc = () => t;\n        }\n        // Do not use 'decodedValue.type = typeFunc' because this would lead to an enumerable property\n        // 'type' which means it would be serialized if the value would be candid encoded again.\n        // This in turn leads to problems if the decoded value is a variant because these values are\n        // only allowed to have a single property.\n        Object.defineProperty(decodedValue, 'type', {\n            value: typeFunc,\n            writable: true,\n            enumerable: false,\n            configurable: true,\n        });\n        return decodedValue;\n    }\n    _buildTypeTableImpl() {\n        throw new Error('Unknown cannot be serialized');\n    }\n    get name() {\n        return 'Unknown';\n    }\n}\n/**\n * Represents an IDL Bool\n */\nclass BoolClass extends PrimitiveType {\n    get typeName() {\n        return IdlTypeName.BoolClass;\n    }\n    static [Symbol.hasInstance](instance) {\n        return instance.typeName === IdlTypeName.BoolClass;\n    }\n    accept(v, d) {\n        return v.visitBool(this, d);\n    }\n    covariant(x) {\n        if (typeof x === 'boolean')\n            return true;\n        throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n    }\n    encodeValue(x) {\n        return new Uint8Array([x ? 1 : 0]);\n    }\n    encodeType() {\n        return (0,_utils_leb128_js__WEBPACK_IMPORTED_MODULE_0__.slebEncode)(IDLTypeIds.Bool);\n    }\n    decodeValue(b, t) {\n        this.checkType(t);\n        switch ((0,_utils_leb128_js__WEBPACK_IMPORTED_MODULE_0__.safeReadUint8)(b)) {\n            case 0:\n                return false;\n            case 1:\n                return true;\n            default:\n                throw new Error('Boolean value out of range');\n        }\n    }\n    get name() {\n        return 'bool';\n    }\n}\n/**\n * Represents an IDL Null\n */\nclass NullClass extends PrimitiveType {\n    get typeName() {\n        return IdlTypeName.NullClass;\n    }\n    static [Symbol.hasInstance](instance) {\n        return instance.typeName === IdlTypeName.NullClass;\n    }\n    accept(v, d) {\n        return v.visitNull(this, d);\n    }\n    covariant(x) {\n        if (x === null)\n            return true;\n        throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n    }\n    encodeValue() {\n        return new Uint8Array(0);\n    }\n    encodeType() {\n        return (0,_utils_leb128_js__WEBPACK_IMPORTED_MODULE_0__.slebEncode)(IDLTypeIds.Null);\n    }\n    decodeValue(_b, t) {\n        this.checkType(t);\n        return null;\n    }\n    get name() {\n        return 'null';\n    }\n}\n/**\n * Represents an IDL Reserved\n */\nclass ReservedClass extends PrimitiveType {\n    get typeName() {\n        return IdlTypeName.ReservedClass;\n    }\n    static [Symbol.hasInstance](instance) {\n        return instance.typeName === IdlTypeName.ReservedClass;\n    }\n    accept(v, d) {\n        return v.visitReserved(this, d);\n    }\n    covariant(_x) {\n        return true;\n    }\n    encodeValue() {\n        return new Uint8Array(0);\n    }\n    encodeType() {\n        return (0,_utils_leb128_js__WEBPACK_IMPORTED_MODULE_0__.slebEncode)(IDLTypeIds.Reserved);\n    }\n    decodeValue(b, t) {\n        if (t.name !== this.name) {\n            t.decodeValue(b, t);\n        }\n        return null;\n    }\n    get name() {\n        return 'reserved';\n    }\n}\n/**\n * Represents an IDL Text\n */\nclass TextClass extends PrimitiveType {\n    get typeName() {\n        return IdlTypeName.TextClass;\n    }\n    static [Symbol.hasInstance](instance) {\n        return instance.typeName === IdlTypeName.TextClass;\n    }\n    accept(v, d) {\n        return v.visitText(this, d);\n    }\n    covariant(x) {\n        if (typeof x === 'string')\n            return true;\n        throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n    }\n    encodeValue(x) {\n        const buf = new TextEncoder().encode(x);\n        const len = (0,_utils_leb128_js__WEBPACK_IMPORTED_MODULE_0__.lebEncode)(buf.byteLength);\n        return (0,_utils_buffer_js__WEBPACK_IMPORTED_MODULE_1__.concat)(len, buf);\n    }\n    encodeType() {\n        return (0,_utils_leb128_js__WEBPACK_IMPORTED_MODULE_0__.slebEncode)(IDLTypeIds.Text);\n    }\n    decodeValue(b, t) {\n        this.checkType(t);\n        const len = (0,_utils_leb128_js__WEBPACK_IMPORTED_MODULE_0__.lebDecode)(b);\n        const buf = (0,_utils_leb128_js__WEBPACK_IMPORTED_MODULE_0__.safeRead)(b, Number(len));\n        const decoder = new TextDecoder('utf8', { fatal: true });\n        return decoder.decode(buf);\n    }\n    get name() {\n        return 'text';\n    }\n    valueToString(x) {\n        return '\"' + x + '\"';\n    }\n}\n/**\n * Represents an IDL Int\n */\nclass IntClass extends PrimitiveType {\n    get typeName() {\n        return IdlTypeName.IntClass;\n    }\n    static [Symbol.hasInstance](instance) {\n        return instance.typeName === IdlTypeName.IntClass;\n    }\n    accept(v, d) {\n        return v.visitInt(this, d);\n    }\n    covariant(x) {\n        // We allow encoding of JavaScript plain numbers.\n        // But we will always decode to bigint.\n        if (typeof x === 'bigint' || Number.isInteger(x))\n            return true;\n        throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n    }\n    encodeValue(x) {\n        return (0,_utils_leb128_js__WEBPACK_IMPORTED_MODULE_0__.slebEncode)(x);\n    }\n    encodeType() {\n        return (0,_utils_leb128_js__WEBPACK_IMPORTED_MODULE_0__.slebEncode)(IDLTypeIds.Int);\n    }\n    decodeValue(b, t) {\n        this.checkType(t);\n        return (0,_utils_leb128_js__WEBPACK_IMPORTED_MODULE_0__.slebDecode)(b);\n    }\n    get name() {\n        return 'int';\n    }\n    valueToString(x) {\n        return x.toString();\n    }\n}\n/**\n * Represents an IDL Nat\n */\nclass NatClass extends PrimitiveType {\n    get typeName() {\n        return IdlTypeName.NatClass;\n    }\n    static [Symbol.hasInstance](instance) {\n        return instance.typeName === IdlTypeName.NatClass;\n    }\n    accept(v, d) {\n        return v.visitNat(this, d);\n    }\n    covariant(x) {\n        // We allow encoding of JavaScript plain numbers.\n        // But we will always decode to bigint.\n        if ((typeof x === 'bigint' && x >= BigInt(0)) || (Number.isInteger(x) && x >= 0))\n            return true;\n        throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n    }\n    encodeValue(x) {\n        return (0,_utils_leb128_js__WEBPACK_IMPORTED_MODULE_0__.lebEncode)(x);\n    }\n    encodeType() {\n        return (0,_utils_leb128_js__WEBPACK_IMPORTED_MODULE_0__.slebEncode)(IDLTypeIds.Nat);\n    }\n    decodeValue(b, t) {\n        this.checkType(t);\n        return (0,_utils_leb128_js__WEBPACK_IMPORTED_MODULE_0__.lebDecode)(b);\n    }\n    get name() {\n        return 'nat';\n    }\n    valueToString(x) {\n        return x.toString();\n    }\n}\n/**\n * Represents an IDL Float\n */\nclass FloatClass extends PrimitiveType {\n    get typeName() {\n        return IdlTypeName.FloatClass;\n    }\n    static [Symbol.hasInstance](instance) {\n        return instance.typeName === IdlTypeName.FloatClass;\n    }\n    constructor(_bits) {\n        super();\n        this._bits = _bits;\n        if (_bits !== 32 && _bits !== 64) {\n            throw new Error('not a valid float type');\n        }\n    }\n    accept(v, d) {\n        return v.visitFloat(this, d);\n    }\n    covariant(x) {\n        if (typeof x === 'number' || x instanceof Number)\n            return true;\n        throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n    }\n    encodeValue(x) {\n        const buf = new ArrayBuffer(this._bits / 8);\n        const view = new DataView(buf);\n        if (this._bits === 32) {\n            view.setFloat32(0, x, true);\n        }\n        else {\n            view.setFloat64(0, x, true);\n        }\n        return new Uint8Array(buf);\n    }\n    encodeType() {\n        const opcode = this._bits === 32 ? IDLTypeIds.Float32 : IDLTypeIds.Float64;\n        return (0,_utils_leb128_js__WEBPACK_IMPORTED_MODULE_0__.slebEncode)(opcode);\n    }\n    decodeValue(b, t) {\n        this.checkType(t);\n        const bytes = (0,_utils_leb128_js__WEBPACK_IMPORTED_MODULE_0__.safeRead)(b, this._bits / 8);\n        const view = (0,_utils_buffer_js__WEBPACK_IMPORTED_MODULE_1__.uint8ToDataView)(bytes);\n        if (this._bits === 32) {\n            return view.getFloat32(0, true);\n        }\n        else {\n            return view.getFloat64(0, true);\n        }\n    }\n    get name() {\n        return 'float' + this._bits;\n    }\n    valueToString(x) {\n        return x.toString();\n    }\n}\n/**\n * Represents an IDL fixed-width Int(n)\n */\nclass FixedIntClass extends PrimitiveType {\n    get typeName() {\n        return IdlTypeName.FixedIntClass;\n    }\n    static [Symbol.hasInstance](instance) {\n        return instance.typeName === IdlTypeName.FixedIntClass;\n    }\n    constructor(_bits) {\n        super();\n        this._bits = _bits;\n    }\n    accept(v, d) {\n        return v.visitFixedInt(this, d);\n    }\n    covariant(x) {\n        const min = (0,_utils_bigint_math_js__WEBPACK_IMPORTED_MODULE_2__.iexp2)(this._bits - 1) * BigInt(-1);\n        const max = (0,_utils_bigint_math_js__WEBPACK_IMPORTED_MODULE_2__.iexp2)(this._bits - 1) - BigInt(1);\n        let ok = false;\n        if (typeof x === 'bigint') {\n            ok = x >= min && x <= max;\n        }\n        else if (Number.isInteger(x)) {\n            const v = BigInt(x);\n            ok = v >= min && v <= max;\n        }\n        else {\n            ok = false;\n        }\n        if (ok)\n            return true;\n        throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n    }\n    encodeValue(x) {\n        return (0,_utils_leb128_js__WEBPACK_IMPORTED_MODULE_0__.writeIntLE)(x, this._bits / 8);\n    }\n    encodeType() {\n        const offset = Math.log2(this._bits) - 3;\n        return (0,_utils_leb128_js__WEBPACK_IMPORTED_MODULE_0__.slebEncode)(-9 - offset);\n    }\n    decodeValue(b, t) {\n        this.checkType(t);\n        const num = (0,_utils_leb128_js__WEBPACK_IMPORTED_MODULE_0__.readIntLE)(b, this._bits / 8);\n        if (this._bits <= 32) {\n            return Number(num);\n        }\n        else {\n            return num;\n        }\n    }\n    get name() {\n        return `int${this._bits}`;\n    }\n    valueToString(x) {\n        return x.toString();\n    }\n}\n/**\n * Represents an IDL fixed-width Nat(n)\n */\nclass FixedNatClass extends PrimitiveType {\n    get typeName() {\n        return IdlTypeName.FixedNatClass;\n    }\n    static [Symbol.hasInstance](instance) {\n        return instance.typeName === IdlTypeName.FixedNatClass;\n    }\n    constructor(_bits) {\n        super();\n        this._bits = _bits;\n    }\n    accept(v, d) {\n        return v.visitFixedNat(this, d);\n    }\n    covariant(x) {\n        const max = (0,_utils_bigint_math_js__WEBPACK_IMPORTED_MODULE_2__.iexp2)(this._bits);\n        let ok = false;\n        if (typeof x === 'bigint' && x >= BigInt(0)) {\n            ok = x < max;\n        }\n        else if (Number.isInteger(x) && x >= 0) {\n            const v = BigInt(x);\n            ok = v < max;\n        }\n        else {\n            ok = false;\n        }\n        if (ok)\n            return true;\n        throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n    }\n    encodeValue(x) {\n        return (0,_utils_leb128_js__WEBPACK_IMPORTED_MODULE_0__.writeUIntLE)(x, this._bits / 8);\n    }\n    encodeType() {\n        const offset = Math.log2(this._bits) - 3;\n        return (0,_utils_leb128_js__WEBPACK_IMPORTED_MODULE_0__.slebEncode)(-5 - offset);\n    }\n    decodeValue(b, t) {\n        this.checkType(t);\n        const num = (0,_utils_leb128_js__WEBPACK_IMPORTED_MODULE_0__.readUIntLE)(b, this._bits / 8);\n        if (this._bits <= 32) {\n            return Number(num);\n        }\n        else {\n            return num;\n        }\n    }\n    get name() {\n        return `nat${this._bits}`;\n    }\n    valueToString(x) {\n        return x.toString();\n    }\n}\n/**\n * Represents an IDL Array\n *\n * Arrays of fixed-sized nat/int type (e.g. nat8), are encoded from and decoded to TypedArrays (e.g. Uint8Array).\n * Arrays of float or other non-primitive types are encoded/decoded as untyped array in Javascript.\n * @param {Type} t\n */\nclass VecClass extends ConstructType {\n    get typeName() {\n        return IdlTypeName.VecClass;\n    }\n    static [Symbol.hasInstance](instance) {\n        return instance.typeName === IdlTypeName.VecClass;\n    }\n    constructor(_type) {\n        super();\n        this._type = _type;\n        // If true, this vector is really a blob and we can just use memcpy.\n        //\n        // NOTE:\n        // With support of encoding/dencoding of TypedArrays, this optimization is\n        // only used when plain array of bytes are passed as encoding input in order\n        // to be backward compatible.\n        this._blobOptimization = false;\n        if (_type instanceof FixedNatClass && _type._bits === 8) {\n            this._blobOptimization = true;\n        }\n    }\n    accept(v, d) {\n        return v.visitVec(this, this._type, d);\n    }\n    covariant(x) {\n        // Special case for ArrayBuffer\n        const bits = this._type instanceof FixedNatClass\n            ? this._type._bits\n            : this._type instanceof FixedIntClass\n                ? this._type._bits\n                : 0;\n        if ((ArrayBuffer.isView(x) && bits == x.BYTES_PER_ELEMENT * 8) ||\n            (Array.isArray(x) &&\n                x.every((v, idx) => {\n                    try {\n                        return this._type.covariant(v);\n                    }\n                    catch (e) {\n                        throw new Error(`Invalid ${this.display()} argument: \\n\\nindex ${idx} -> ${e.message}`);\n                    }\n                })))\n            return true;\n        throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n    }\n    encodeValue(x) {\n        const len = (0,_utils_leb128_js__WEBPACK_IMPORTED_MODULE_0__.lebEncode)(x.length);\n        if (this._blobOptimization) {\n            return (0,_utils_buffer_js__WEBPACK_IMPORTED_MODULE_1__.concat)(len, new Uint8Array(x));\n        }\n        if (ArrayBuffer.isView(x)) {\n            // Handle TypedArrays with endianness concerns\n            if (x instanceof Int16Array || x instanceof Uint16Array) {\n                const buffer = new DataView(new ArrayBuffer(x.length * 2));\n                for (let i = 0; i < x.length; i++) {\n                    if (x instanceof Int16Array) {\n                        buffer.setInt16(i * 2, x[i], true); // true = little-endian\n                    }\n                    else {\n                        buffer.setUint16(i * 2, x[i], true);\n                    }\n                }\n                return (0,_utils_buffer_js__WEBPACK_IMPORTED_MODULE_1__.concat)(len, new Uint8Array(buffer.buffer));\n            }\n            else if (x instanceof Int32Array || x instanceof Uint32Array) {\n                const buffer = new DataView(new ArrayBuffer(x.length * 4));\n                for (let i = 0; i < x.length; i++) {\n                    if (x instanceof Int32Array) {\n                        buffer.setInt32(i * 4, x[i], true);\n                    }\n                    else {\n                        buffer.setUint32(i * 4, x[i], true);\n                    }\n                }\n                return (0,_utils_buffer_js__WEBPACK_IMPORTED_MODULE_1__.concat)(len, new Uint8Array(buffer.buffer));\n            }\n            else if (x instanceof BigInt64Array || x instanceof BigUint64Array) {\n                const buffer = new DataView(new ArrayBuffer(x.length * 8));\n                for (let i = 0; i < x.length; i++) {\n                    if (x instanceof BigInt64Array) {\n                        buffer.setBigInt64(i * 8, x[i], true);\n                    }\n                    else {\n                        buffer.setBigUint64(i * 8, x[i], true);\n                    }\n                }\n                return (0,_utils_buffer_js__WEBPACK_IMPORTED_MODULE_1__.concat)(len, new Uint8Array(buffer.buffer));\n            }\n            else {\n                // For Uint8Array, Int8Array, etc. that don't have endianness concerns\n                return (0,_utils_buffer_js__WEBPACK_IMPORTED_MODULE_1__.concat)(len, new Uint8Array(x.buffer, x.byteOffset, x.byteLength));\n            }\n        }\n        const buf = new _utils_buffer_js__WEBPACK_IMPORTED_MODULE_1__.PipeArrayBuffer(new Uint8Array(len.byteLength + x.length), 0);\n        buf.write(len);\n        for (const d of x) {\n            const encoded = this._type.encodeValue(d);\n            buf.write(new Uint8Array(encoded));\n        }\n        return buf.buffer;\n    }\n    _buildTypeTableImpl(typeTable) {\n        this._type.buildTypeTable(typeTable);\n        const opCode = (0,_utils_leb128_js__WEBPACK_IMPORTED_MODULE_0__.slebEncode)(IDLTypeIds.Vector);\n        const buffer = this._type.encodeType(typeTable);\n        typeTable.add(this, (0,_utils_buffer_js__WEBPACK_IMPORTED_MODULE_1__.concat)(opCode, buffer));\n    }\n    decodeValue(b, t) {\n        const vec = this.checkType(t);\n        if (!(vec instanceof VecClass)) {\n            throw new Error('Not a vector type');\n        }\n        const len = Number((0,_utils_leb128_js__WEBPACK_IMPORTED_MODULE_0__.lebDecode)(b));\n        if (this._type instanceof FixedNatClass) {\n            if (this._type._bits == 8) {\n                return new Uint8Array(b.read(len));\n            }\n            if (this._type._bits == 16) {\n                const bytes = b.read(len * 2);\n                // Check if we need to swap bytes for endianness\n                const u16 = new Uint16Array(bytes.buffer, bytes.byteOffset, len);\n                return u16;\n            }\n            if (this._type._bits == 32) {\n                const bytes = b.read(len * 4);\n                const u32 = new Uint32Array(bytes.buffer, bytes.byteOffset, len);\n                return u32;\n            }\n            if (this._type._bits == 64) {\n                return new BigUint64Array(b.read(len * 8).buffer);\n            }\n        }\n        if (this._type instanceof FixedIntClass) {\n            if (this._type._bits == 8) {\n                return new Int8Array(b.read(len));\n            }\n            if (this._type._bits == 16) {\n                const bytes = b.read(len * 2);\n                // Create a DataView to properly handle endianness\n                const view = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);\n                // Create result array with correct endianness\n                const result = new Int16Array(len);\n                for (let i = 0; i < len; i++) {\n                    // Read each value as little-endian (Candid wire format is little-endian)\n                    result[i] = view.getInt16(i * 2, true);\n                }\n                return result;\n            }\n            if (this._type._bits == 32) {\n                const bytes = b.read(len * 4);\n                const view = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);\n                const result = new Int32Array(len);\n                for (let i = 0; i < len; i++) {\n                    result[i] = view.getInt32(i * 4, true);\n                }\n                return result;\n            }\n            if (this._type._bits == 64) {\n                const bytes = b.read(len * 8);\n                const view = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);\n                const result = new BigInt64Array(len);\n                for (let i = 0; i < len; i++) {\n                    result[i] = view.getBigInt64(i * 8, true);\n                }\n                return result;\n            }\n        }\n        const rets = [];\n        for (let i = 0; i < len; i++) {\n            rets.push(this._type.decodeValue(b, vec._type));\n        }\n        return rets;\n    }\n    get name() {\n        return `vec ${this._type.name}`;\n    }\n    display() {\n        return `vec ${this._type.display()}`;\n    }\n    valueToString(x) {\n        const elements = x.map(e => this._type.valueToString(e));\n        return 'vec {' + elements.join('; ') + '}';\n    }\n}\n/**\n * Represents an IDL Option\n * @param {Type} t\n */\nclass OptClass extends ConstructType {\n    get typeName() {\n        return IdlTypeName.OptClass;\n    }\n    static [Symbol.hasInstance](instance) {\n        return instance.typeName === IdlTypeName.OptClass;\n    }\n    constructor(_type) {\n        super();\n        this._type = _type;\n    }\n    accept(v, d) {\n        return v.visitOpt(this, this._type, d);\n    }\n    covariant(x) {\n        try {\n            if (Array.isArray(x) && (x.length === 0 || (x.length === 1 && this._type.covariant(x[0]))))\n                return true;\n        }\n        catch (e) {\n            throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)} \\n\\n-> ${e.message}`);\n        }\n        throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n    }\n    encodeValue(x) {\n        if (x.length === 0) {\n            return new Uint8Array([0]);\n        }\n        else {\n            return (0,_utils_buffer_js__WEBPACK_IMPORTED_MODULE_1__.concat)(new Uint8Array([1]), this._type.encodeValue(x[0]));\n        }\n    }\n    _buildTypeTableImpl(typeTable) {\n        this._type.buildTypeTable(typeTable);\n        const opCode = (0,_utils_leb128_js__WEBPACK_IMPORTED_MODULE_0__.slebEncode)(IDLTypeIds.Opt);\n        const buffer = this._type.encodeType(typeTable);\n        typeTable.add(this, (0,_utils_buffer_js__WEBPACK_IMPORTED_MODULE_1__.concat)(opCode, buffer));\n    }\n    decodeValue(b, t) {\n        if (t instanceof NullClass) {\n            return [];\n        }\n        if (t instanceof ReservedClass) {\n            return [];\n        }\n        let wireType = t;\n        // unfold wireType, if needed\n        if (t instanceof RecClass) {\n            const ty = t.getType();\n            if (typeof ty === 'undefined') {\n                throw new Error('type mismatch with uninitialized type');\n            }\n            else\n                wireType = ty;\n        }\n        if (wireType instanceof OptClass) {\n            switch ((0,_utils_leb128_js__WEBPACK_IMPORTED_MODULE_0__.safeReadUint8)(b)) {\n                case 0:\n                    return [];\n                case 1: {\n                    // Save the current state of the Pipe `b` to allow rollback in case of an error\n                    const checkpoint = b.save();\n                    try {\n                        // Attempt to decode a value using the `_type` of the current instance\n                        const v = this._type.decodeValue(b, wireType._type);\n                        return [v];\n                    }\n                    catch (e) {\n                        // If an error occurs during decoding, restore the Pipe `b` to its previous state\n                        b.restore(checkpoint);\n                        // Skip the value at the current wire type to advance the Pipe `b` position\n                        wireType._type.decodeValue(b, wireType._type);\n                        // Return an empty array to indicate a `none` value\n                        return [];\n                    }\n                }\n                default:\n                    throw new Error('Not an option value');\n            }\n        }\n        else if (\n        // this check corresponds to `not (null <: <t>)` in the spec\n        this._type instanceof NullClass ||\n            this._type instanceof OptClass ||\n            this._type instanceof ReservedClass) {\n            // null <: <t> :\n            // skip value at wire type (to advance b) and return \"null\", i.e. []\n            wireType.decodeValue(b, wireType);\n            return [];\n        }\n        else {\n            // not (null <: t) :\n            // try constituent type\n            const checkpoint = b.save();\n            try {\n                const v = this._type.decodeValue(b, t);\n                return [v];\n            }\n            catch (e) {\n                // decoding failed, but this is opt, so return \"null\", i.e. []\n                b.restore(checkpoint);\n                // skip value at wire type (to advance b)\n                wireType.decodeValue(b, t);\n                // return \"null\"\n                return [];\n            }\n        }\n    }\n    get name() {\n        return `opt ${this._type.name}`;\n    }\n    display() {\n        return `opt ${this._type.display()}`;\n    }\n    valueToString(x) {\n        if (x.length === 0) {\n            return 'null';\n        }\n        else {\n            return `opt ${this._type.valueToString(x[0])}`;\n        }\n    }\n}\n/**\n * Represents an IDL Record\n * @param {object} [fields] - mapping of function name to Type\n */\nclass RecordClass extends ConstructType {\n    get typeName() {\n        return IdlTypeName.RecordClass;\n    }\n    static [Symbol.hasInstance](instance) {\n        // TupleClass extends RecordClass, so we need to check both here\n        return (instance.typeName === IdlTypeName.RecordClass || instance.typeName === IdlTypeName.TupleClass);\n    }\n    constructor(fields = {}) {\n        super();\n        this._fields = Object.entries(fields).sort((a, b) => (0,_utils_hash_js__WEBPACK_IMPORTED_MODULE_3__.idlLabelToId)(a[0]) - (0,_utils_hash_js__WEBPACK_IMPORTED_MODULE_3__.idlLabelToId)(b[0]));\n    }\n    accept(v, d) {\n        return v.visitRecord(this, this._fields, d);\n    }\n    tryAsTuple() {\n        const res = [];\n        for (let i = 0; i < this._fields.length; i++) {\n            const [key, type] = this._fields[i];\n            if (key !== `_${i}_`) {\n                return null;\n            }\n            res.push(type);\n        }\n        return res;\n    }\n    covariant(x) {\n        if (typeof x === 'object' &&\n            this._fields.every(([k, t]) => {\n                // eslint-disable-next-line\n                if (!x.hasOwnProperty(k)) {\n                    throw new Error(`Record is missing key \"${k}\".`);\n                }\n                try {\n                    return t.covariant(x[k]);\n                }\n                catch (e) {\n                    throw new Error(`Invalid ${this.display()} argument: \\n\\nfield ${k} -> ${e.message}`);\n                }\n            }))\n            return true;\n        throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n    }\n    encodeValue(x) {\n        const values = this._fields.map(([key]) => x[key]);\n        const bufs = zipWith(this._fields, values, ([, c], d) => c.encodeValue(d));\n        return (0,_utils_buffer_js__WEBPACK_IMPORTED_MODULE_1__.concat)(...bufs);\n    }\n    _buildTypeTableImpl(T) {\n        this._fields.forEach(([_, value]) => value.buildTypeTable(T));\n        const opCode = (0,_utils_leb128_js__WEBPACK_IMPORTED_MODULE_0__.slebEncode)(IDLTypeIds.Record);\n        const len = (0,_utils_leb128_js__WEBPACK_IMPORTED_MODULE_0__.lebEncode)(this._fields.length);\n        const fields = this._fields.map(([key, value]) => (0,_utils_buffer_js__WEBPACK_IMPORTED_MODULE_1__.concat)((0,_utils_leb128_js__WEBPACK_IMPORTED_MODULE_0__.lebEncode)((0,_utils_hash_js__WEBPACK_IMPORTED_MODULE_3__.idlLabelToId)(key)), value.encodeType(T)));\n        T.add(this, (0,_utils_buffer_js__WEBPACK_IMPORTED_MODULE_1__.concat)(opCode, len, (0,_utils_buffer_js__WEBPACK_IMPORTED_MODULE_1__.concat)(...fields)));\n    }\n    decodeValue(b, t) {\n        const record = this.checkType(t);\n        if (!(record instanceof RecordClass)) {\n            throw new Error('Not a record type');\n        }\n        const x = {};\n        let expectedRecordIdx = 0;\n        let actualRecordIdx = 0;\n        while (actualRecordIdx < record._fields.length) {\n            const [hash, type] = record._fields[actualRecordIdx];\n            if (expectedRecordIdx >= this._fields.length) {\n                // skip unexpected left over fields present on the wire\n                type.decodeValue(b, type);\n                actualRecordIdx++;\n                continue;\n            }\n            const [expectKey, expectType] = this._fields[expectedRecordIdx];\n            const expectedId = (0,_utils_hash_js__WEBPACK_IMPORTED_MODULE_3__.idlLabelToId)(this._fields[expectedRecordIdx][0]);\n            const actualId = (0,_utils_hash_js__WEBPACK_IMPORTED_MODULE_3__.idlLabelToId)(hash);\n            if (expectedId === actualId) {\n                // the current field on the wire matches the expected field\n                x[expectKey] = expectType.decodeValue(b, type);\n                expectedRecordIdx++;\n                actualRecordIdx++;\n            }\n            else if (actualId > expectedId) {\n                // The expected field does not exist on the wire\n                if (expectType instanceof OptClass || expectType instanceof ReservedClass) {\n                    x[expectKey] = [];\n                    expectedRecordIdx++;\n                }\n                else {\n                    throw new Error('Cannot find required field ' + expectKey);\n                }\n            }\n            else {\n                // The field on the wire does not exist in the output type, so we can skip it\n                type.decodeValue(b, type);\n                actualRecordIdx++;\n            }\n        }\n        // initialize left over expected optional fields\n        for (const [expectKey, expectType] of this._fields.slice(expectedRecordIdx)) {\n            if (expectType instanceof OptClass || expectType instanceof ReservedClass) {\n                // TODO this assumes null value in opt is represented as []\n                x[expectKey] = [];\n            }\n            else {\n                throw new Error('Cannot find required field ' + expectKey);\n            }\n        }\n        return x;\n    }\n    get fieldsAsObject() {\n        const fields = {};\n        for (const [name, ty] of this._fields) {\n            fields[(0,_utils_hash_js__WEBPACK_IMPORTED_MODULE_3__.idlLabelToId)(name)] = ty;\n        }\n        return fields;\n    }\n    get name() {\n        const fields = this._fields.map(([key, value]) => key + ':' + value.name);\n        return `record {${fields.join('; ')}}`;\n    }\n    display() {\n        const fields = this._fields.map(([key, value]) => key + ':' + value.display());\n        return `record {${fields.join('; ')}}`;\n    }\n    valueToString(x) {\n        const values = this._fields.map(([key]) => x[key]);\n        const fields = zipWith(this._fields, values, ([k, c], d) => k + '=' + c.valueToString(d));\n        return `record {${fields.join('; ')}}`;\n    }\n}\n/**\n * Represents Tuple, a syntactic sugar for Record.\n * @param {Type} components\n */\nclass TupleClass extends RecordClass {\n    get typeName() {\n        return IdlTypeName.TupleClass;\n    }\n    static [Symbol.hasInstance](instance) {\n        return instance.typeName === IdlTypeName.TupleClass;\n    }\n    constructor(_components) {\n        const x = {};\n        _components.forEach((e, i) => (x['_' + i + '_'] = e));\n        super(x);\n        this._components = _components;\n    }\n    accept(v, d) {\n        return v.visitTuple(this, this._components, d);\n    }\n    covariant(x) {\n        // `>=` because tuples can be covariant when encoded.\n        if (Array.isArray(x) &&\n            x.length >= this._fields.length &&\n            this._components.every((t, i) => {\n                try {\n                    return t.covariant(x[i]);\n                }\n                catch (e) {\n                    throw new Error(`Invalid ${this.display()} argument: \\n\\nindex ${i} -> ${e.message}`);\n                }\n            }))\n            return true;\n        throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n    }\n    encodeValue(x) {\n        const bufs = zipWith(this._components, x, (c, d) => c.encodeValue(d));\n        return (0,_utils_buffer_js__WEBPACK_IMPORTED_MODULE_1__.concat)(...bufs);\n    }\n    decodeValue(b, t) {\n        const tuple = this.checkType(t);\n        if (!(tuple instanceof TupleClass)) {\n            throw new Error('not a tuple type');\n        }\n        if (tuple._components.length < this._components.length) {\n            throw new Error('tuple mismatch');\n        }\n        const res = [];\n        for (const [i, wireType] of tuple._components.entries()) {\n            if (i >= this._components.length) {\n                // skip value\n                wireType.decodeValue(b, wireType);\n            }\n            else {\n                res.push(this._components[i].decodeValue(b, wireType));\n            }\n        }\n        return res;\n    }\n    display() {\n        const fields = this._components.map(value => value.display());\n        return `record {${fields.join('; ')}}`;\n    }\n    valueToString(values) {\n        const fields = zipWith(this._components, values, (c, d) => c.valueToString(d));\n        return `record {${fields.join('; ')}}`;\n    }\n}\n/**\n * Represents an IDL Variant\n * @param {object} [fields] - mapping of function name to Type\n */\nclass VariantClass extends ConstructType {\n    get typeName() {\n        return IdlTypeName.VariantClass;\n    }\n    static [Symbol.hasInstance](instance) {\n        return instance.typeName === IdlTypeName.VariantClass;\n    }\n    constructor(fields = {}) {\n        super();\n        this._fields = Object.entries(fields).sort((a, b) => (0,_utils_hash_js__WEBPACK_IMPORTED_MODULE_3__.idlLabelToId)(a[0]) - (0,_utils_hash_js__WEBPACK_IMPORTED_MODULE_3__.idlLabelToId)(b[0]));\n    }\n    accept(v, d) {\n        return v.visitVariant(this, this._fields, d);\n    }\n    covariant(x) {\n        if (typeof x === 'object' &&\n            Object.entries(x).length === 1 &&\n            this._fields.every(([k, v]) => {\n                try {\n                    // eslint-disable-next-line\n                    return !x.hasOwnProperty(k) || v.covariant(x[k]);\n                }\n                catch (e) {\n                    throw new Error(`Invalid ${this.display()} argument: \\n\\nvariant ${k} -> ${e.message}`);\n                }\n            }))\n            return true;\n        throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n    }\n    encodeValue(x) {\n        for (let i = 0; i < this._fields.length; i++) {\n            const [name, type] = this._fields[i];\n            // eslint-disable-next-line\n            if (x.hasOwnProperty(name)) {\n                const idx = (0,_utils_leb128_js__WEBPACK_IMPORTED_MODULE_0__.lebEncode)(i);\n                const buf = type.encodeValue(x[name]);\n                return (0,_utils_buffer_js__WEBPACK_IMPORTED_MODULE_1__.concat)(idx, buf);\n            }\n        }\n        throw Error('Variant has no data: ' + x);\n    }\n    _buildTypeTableImpl(typeTable) {\n        this._fields.forEach(([, type]) => {\n            type.buildTypeTable(typeTable);\n        });\n        const opCode = (0,_utils_leb128_js__WEBPACK_IMPORTED_MODULE_0__.slebEncode)(IDLTypeIds.Variant);\n        const len = (0,_utils_leb128_js__WEBPACK_IMPORTED_MODULE_0__.lebEncode)(this._fields.length);\n        const fields = this._fields.map(([key, value]) => (0,_utils_buffer_js__WEBPACK_IMPORTED_MODULE_1__.concat)((0,_utils_leb128_js__WEBPACK_IMPORTED_MODULE_0__.lebEncode)((0,_utils_hash_js__WEBPACK_IMPORTED_MODULE_3__.idlLabelToId)(key)), value.encodeType(typeTable)));\n        typeTable.add(this, (0,_utils_buffer_js__WEBPACK_IMPORTED_MODULE_1__.concat)(opCode, len, ...fields));\n    }\n    decodeValue(b, t) {\n        const variant = this.checkType(t);\n        if (!(variant instanceof VariantClass)) {\n            throw new Error('Not a variant type');\n        }\n        const idx = Number((0,_utils_leb128_js__WEBPACK_IMPORTED_MODULE_0__.lebDecode)(b));\n        if (idx >= variant._fields.length) {\n            throw Error('Invalid variant index: ' + idx);\n        }\n        const [wireHash, wireType] = variant._fields[idx];\n        for (const [key, expectType] of this._fields) {\n            if ((0,_utils_hash_js__WEBPACK_IMPORTED_MODULE_3__.idlLabelToId)(wireHash) === (0,_utils_hash_js__WEBPACK_IMPORTED_MODULE_3__.idlLabelToId)(key)) {\n                const value = expectType.decodeValue(b, wireType);\n                return { [key]: value };\n            }\n        }\n        throw new Error('Cannot find field hash ' + wireHash);\n    }\n    get name() {\n        const fields = this._fields.map(([key, type]) => key + ':' + type.name);\n        return `variant {${fields.join('; ')}}`;\n    }\n    display() {\n        const fields = this._fields.map(([key, type]) => key + (type.name === 'null' ? '' : `:${type.display()}`));\n        return `variant {${fields.join('; ')}}`;\n    }\n    valueToString(x) {\n        for (const [name, type] of this._fields) {\n            // eslint-disable-next-line\n            if (x.hasOwnProperty(name)) {\n                const value = type.valueToString(x[name]);\n                if (value === 'null') {\n                    return `variant {${name}}`;\n                }\n                else {\n                    return `variant {${name}=${value}}`;\n                }\n            }\n        }\n        throw new Error('Variant has no data: ' + x);\n    }\n    get alternativesAsObject() {\n        const alternatives = {};\n        for (const [name, ty] of this._fields) {\n            alternatives[(0,_utils_hash_js__WEBPACK_IMPORTED_MODULE_3__.idlLabelToId)(name)] = ty;\n        }\n        return alternatives;\n    }\n}\n/**\n * Represents a reference to an IDL type, used for defining recursive data\n * types.\n */\nclass RecClass extends ConstructType {\n    constructor() {\n        super(...arguments);\n        this._id = RecClass._counter++;\n    }\n    get typeName() {\n        return IdlTypeName.RecClass;\n    }\n    static { this._counter = 0; }\n    static [Symbol.hasInstance](instance) {\n        return instance.typeName === IdlTypeName.RecClass;\n    }\n    accept(v, d) {\n        if (!this._type) {\n            throw Error('Recursive type uninitialized.');\n        }\n        return v.visitRec(this, this._type, d);\n    }\n    fill(t) {\n        this._type = t;\n    }\n    getType() {\n        return this._type;\n    }\n    covariant(x) {\n        if (this._type ? this._type.covariant(x) : false)\n            return true;\n        throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n    }\n    encodeValue(x) {\n        if (!this._type) {\n            throw Error('Recursive type uninitialized.');\n        }\n        return this._type.encodeValue(x);\n    }\n    _buildTypeTableImpl(typeTable) {\n        if (!this._type) {\n            throw Error('Recursive type uninitialized.');\n        }\n        typeTable.add(this, new Uint8Array([]));\n        this._type.buildTypeTable(typeTable);\n        typeTable.merge(this, this._type.name);\n    }\n    decodeValue(b, t) {\n        if (!this._type) {\n            throw Error('Recursive type uninitialized.');\n        }\n        return this._type.decodeValue(b, t);\n    }\n    get name() {\n        return `rec_${this._id}`;\n    }\n    display() {\n        if (!this._type) {\n            throw Error('Recursive type uninitialized.');\n        }\n        return `μ${this.name}.${this._type.name}`;\n    }\n    valueToString(x) {\n        if (!this._type) {\n            throw Error('Recursive type uninitialized.');\n        }\n        return this._type.valueToString(x);\n    }\n}\nfunction decodePrincipalId(b) {\n    const x = (0,_utils_leb128_js__WEBPACK_IMPORTED_MODULE_0__.safeReadUint8)(b);\n    if (x !== 1) {\n        throw new Error('Cannot decode principal');\n    }\n    const len = Number((0,_utils_leb128_js__WEBPACK_IMPORTED_MODULE_0__.lebDecode)(b));\n    return _dfinity_principal__WEBPACK_IMPORTED_MODULE_4__.Principal.fromUint8Array(new Uint8Array((0,_utils_leb128_js__WEBPACK_IMPORTED_MODULE_0__.safeRead)(b, len)));\n}\n/**\n * Represents an IDL principal reference\n */\nclass PrincipalClass extends PrimitiveType {\n    get typeName() {\n        return IdlTypeName.PrincipalClass;\n    }\n    static [Symbol.hasInstance](instance) {\n        return instance.typeName === IdlTypeName.PrincipalClass;\n    }\n    accept(v, d) {\n        return v.visitPrincipal(this, d);\n    }\n    covariant(x) {\n        if (x && x._isPrincipal)\n            return true;\n        throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n    }\n    encodeValue(x) {\n        const buf = x.toUint8Array();\n        const len = (0,_utils_leb128_js__WEBPACK_IMPORTED_MODULE_0__.lebEncode)(buf.byteLength);\n        return (0,_utils_buffer_js__WEBPACK_IMPORTED_MODULE_1__.concat)(new Uint8Array([1]), len, buf);\n    }\n    encodeType() {\n        return (0,_utils_leb128_js__WEBPACK_IMPORTED_MODULE_0__.slebEncode)(IDLTypeIds.Principal);\n    }\n    decodeValue(b, t) {\n        this.checkType(t);\n        return decodePrincipalId(b);\n    }\n    get name() {\n        return 'principal';\n    }\n    valueToString(x) {\n        return `${this.name} \"${x.toText()}\"`;\n    }\n}\n/**\n * Represents an IDL function reference.\n * @param argTypes Argument types.\n * @param retTypes Return types.\n * @param annotations Function annotations.\n */\nclass FuncClass extends ConstructType {\n    get typeName() {\n        return IdlTypeName.FuncClass;\n    }\n    static [Symbol.hasInstance](instance) {\n        return instance.typeName === IdlTypeName.FuncClass;\n    }\n    static argsToString(types, v) {\n        if (types.length !== v.length) {\n            throw new Error('arity mismatch');\n        }\n        return '(' + types.map((t, i) => t.valueToString(v[i])).join(', ') + ')';\n    }\n    constructor(argTypes, retTypes, annotations = []) {\n        super();\n        this.argTypes = argTypes;\n        this.retTypes = retTypes;\n        this.annotations = annotations;\n    }\n    accept(v, d) {\n        return v.visitFunc(this, d);\n    }\n    covariant(x) {\n        if (Array.isArray(x) && x.length === 2 && x[0] && x[0]._isPrincipal && typeof x[1] === 'string')\n            return true;\n        throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n    }\n    encodeValue([principal, methodName]) {\n        const buf = principal.toUint8Array();\n        const len = (0,_utils_leb128_js__WEBPACK_IMPORTED_MODULE_0__.lebEncode)(buf.byteLength);\n        const canister = (0,_utils_buffer_js__WEBPACK_IMPORTED_MODULE_1__.concat)(new Uint8Array([1]), len, buf);\n        const method = new TextEncoder().encode(methodName);\n        const methodLen = (0,_utils_leb128_js__WEBPACK_IMPORTED_MODULE_0__.lebEncode)(method.byteLength);\n        return (0,_utils_buffer_js__WEBPACK_IMPORTED_MODULE_1__.concat)(new Uint8Array([1]), canister, methodLen, method);\n    }\n    _buildTypeTableImpl(T) {\n        this.argTypes.forEach(arg => arg.buildTypeTable(T));\n        this.retTypes.forEach(arg => arg.buildTypeTable(T));\n        const opCode = (0,_utils_leb128_js__WEBPACK_IMPORTED_MODULE_0__.slebEncode)(IDLTypeIds.Func);\n        const argLen = (0,_utils_leb128_js__WEBPACK_IMPORTED_MODULE_0__.lebEncode)(this.argTypes.length);\n        const args = (0,_utils_buffer_js__WEBPACK_IMPORTED_MODULE_1__.concat)(...this.argTypes.map(arg => arg.encodeType(T)));\n        const retLen = (0,_utils_leb128_js__WEBPACK_IMPORTED_MODULE_0__.lebEncode)(this.retTypes.length);\n        const rets = (0,_utils_buffer_js__WEBPACK_IMPORTED_MODULE_1__.concat)(...this.retTypes.map(arg => arg.encodeType(T)));\n        const annLen = (0,_utils_leb128_js__WEBPACK_IMPORTED_MODULE_0__.lebEncode)(this.annotations.length);\n        const anns = (0,_utils_buffer_js__WEBPACK_IMPORTED_MODULE_1__.concat)(...this.annotations.map(a => this.encodeAnnotation(a)));\n        T.add(this, (0,_utils_buffer_js__WEBPACK_IMPORTED_MODULE_1__.concat)(opCode, argLen, args, retLen, rets, annLen, anns));\n    }\n    decodeValue(b, t) {\n        const tt = t instanceof RecClass ? (t.getType() ?? t) : t;\n        if (!subtype(tt, this)) {\n            throw new Error(`Cannot decode function reference at type ${this.display()} from wire type ${tt.display()}`);\n        }\n        const x = (0,_utils_leb128_js__WEBPACK_IMPORTED_MODULE_0__.safeReadUint8)(b);\n        if (x !== 1) {\n            throw new Error('Cannot decode function reference');\n        }\n        const canister = decodePrincipalId(b);\n        const mLen = Number((0,_utils_leb128_js__WEBPACK_IMPORTED_MODULE_0__.lebDecode)(b));\n        const buf = (0,_utils_leb128_js__WEBPACK_IMPORTED_MODULE_0__.safeRead)(b, mLen);\n        const decoder = new TextDecoder('utf8', { fatal: true });\n        const method = decoder.decode(buf);\n        return [canister, method];\n    }\n    get name() {\n        const args = this.argTypes.map(arg => arg.name).join(', ');\n        const rets = this.retTypes.map(arg => arg.name).join(', ');\n        const annon = ' ' + this.annotations.join(' ');\n        return `(${args}) -> (${rets})${annon}`;\n    }\n    valueToString([principal, str]) {\n        return `func \"${principal.toText()}\".${str}`;\n    }\n    display() {\n        const args = this.argTypes.map(arg => arg.display()).join(', ');\n        const rets = this.retTypes.map(arg => arg.display()).join(', ');\n        const annon = ' ' + this.annotations.join(' ');\n        return `(${args}) → (${rets})${annon}`;\n    }\n    encodeAnnotation(ann) {\n        if (ann === 'query') {\n            return new Uint8Array([1]);\n        }\n        else if (ann === 'oneway') {\n            return new Uint8Array([2]);\n        }\n        else if (ann === 'composite_query') {\n            return new Uint8Array([3]);\n        }\n        else {\n            throw new Error('Illegal function annotation');\n        }\n    }\n}\nclass ServiceClass extends ConstructType {\n    get typeName() {\n        return IdlTypeName.ServiceClass;\n    }\n    static [Symbol.hasInstance](instance) {\n        return instance.typeName === IdlTypeName.ServiceClass;\n    }\n    constructor(fields) {\n        super();\n        this._fields = Object.entries(fields).sort((a, b) => {\n            if (a[0] < b[0]) {\n                return -1;\n            }\n            if (a[0] > b[0]) {\n                return 1;\n            }\n            return 0;\n        });\n    }\n    accept(v, d) {\n        return v.visitService(this, d);\n    }\n    covariant(x) {\n        if (x && x._isPrincipal)\n            return true;\n        throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n    }\n    encodeValue(x) {\n        const buf = x.toUint8Array();\n        const len = (0,_utils_leb128_js__WEBPACK_IMPORTED_MODULE_0__.lebEncode)(buf.length);\n        return (0,_utils_buffer_js__WEBPACK_IMPORTED_MODULE_1__.concat)(new Uint8Array([1]), len, buf);\n    }\n    _buildTypeTableImpl(T) {\n        this._fields.forEach(([_, func]) => func.buildTypeTable(T));\n        const opCode = (0,_utils_leb128_js__WEBPACK_IMPORTED_MODULE_0__.slebEncode)(IDLTypeIds.Service);\n        const len = (0,_utils_leb128_js__WEBPACK_IMPORTED_MODULE_0__.lebEncode)(this._fields.length);\n        const meths = this._fields.map(([label, func]) => {\n            const labelBuf = new TextEncoder().encode(label);\n            const labelLen = (0,_utils_leb128_js__WEBPACK_IMPORTED_MODULE_0__.lebEncode)(labelBuf.length);\n            return (0,_utils_buffer_js__WEBPACK_IMPORTED_MODULE_1__.concat)(labelLen, labelBuf, func.encodeType(T));\n        });\n        T.add(this, (0,_utils_buffer_js__WEBPACK_IMPORTED_MODULE_1__.concat)(opCode, len, ...meths));\n    }\n    decodeValue(b, t) {\n        const tt = t instanceof RecClass ? (t.getType() ?? t) : t;\n        if (!subtype(tt, this)) {\n            throw new Error(`Cannot decode service reference at type ${this.display()} from wire type ${tt.display()}`);\n        }\n        return decodePrincipalId(b);\n    }\n    get name() {\n        const fields = this._fields.map(([key, value]) => key + ':' + value.name);\n        return `service {${fields.join('; ')}}`;\n    }\n    valueToString(x) {\n        return `service \"${x.toText()}\"`;\n    }\n    fieldsAsObject() {\n        const fields = {};\n        for (const [name, ty] of this._fields) {\n            fields[name] = ty;\n        }\n        return fields;\n    }\n}\n/**\n * Takes an unknown value and returns a string representation of it.\n * @param x - unknown value\n * @returns {string} string representation of the value\n */\nfunction toReadableString(x) {\n    const str = JSON.stringify(x, (_key, value) => typeof value === 'bigint' ? `BigInt(${value})` : value);\n    return str && str.length > toReadableString_max\n        ? str.substring(0, toReadableString_max - 3) + '...'\n        : str;\n}\n/**\n * Encode a array of values\n * @param argTypes - array of Types\n * @param args - array of values\n * @returns {Uint8Array} serialised value\n */\nfunction encode(argTypes, args) {\n    if (args.length < argTypes.length) {\n        throw Error('Wrong number of message arguments');\n    }\n    const typeTable = new TypeTable();\n    argTypes.forEach(t => t.buildTypeTable(typeTable));\n    const magic = new TextEncoder().encode(magicNumber);\n    const table = typeTable.encode();\n    const len = (0,_utils_leb128_js__WEBPACK_IMPORTED_MODULE_0__.lebEncode)(args.length);\n    const typs = (0,_utils_buffer_js__WEBPACK_IMPORTED_MODULE_1__.concat)(...argTypes.map(t => t.encodeType(typeTable)));\n    const vals = (0,_utils_buffer_js__WEBPACK_IMPORTED_MODULE_1__.concat)(...zipWith(argTypes, args, (t, x) => {\n        try {\n            t.covariant(x);\n        }\n        catch (e) {\n            const err = new Error(e.message + '\\n\\n');\n            throw err;\n        }\n        return t.encodeValue(x);\n    }));\n    return (0,_utils_buffer_js__WEBPACK_IMPORTED_MODULE_1__.concat)(magic, table, len, typs, vals);\n}\n/**\n * Decode a binary value\n * @param retTypes - Types expected in the buffer.\n * @param bytes - hex-encoded string, or buffer.\n * @returns Value deserialised to JS type\n */\nfunction decode(retTypes, bytes) {\n    const b = new _utils_buffer_js__WEBPACK_IMPORTED_MODULE_1__.PipeArrayBuffer(bytes);\n    if (bytes.byteLength < magicNumber.length) {\n        throw new Error('Message length smaller than magic number');\n    }\n    const magicBuffer = (0,_utils_leb128_js__WEBPACK_IMPORTED_MODULE_0__.safeRead)(b, magicNumber.length);\n    const magic = new TextDecoder().decode(magicBuffer);\n    if (magic !== magicNumber) {\n        throw new Error('Wrong magic number: ' + JSON.stringify(magic));\n    }\n    function readTypeTable(pipe) {\n        const typeTable = [];\n        const len = Number((0,_utils_leb128_js__WEBPACK_IMPORTED_MODULE_0__.lebDecode)(pipe));\n        for (let i = 0; i < len; i++) {\n            const ty = Number((0,_utils_leb128_js__WEBPACK_IMPORTED_MODULE_0__.slebDecode)(pipe));\n            switch (ty) {\n                case IDLTypeIds.Opt:\n                case IDLTypeIds.Vector: {\n                    const t = Number((0,_utils_leb128_js__WEBPACK_IMPORTED_MODULE_0__.slebDecode)(pipe));\n                    typeTable.push([ty, t]);\n                    break;\n                }\n                case IDLTypeIds.Record:\n                case IDLTypeIds.Variant: {\n                    const fields = [];\n                    let objectLength = Number((0,_utils_leb128_js__WEBPACK_IMPORTED_MODULE_0__.lebDecode)(pipe));\n                    let prevHash;\n                    while (objectLength--) {\n                        const hash = Number((0,_utils_leb128_js__WEBPACK_IMPORTED_MODULE_0__.lebDecode)(pipe));\n                        if (hash >= Math.pow(2, 32)) {\n                            throw new Error('field id out of 32-bit range');\n                        }\n                        if (typeof prevHash === 'number' && prevHash >= hash) {\n                            throw new Error('field id collision or not sorted');\n                        }\n                        prevHash = hash;\n                        const t = Number((0,_utils_leb128_js__WEBPACK_IMPORTED_MODULE_0__.slebDecode)(pipe));\n                        fields.push([hash, t]);\n                    }\n                    typeTable.push([ty, fields]);\n                    break;\n                }\n                case IDLTypeIds.Func: {\n                    const args = [];\n                    let argLength = Number((0,_utils_leb128_js__WEBPACK_IMPORTED_MODULE_0__.lebDecode)(pipe));\n                    while (argLength--) {\n                        args.push(Number((0,_utils_leb128_js__WEBPACK_IMPORTED_MODULE_0__.slebDecode)(pipe)));\n                    }\n                    const returnValues = [];\n                    let returnValuesLength = Number((0,_utils_leb128_js__WEBPACK_IMPORTED_MODULE_0__.lebDecode)(pipe));\n                    while (returnValuesLength--) {\n                        returnValues.push(Number((0,_utils_leb128_js__WEBPACK_IMPORTED_MODULE_0__.slebDecode)(pipe)));\n                    }\n                    const annotations = [];\n                    let annotationLength = Number((0,_utils_leb128_js__WEBPACK_IMPORTED_MODULE_0__.lebDecode)(pipe));\n                    while (annotationLength--) {\n                        const annotation = Number((0,_utils_leb128_js__WEBPACK_IMPORTED_MODULE_0__.lebDecode)(pipe));\n                        switch (annotation) {\n                            case 1: {\n                                annotations.push('query');\n                                break;\n                            }\n                            case 2: {\n                                annotations.push('oneway');\n                                break;\n                            }\n                            case 3: {\n                                annotations.push('composite_query');\n                                break;\n                            }\n                            default:\n                                throw new Error('unknown annotation');\n                        }\n                    }\n                    typeTable.push([ty, [args, returnValues, annotations]]);\n                    break;\n                }\n                case IDLTypeIds.Service: {\n                    let servLength = Number((0,_utils_leb128_js__WEBPACK_IMPORTED_MODULE_0__.lebDecode)(pipe));\n                    const methods = [];\n                    while (servLength--) {\n                        const nameLength = Number((0,_utils_leb128_js__WEBPACK_IMPORTED_MODULE_0__.lebDecode)(pipe));\n                        const funcName = new TextDecoder().decode((0,_utils_leb128_js__WEBPACK_IMPORTED_MODULE_0__.safeRead)(pipe, nameLength));\n                        const funcType = (0,_utils_leb128_js__WEBPACK_IMPORTED_MODULE_0__.slebDecode)(pipe);\n                        methods.push([funcName, funcType]);\n                    }\n                    typeTable.push([ty, methods]);\n                    break;\n                }\n                default:\n                    throw new Error('Illegal op_code: ' + ty);\n            }\n        }\n        const rawList = [];\n        const length = Number((0,_utils_leb128_js__WEBPACK_IMPORTED_MODULE_0__.lebDecode)(pipe));\n        for (let i = 0; i < length; i++) {\n            rawList.push(Number((0,_utils_leb128_js__WEBPACK_IMPORTED_MODULE_0__.slebDecode)(pipe)));\n        }\n        return [typeTable, rawList];\n    }\n    const [rawTable, rawTypes] = readTypeTable(b);\n    if (rawTypes.length < retTypes.length) {\n        throw new Error('Wrong number of return values');\n    }\n    const table = rawTable.map(_ => Rec());\n    function getType(t) {\n        if (t < -24) {\n            throw new Error('future value not supported');\n        }\n        if (t < 0) {\n            switch (t) {\n                case -1:\n                    return Null;\n                case -2:\n                    return Bool;\n                case -3:\n                    return Nat;\n                case -4:\n                    return Int;\n                case -5:\n                    return Nat8;\n                case -6:\n                    return Nat16;\n                case -7:\n                    return Nat32;\n                case -8:\n                    return Nat64;\n                case -9:\n                    return Int8;\n                case -10:\n                    return Int16;\n                case -11:\n                    return Int32;\n                case -12:\n                    return Int64;\n                case -13:\n                    return Float32;\n                case -14:\n                    return Float64;\n                case -15:\n                    return Text;\n                case -16:\n                    return Reserved;\n                case -17:\n                    return Empty;\n                case -24:\n                    return Principal;\n                default:\n                    throw new Error('Illegal op_code: ' + t);\n            }\n        }\n        if (t >= rawTable.length) {\n            throw new Error('type index out of range');\n        }\n        return table[t];\n    }\n    function buildType(entry) {\n        switch (entry[0]) {\n            case IDLTypeIds.Vector: {\n                const ty = getType(entry[1]);\n                return Vec(ty);\n            }\n            case IDLTypeIds.Opt: {\n                const ty = getType(entry[1]);\n                return Opt(ty);\n            }\n            case IDLTypeIds.Record: {\n                const fields = {};\n                for (const [hash, ty] of entry[1]) {\n                    const name = `_${hash}_`;\n                    fields[name] = getType(ty);\n                }\n                const record = Record(fields);\n                const tuple = record.tryAsTuple();\n                if (Array.isArray(tuple)) {\n                    return Tuple(...tuple);\n                }\n                else {\n                    return record;\n                }\n            }\n            case IDLTypeIds.Variant: {\n                const fields = {};\n                for (const [hash, ty] of entry[1]) {\n                    const name = `_${hash}_`;\n                    fields[name] = getType(ty);\n                }\n                return Variant(fields);\n            }\n            case IDLTypeIds.Func: {\n                const [args, returnValues, annotations] = entry[1];\n                return Func(args.map((t) => getType(t)), returnValues.map((t) => getType(t)), annotations);\n            }\n            case IDLTypeIds.Service: {\n                const rec = {};\n                const methods = entry[1];\n                for (const [name, typeRef] of methods) {\n                    let type = getType(typeRef);\n                    if (type instanceof RecClass) {\n                        // unpack reference type\n                        type = type.getType();\n                    }\n                    if (!(type instanceof FuncClass)) {\n                        throw new Error('Illegal service definition: services can only contain functions');\n                    }\n                    rec[name] = type;\n                }\n                return Service(rec);\n            }\n            default:\n                throw new Error('Illegal op_code: ' + entry[0]);\n        }\n    }\n    rawTable.forEach((entry, i) => {\n        // Process function type first, so that we can construct the correct service type\n        if (entry[0] === IDLTypeIds.Func) {\n            const t = buildType(entry);\n            table[i].fill(t);\n        }\n    });\n    rawTable.forEach((entry, i) => {\n        if (entry[0] !== IDLTypeIds.Func) {\n            const t = buildType(entry);\n            table[i].fill(t);\n        }\n    });\n    resetSubtypeCache();\n    const types = rawTypes.map(t => getType(t));\n    try {\n        const output = retTypes.map((t, i) => {\n            return t.decodeValue(b, types[i]);\n        });\n        // skip unused values\n        for (let ind = retTypes.length; ind < types.length; ind++) {\n            types[ind].decodeValue(b, types[ind]);\n        }\n        if (b.byteLength > 0) {\n            throw new Error('decode: Left-over bytes');\n        }\n        return output;\n    }\n    finally {\n        resetSubtypeCache();\n    }\n}\n// Export Types instances.\nconst Empty = new EmptyClass();\nconst Reserved = new ReservedClass();\n/**\n * Client-only type for deserializing unknown data. Not supported by Candid, and its use is discouraged.\n */\nconst Unknown = new UnknownClass();\nconst Bool = new BoolClass();\nconst Null = new NullClass();\nconst Text = new TextClass();\nconst Int = new IntClass();\nconst Nat = new NatClass();\nconst Float32 = new FloatClass(32);\nconst Float64 = new FloatClass(64);\nconst Int8 = new FixedIntClass(8);\nconst Int16 = new FixedIntClass(16);\nconst Int32 = new FixedIntClass(32);\nconst Int64 = new FixedIntClass(64);\nconst Nat8 = new FixedNatClass(8);\nconst Nat16 = new FixedNatClass(16);\nconst Nat32 = new FixedNatClass(32);\nconst Nat64 = new FixedNatClass(64);\nconst Principal = new PrincipalClass();\n/**\n *\n * @param types array of any types\n * @returns TupleClass from those types\n */\nfunction Tuple(...types) {\n    return new TupleClass(types);\n}\n/**\n *\n * @param t IDL Type\n * @returns VecClass from that type\n */\nfunction Vec(t) {\n    return new VecClass(t);\n}\n/**\n *\n * @param t IDL Type\n * @returns OptClass of Type\n */\nfunction Opt(t) {\n    return new OptClass(t);\n}\n/**\n *\n * @param t Record of string and IDL Type\n * @returns RecordClass of string and Type\n */\nfunction Record(t) {\n    return new RecordClass(t);\n}\n/**\n *\n * @param fields Record of string and IDL Type\n * @returns VariantClass\n */\nfunction Variant(fields) {\n    return new VariantClass(fields);\n}\n/**\n *\n * @returns new RecClass\n */\nfunction Rec() {\n    return new RecClass();\n}\n/**\n *\n * @param args array of IDL Types\n * @param ret array of IDL Types\n * @param annotations array of strings, [] by default\n * @returns new FuncClass\n */\nfunction Func(args, ret, annotations = []) {\n    return new FuncClass(args, ret, annotations);\n}\n/**\n *\n * @param t Record of string and FuncClass\n * @returns ServiceClass\n */\nfunction Service(t) {\n    return new ServiceClass(t);\n}\n/**\n * The list of relations between types we assume to hold. Uses the types .name property as key\n */\nclass Relations {\n    constructor(relations = new Map()) {\n        this.rels = relations;\n    }\n    copy() {\n        const copy = new Map();\n        for (const [key, value] of this.rels.entries()) {\n            const valCopy = new Map(value);\n            copy.set(key, valCopy);\n        }\n        return new Relations(copy);\n    }\n    /// Returns whether we know for sure that a relation holds or doesn't (`true` or `false`), or\n    /// if we don't know yet (`undefined`)\n    known(t1, t2) {\n        return this.rels.get(t1.name)?.get(t2.name);\n    }\n    addNegative(t1, t2) {\n        this.addNames(t1.name, t2.name, false);\n    }\n    add(t1, t2) {\n        this.addNames(t1.name, t2.name, true);\n    }\n    display() {\n        let result = '';\n        for (const [t1, v] of this.rels) {\n            for (const [t2, known] of v) {\n                const subty = known ? ':<' : '!<:';\n                result += `${t1} ${subty} ${t2}\\n`;\n            }\n        }\n        return result;\n    }\n    addNames(t1, t2, isSubtype) {\n        const t1Map = this.rels.get(t1);\n        if (t1Map == undefined) {\n            const newMap = new Map();\n            newMap.set(t2, isSubtype);\n            this.rels.set(t1, newMap);\n        }\n        else {\n            t1Map.set(t2, isSubtype);\n        }\n    }\n}\n/// `subtypeCache` holds subtyping relations we've previously computed while decoding a message\nlet subtypeCache = new Relations();\n/** Resets the global subtyping cache */\nfunction resetSubtypeCache() {\n    subtypeCache = new Relations();\n}\nfunction eqFunctionAnnotations(t1, t2) {\n    const t1Annotations = new Set(t1.annotations);\n    const t2Annotations = new Set(t2.annotations);\n    if (t1Annotations.size !== t2Annotations.size) {\n        return false;\n    }\n    for (const a of t1Annotations) {\n        if (!t2Annotations.has(a))\n            return false;\n    }\n    return true;\n}\nfunction canBeOmmitted(t) {\n    return t instanceof OptClass || t instanceof NullClass || t instanceof ReservedClass;\n}\n/**\n * Subtyping on Candid types t1 <: t2 (Exported for testing)\n * @param t1 The potential subtype\n * @param t2 The potential supertype\n */\nfunction subtype(t1, t2) {\n    const relations = subtypeCache.copy();\n    const isSubtype = subtype_(relations, t1, t2);\n    if (isSubtype) {\n        subtypeCache.add(t1, t2);\n    }\n    else {\n        subtypeCache.addNegative(t1, t2);\n    }\n    return isSubtype;\n}\nfunction subtype_(relations, t1, t2) {\n    if (t1.name === t2.name)\n        return true;\n    const known = relations.known(t1, t2);\n    if (known !== undefined)\n        return known;\n    relations.add(t1, t2);\n    if (t2 instanceof ReservedClass)\n        return true;\n    if (t1 instanceof EmptyClass)\n        return true;\n    if (t1 instanceof NatClass && t2 instanceof IntClass)\n        return true;\n    if (t1 instanceof VecClass && t2 instanceof VecClass)\n        return subtype_(relations, t1._type, t2._type);\n    if (t2 instanceof OptClass)\n        return true;\n    if (t1 instanceof RecordClass && t2 instanceof RecordClass) {\n        const t1Object = t1.fieldsAsObject;\n        for (const [label, ty2] of t2._fields) {\n            const ty1 = t1Object[(0,_utils_hash_js__WEBPACK_IMPORTED_MODULE_3__.idlLabelToId)(label)];\n            if (!ty1) {\n                if (!canBeOmmitted(ty2))\n                    return false;\n            }\n            else {\n                if (!subtype_(relations, ty1, ty2))\n                    return false;\n            }\n        }\n        return true;\n    }\n    if (t1 instanceof FuncClass && t2 instanceof FuncClass) {\n        if (!eqFunctionAnnotations(t1, t2))\n            return false;\n        for (let i = 0; i < t1.argTypes.length; i++) {\n            const argTy1 = t1.argTypes[i];\n            if (i < t2.argTypes.length) {\n                if (!subtype_(relations, t2.argTypes[i], argTy1))\n                    return false;\n            }\n            else {\n                if (!canBeOmmitted(argTy1))\n                    return false;\n            }\n        }\n        for (let i = 0; i < t2.retTypes.length; i++) {\n            const retTy2 = t2.retTypes[i];\n            if (i < t1.retTypes.length) {\n                if (!subtype_(relations, t1.retTypes[i], retTy2))\n                    return false;\n            }\n            else {\n                if (!canBeOmmitted(retTy2))\n                    return false;\n            }\n        }\n        return true;\n    }\n    if (t1 instanceof VariantClass && t2 instanceof VariantClass) {\n        const t2Object = t2.alternativesAsObject;\n        for (const [label, ty1] of t1._fields) {\n            const ty2 = t2Object[(0,_utils_hash_js__WEBPACK_IMPORTED_MODULE_3__.idlLabelToId)(label)];\n            if (!ty2)\n                return false;\n            if (!subtype_(relations, ty1, ty2))\n                return false;\n        }\n        return true;\n    }\n    if (t1 instanceof ServiceClass && t2 instanceof ServiceClass) {\n        const t1Object = t1.fieldsAsObject();\n        for (const [name, ty2] of t2._fields) {\n            const ty1 = t1Object[name];\n            if (!ty1)\n                return false;\n            if (!subtype_(relations, ty1, ty2))\n                return false;\n        }\n        return true;\n    }\n    if (t1 instanceof RecClass) {\n        return subtype_(relations, t1.getType(), t2);\n    }\n    if (t2 instanceof RecClass) {\n        return subtype_(relations, t1, t2.getType());\n    }\n    return false;\n}\n//# sourceMappingURL=idl.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vcGFja2FnZXMvc2RrLWpzL25vZGVfbW9kdWxlcy9AZGZpbml0eS9jYW5kaWQvbGliL2VzbS9pZGwuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUM4RDtBQUN1QjtBQUN0QztBQUM0RztBQUM1RztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxnQ0FBZ0M7QUFDakM7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwyREFBUztBQUM3QixvQkFBb0Isd0RBQU07QUFDMUIsZUFBZSx3REFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw0REFBVTtBQUN6QjtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxLQUFLO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsS0FBSztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSx3Q0FBd0Msb0JBQW9CO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ0E7QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLElBQUksRUFBRSxPQUFPLEVBQUUsR0FBRztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyw0REFBWTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHdCQUF3QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix3QkFBd0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLDREQUFZO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BpcXViZS9vcHMtY29uc29sZS8uLi8uLi9wYWNrYWdlcy9zZGstanMvbm9kZV9tb2R1bGVzL0BkZmluaXR5L2NhbmRpZC9saWIvZXNtL2lkbC5qcz9kMTE3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFycyAqL1xuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xuaW1wb3J0IHsgUHJpbmNpcGFsIGFzIFByaW5jaXBhbElkIH0gZnJvbSAnQGRmaW5pdHkvcHJpbmNpcGFsJztcbmltcG9ydCB7IGNvbmNhdCwgUGlwZUFycmF5QnVmZmVyIGFzIFBpcGUsIHVpbnQ4VG9EYXRhVmlldyB9IGZyb20gXCIuL3V0aWxzL2J1ZmZlci5qc1wiO1xuaW1wb3J0IHsgaWRsTGFiZWxUb0lkIH0gZnJvbSBcIi4vdXRpbHMvaGFzaC5qc1wiO1xuaW1wb3J0IHsgbGViRGVjb2RlLCBsZWJFbmNvZGUsIHJlYWRJbnRMRSwgcmVhZFVJbnRMRSwgc2FmZVJlYWQsIHNhZmVSZWFkVWludDgsIHNsZWJEZWNvZGUsIHNsZWJFbmNvZGUsIHdyaXRlSW50TEUsIHdyaXRlVUludExFLCB9IGZyb20gXCIuL3V0aWxzL2xlYjEyOC5qc1wiO1xuaW1wb3J0IHsgaWV4cDIgfSBmcm9tIFwiLi91dGlscy9iaWdpbnQtbWF0aC5qc1wiO1xuLyoqXG4gKiBUaGlzIG1vZHVsZSBwcm92aWRlcyBhIGNvbWJpbmF0b3IgbGlicmFyeSB0byBjcmVhdGUgc2VyaWFsaXplcnMvZGVzZXJpYWxpemVyc1xuICogYmV0d2VlbiBKYXZhU2NyaXB0IHZhbHVlcyBhbmQgSURMIHVzZWQgYnkgY2FuaXN0ZXJzIG9uIHRoZSBJbnRlcm5ldCBDb21wdXRlcixcbiAqIGFzIGRvY3VtZW50ZWQgYXQgaHR0cHM6Ly9naXRodWIuY29tL2RmaW5pdHkvY2FuZGlkL2Jsb2IvMTE5NzAzYmEzNDJkMmZlZjZhYjQ5NzJkMjU0MWI5ZmUzNmFlOGUzNi9zcGVjL0NhbmRpZC5tZFxuICovXG52YXIgSURMVHlwZUlkcztcbihmdW5jdGlvbiAoSURMVHlwZUlkcykge1xuICAgIElETFR5cGVJZHNbSURMVHlwZUlkc1tcIk51bGxcIl0gPSAtMV0gPSBcIk51bGxcIjtcbiAgICBJRExUeXBlSWRzW0lETFR5cGVJZHNbXCJCb29sXCJdID0gLTJdID0gXCJCb29sXCI7XG4gICAgSURMVHlwZUlkc1tJRExUeXBlSWRzW1wiTmF0XCJdID0gLTNdID0gXCJOYXRcIjtcbiAgICBJRExUeXBlSWRzW0lETFR5cGVJZHNbXCJJbnRcIl0gPSAtNF0gPSBcIkludFwiO1xuICAgIElETFR5cGVJZHNbSURMVHlwZUlkc1tcIkZsb2F0MzJcIl0gPSAtMTNdID0gXCJGbG9hdDMyXCI7XG4gICAgSURMVHlwZUlkc1tJRExUeXBlSWRzW1wiRmxvYXQ2NFwiXSA9IC0xNF0gPSBcIkZsb2F0NjRcIjtcbiAgICBJRExUeXBlSWRzW0lETFR5cGVJZHNbXCJUZXh0XCJdID0gLTE1XSA9IFwiVGV4dFwiO1xuICAgIElETFR5cGVJZHNbSURMVHlwZUlkc1tcIlJlc2VydmVkXCJdID0gLTE2XSA9IFwiUmVzZXJ2ZWRcIjtcbiAgICBJRExUeXBlSWRzW0lETFR5cGVJZHNbXCJFbXB0eVwiXSA9IC0xN10gPSBcIkVtcHR5XCI7XG4gICAgSURMVHlwZUlkc1tJRExUeXBlSWRzW1wiT3B0XCJdID0gLTE4XSA9IFwiT3B0XCI7XG4gICAgSURMVHlwZUlkc1tJRExUeXBlSWRzW1wiVmVjdG9yXCJdID0gLTE5XSA9IFwiVmVjdG9yXCI7XG4gICAgSURMVHlwZUlkc1tJRExUeXBlSWRzW1wiUmVjb3JkXCJdID0gLTIwXSA9IFwiUmVjb3JkXCI7XG4gICAgSURMVHlwZUlkc1tJRExUeXBlSWRzW1wiVmFyaWFudFwiXSA9IC0yMV0gPSBcIlZhcmlhbnRcIjtcbiAgICBJRExUeXBlSWRzW0lETFR5cGVJZHNbXCJGdW5jXCJdID0gLTIyXSA9IFwiRnVuY1wiO1xuICAgIElETFR5cGVJZHNbSURMVHlwZUlkc1tcIlNlcnZpY2VcIl0gPSAtMjNdID0gXCJTZXJ2aWNlXCI7XG4gICAgSURMVHlwZUlkc1tJRExUeXBlSWRzW1wiUHJpbmNpcGFsXCJdID0gLTI0XSA9IFwiUHJpbmNpcGFsXCI7XG59KShJRExUeXBlSWRzIHx8IChJRExUeXBlSWRzID0ge30pKTtcbmNvbnN0IG1hZ2ljTnVtYmVyID0gJ0RJREwnO1xuY29uc3QgdG9SZWFkYWJsZVN0cmluZ19tYXggPSA0MDA7IC8vIHdpbGwgbm90IGRpc3BsYXkgYXJndW1lbnRzIGFmdGVyIDQwMGNoYXJzLiBNYWtlcyBzdXJlIDJtYiBibG9icyBkb24ndCBnZXQgaW5zaWRlIHRoZSBlcnJvclxuZnVuY3Rpb24gemlwV2l0aCh4cywgeXMsIGYpIHtcbiAgICByZXR1cm4geHMubWFwKCh4LCBpKSA9PiBmKHgsIHlzW2ldKSk7XG59XG4vKipcbiAqIEFuIElETCBUeXBlIFRhYmxlLCB3aGljaCBwcmVjZWRlcyB0aGUgZGF0YSBpbiB0aGUgc3RyZWFtLlxuICovXG5jbGFzcyBUeXBlVGFibGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAvLyBMaXN0IG9mIHR5cGVzLiBOZWVkcyB0byBiZSBhbiBhcnJheSBhcyB0aGUgaW5kZXggbmVlZHMgdG8gYmUgc3RhYmxlLlxuICAgICAgICB0aGlzLl90eXBzID0gW107XG4gICAgICAgIHRoaXMuX2lkeCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5faWR4UmVmQ291bnQgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIGhhcyhvYmopIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lkeC5oYXMob2JqLm5hbWUpO1xuICAgIH1cbiAgICBhZGQodHlwZSwgYnVmKSB7XG4gICAgICAgIGNvbnN0IGlkeCA9IHRoaXMuX3R5cHMubGVuZ3RoO1xuICAgICAgICB0aGlzLl9pZHguc2V0KHR5cGUubmFtZSwgaWR4KTtcbiAgICAgICAgdGhpcy5faWR4UmVmQ291bnQuc2V0KGlkeCwgMSk7XG4gICAgICAgIHRoaXMuX3R5cHMucHVzaChidWYpO1xuICAgIH1cbiAgICBtZXJnZShvYmosIGtub3QpIHtcbiAgICAgICAgY29uc3QgaWR4ID0gdGhpcy5faWR4LmdldChvYmoubmFtZSk7XG4gICAgICAgIGNvbnN0IGtub3RJZHggPSB0aGlzLl9pZHguZ2V0KGtub3QpO1xuICAgICAgICBpZiAoaWR4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyB0eXBlIGluZGV4IGZvciAnICsgb2JqKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoa25vdElkeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgdHlwZSBpbmRleCBmb3IgJyArIGtub3QpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3R5cHNbaWR4XSA9IHRoaXMuX3R5cHNba25vdElkeF07XG4gICAgICAgIC8vIERlY3JlbWVudCByZWZlcmVuY2UgY291bnQgc2luY2Ugd2UncmUgcmVtb3ZpbmcgdGhlIGtub3QgbmFtZSBtYXBwaW5nXG4gICAgICAgIGNvbnN0IGtub3RSZWZDb3VudCA9IHRoaXMuX2dldElkeFJlZkNvdW50KGtub3RJZHgpO1xuICAgICAgICB0aGlzLl9pZHhSZWZDb3VudC5zZXQoa25vdElkeCwga25vdFJlZkNvdW50IC0gMSk7XG4gICAgICAgIHRoaXMuX2lkeC5kZWxldGUoa25vdCk7XG4gICAgICAgIHRoaXMuX2NvbXBhY3RGcm9tRW5kKCk7XG4gICAgfVxuICAgIF9nZXRJZHhSZWZDb3VudChpZHgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lkeFJlZkNvdW50LmdldChpZHgpIHx8IDA7XG4gICAgfVxuICAgIF9jb21wYWN0RnJvbUVuZCgpIHtcbiAgICAgICAgLy8gUmVtb3ZlIHVudXNlZCBlbnRyaWVzIGZyb20gdGhlIGVuZCBvZiB0aGUgYXJyYXlcbiAgICAgICAgd2hpbGUgKHRoaXMuX3R5cHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgbGFzdEluZGV4ID0gdGhpcy5fdHlwcy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2dldElkeFJlZkNvdW50KGxhc3RJbmRleCkgPiAwKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl90eXBzLnBvcCgpO1xuICAgICAgICAgICAgdGhpcy5faWR4UmVmQ291bnQuZGVsZXRlKGxhc3RJbmRleCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZW5jb2RlKCkge1xuICAgICAgICBjb25zdCBsZW4gPSBsZWJFbmNvZGUodGhpcy5fdHlwcy5sZW5ndGgpO1xuICAgICAgICBjb25zdCBidWYgPSBjb25jYXQoLi4udGhpcy5fdHlwcyk7XG4gICAgICAgIHJldHVybiBjb25jYXQobGVuLCBidWYpO1xuICAgIH1cbiAgICBpbmRleE9mKHR5cGVOYW1lKSB7XG4gICAgICAgIGlmICghdGhpcy5faWR4Lmhhcyh0eXBlTmFtZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyB0eXBlIGluZGV4IGZvciAnICsgdHlwZU5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzbGViRW5jb2RlKHRoaXMuX2lkeC5nZXQodHlwZU5hbWUpIHx8IDApO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBWaXNpdG9yIHtcbiAgICB2aXNpdFR5cGUoX3QsIF9kYXRhKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkJyk7XG4gICAgfVxuICAgIHZpc2l0UHJpbWl0aXZlKHQsIGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRUeXBlKHQsIGRhdGEpO1xuICAgIH1cbiAgICB2aXNpdEVtcHR5KHQsIGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRQcmltaXRpdmUodCwgZGF0YSk7XG4gICAgfVxuICAgIHZpc2l0Qm9vbCh0LCBkYXRhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2l0UHJpbWl0aXZlKHQsIGRhdGEpO1xuICAgIH1cbiAgICB2aXNpdE51bGwodCwgZGF0YSkge1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpdFByaW1pdGl2ZSh0LCBkYXRhKTtcbiAgICB9XG4gICAgdmlzaXRSZXNlcnZlZCh0LCBkYXRhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2l0UHJpbWl0aXZlKHQsIGRhdGEpO1xuICAgIH1cbiAgICB2aXNpdFRleHQodCwgZGF0YSkge1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpdFByaW1pdGl2ZSh0LCBkYXRhKTtcbiAgICB9XG4gICAgdmlzaXROdW1iZXIodCwgZGF0YSkge1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpdFByaW1pdGl2ZSh0LCBkYXRhKTtcbiAgICB9XG4gICAgdmlzaXRJbnQodCwgZGF0YSkge1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpdE51bWJlcih0LCBkYXRhKTtcbiAgICB9XG4gICAgdmlzaXROYXQodCwgZGF0YSkge1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpdE51bWJlcih0LCBkYXRhKTtcbiAgICB9XG4gICAgdmlzaXRGbG9hdCh0LCBkYXRhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2l0UHJpbWl0aXZlKHQsIGRhdGEpO1xuICAgIH1cbiAgICB2aXNpdEZpeGVkSW50KHQsIGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaXROdW1iZXIodCwgZGF0YSk7XG4gICAgfVxuICAgIHZpc2l0Rml4ZWROYXQodCwgZGF0YSkge1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpdE51bWJlcih0LCBkYXRhKTtcbiAgICB9XG4gICAgdmlzaXRQcmluY2lwYWwodCwgZGF0YSkge1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpdFByaW1pdGl2ZSh0LCBkYXRhKTtcbiAgICB9XG4gICAgdmlzaXRDb25zdHJ1Y3QodCwgZGF0YSkge1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpdFR5cGUodCwgZGF0YSk7XG4gICAgfVxuICAgIHZpc2l0VmVjKHQsIF90eSwgZGF0YSkge1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpdENvbnN0cnVjdCh0LCBkYXRhKTtcbiAgICB9XG4gICAgdmlzaXRPcHQodCwgX3R5LCBkYXRhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2l0Q29uc3RydWN0KHQsIGRhdGEpO1xuICAgIH1cbiAgICB2aXNpdFJlY29yZCh0LCBfZmllbGRzLCBkYXRhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2l0Q29uc3RydWN0KHQsIGRhdGEpO1xuICAgIH1cbiAgICB2aXNpdFR1cGxlKHQsIGNvbXBvbmVudHMsIGRhdGEpIHtcbiAgICAgICAgY29uc3QgZmllbGRzID0gY29tcG9uZW50cy5tYXAoKHR5LCBpKSA9PiBbYF8ke2l9X2AsIHR5XSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2l0UmVjb3JkKHQsIGZpZWxkcywgZGF0YSk7XG4gICAgfVxuICAgIHZpc2l0VmFyaWFudCh0LCBfZmllbGRzLCBkYXRhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2l0Q29uc3RydWN0KHQsIGRhdGEpO1xuICAgIH1cbiAgICB2aXNpdFJlYyhfdCwgdHksIGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRDb25zdHJ1Y3QodHksIGRhdGEpO1xuICAgIH1cbiAgICB2aXNpdEZ1bmModCwgZGF0YSkge1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpdENvbnN0cnVjdCh0LCBkYXRhKTtcbiAgICB9XG4gICAgdmlzaXRTZXJ2aWNlKHQsIGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRDb25zdHJ1Y3QodCwgZGF0YSk7XG4gICAgfVxufVxuLy8gV2UgdHJ5IHRvIHVzZSBoYXJkLXRvLWFjY2lkZW50YWxseS1waWNrIG5hbWVzIHRvIGF2b2lkIHBvdGVudGlhbCBjb2xsaXNpb25zIHdpdGggb3RoZXIgdHlwZXMuXG52YXIgSWRsVHlwZU5hbWU7XG4oZnVuY3Rpb24gKElkbFR5cGVOYW1lKSB7XG4gICAgSWRsVHlwZU5hbWVbXCJFbXB0eUNsYXNzXCJdID0gXCJfX0lETF9FbXB0eUNsYXNzX19cIjtcbiAgICBJZGxUeXBlTmFtZVtcIlVua25vd25DbGFzc1wiXSA9IFwiX19JRExfVW5rbm93bkNsYXNzX19cIjtcbiAgICBJZGxUeXBlTmFtZVtcIkJvb2xDbGFzc1wiXSA9IFwiX19JRExfQm9vbENsYXNzX19cIjtcbiAgICBJZGxUeXBlTmFtZVtcIk51bGxDbGFzc1wiXSA9IFwiX19JRExfTnVsbENsYXNzX19cIjtcbiAgICBJZGxUeXBlTmFtZVtcIlJlc2VydmVkQ2xhc3NcIl0gPSBcIl9fSURMX1Jlc2VydmVkQ2xhc3NfX1wiO1xuICAgIElkbFR5cGVOYW1lW1wiVGV4dENsYXNzXCJdID0gXCJfX0lETF9UZXh0Q2xhc3NfX1wiO1xuICAgIElkbFR5cGVOYW1lW1wiSW50Q2xhc3NcIl0gPSBcIl9fSURMX0ludENsYXNzX19cIjtcbiAgICBJZGxUeXBlTmFtZVtcIk5hdENsYXNzXCJdID0gXCJfX0lETF9OYXRDbGFzc19fXCI7XG4gICAgSWRsVHlwZU5hbWVbXCJGbG9hdENsYXNzXCJdID0gXCJfX0lETF9GbG9hdENsYXNzX19cIjtcbiAgICBJZGxUeXBlTmFtZVtcIkZpeGVkSW50Q2xhc3NcIl0gPSBcIl9fSURMX0ZpeGVkSW50Q2xhc3NfX1wiO1xuICAgIElkbFR5cGVOYW1lW1wiRml4ZWROYXRDbGFzc1wiXSA9IFwiX19JRExfRml4ZWROYXRDbGFzc19fXCI7XG4gICAgSWRsVHlwZU5hbWVbXCJWZWNDbGFzc1wiXSA9IFwiX19JRExfVmVjQ2xhc3NfX1wiO1xuICAgIElkbFR5cGVOYW1lW1wiT3B0Q2xhc3NcIl0gPSBcIl9fSURMX09wdENsYXNzX19cIjtcbiAgICBJZGxUeXBlTmFtZVtcIlJlY29yZENsYXNzXCJdID0gXCJfX0lETF9SZWNvcmRDbGFzc19fXCI7XG4gICAgSWRsVHlwZU5hbWVbXCJUdXBsZUNsYXNzXCJdID0gXCJfX0lETF9UdXBsZUNsYXNzX19cIjtcbiAgICBJZGxUeXBlTmFtZVtcIlZhcmlhbnRDbGFzc1wiXSA9IFwiX19JRExfVmFyaWFudENsYXNzX19cIjtcbiAgICBJZGxUeXBlTmFtZVtcIlJlY0NsYXNzXCJdID0gXCJfX0lETF9SZWNDbGFzc19fXCI7XG4gICAgSWRsVHlwZU5hbWVbXCJQcmluY2lwYWxDbGFzc1wiXSA9IFwiX19JRExfUHJpbmNpcGFsQ2xhc3NfX1wiO1xuICAgIElkbFR5cGVOYW1lW1wiRnVuY0NsYXNzXCJdID0gXCJfX0lETF9GdW5jQ2xhc3NfX1wiO1xuICAgIElkbFR5cGVOYW1lW1wiU2VydmljZUNsYXNzXCJdID0gXCJfX0lETF9TZXJ2aWNlQ2xhc3NfX1wiO1xufSkoSWRsVHlwZU5hbWUgfHwgKElkbFR5cGVOYW1lID0ge30pKTtcbi8qKlxuICogUmVwcmVzZW50cyBhbiBJREwgdHlwZS5cbiAqL1xuZXhwb3J0IGNsYXNzIFR5cGUge1xuICAgIC8qIERpc3BsYXkgdHlwZSBuYW1lICovXG4gICAgZGlzcGxheSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmFtZTtcbiAgICB9XG4gICAgdmFsdWVUb1N0cmluZyh4KSB7XG4gICAgICAgIHJldHVybiB0b1JlYWRhYmxlU3RyaW5nKHgpO1xuICAgIH1cbiAgICAvKiBJbXBsZW1lbnQgYFRgIGluIHRoZSBJREwgc3BlYywgb25seSBuZWVkZWQgZm9yIG5vbi1wcmltaXRpdmUgdHlwZXMgKi9cbiAgICBidWlsZFR5cGVUYWJsZSh0eXBlVGFibGUpIHtcbiAgICAgICAgaWYgKCF0eXBlVGFibGUuaGFzKHRoaXMpKSB7XG4gICAgICAgICAgICB0aGlzLl9idWlsZFR5cGVUYWJsZUltcGwodHlwZVRhYmxlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBQcmltaXRpdmVUeXBlIGV4dGVuZHMgVHlwZSB7XG4gICAgY2hlY2tUeXBlKHQpIHtcbiAgICAgICAgaWYgKHRoaXMubmFtZSAhPT0gdC5uYW1lKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHR5cGUgbWlzbWF0Y2g6IHR5cGUgb24gdGhlIHdpcmUgJHt0Lm5hbWV9LCBleHBlY3QgdHlwZSAke3RoaXMubmFtZX1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9XG4gICAgX2J1aWxkVHlwZVRhYmxlSW1wbChfdHlwZVRhYmxlKSB7XG4gICAgICAgIC8vIE5vIHR5cGUgdGFibGUgZW5jb2RpbmcgZm9yIFByaW1pdGl2ZSB0eXBlcy5cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBDb25zdHJ1Y3RUeXBlIGV4dGVuZHMgVHlwZSB7XG4gICAgY2hlY2tUeXBlKHQpIHtcbiAgICAgICAgaWYgKHQgaW5zdGFuY2VvZiBSZWNDbGFzcykge1xuICAgICAgICAgICAgY29uc3QgdHkgPSB0LmdldFR5cGUoKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdHkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0eXBlIG1pc21hdGNoIHdpdGggdW5pbml0aWFsaXplZCB0eXBlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB0eXBlIG1pc21hdGNoOiB0eXBlIG9uIHRoZSB3aXJlICR7dC5uYW1lfSwgZXhwZWN0IHR5cGUgJHt0aGlzLm5hbWV9YCk7XG4gICAgfVxuICAgIGVuY29kZVR5cGUodHlwZVRhYmxlKSB7XG4gICAgICAgIHJldHVybiB0eXBlVGFibGUuaW5kZXhPZih0aGlzLm5hbWUpO1xuICAgIH1cbn1cbi8qKlxuICogUmVwcmVzZW50cyBhbiBJREwgRW1wdHksIGEgdHlwZSB3aGljaCBoYXMgbm8gaW5oYWJpdGFudHMuXG4gKiBTaW5jZSBubyB2YWx1ZXMgZXhpc3QgZm9yIHRoaXMgdHlwZSwgaXQgY2Fubm90IGJlIHNlcmlhbGlzZWQgb3IgZGVzZXJpYWxpc2VkLlxuICogUmVzdWx0IHR5cGVzIGxpa2UgYFJlc3VsdDxUZXh0LCBFbXB0eT5gIHNob3VsZCBhbHdheXMgc3VjY2VlZC5cbiAqL1xuZXhwb3J0IGNsYXNzIEVtcHR5Q2xhc3MgZXh0ZW5kcyBQcmltaXRpdmVUeXBlIHtcbiAgICBnZXQgdHlwZU5hbWUoKSB7XG4gICAgICAgIHJldHVybiBJZGxUeXBlTmFtZS5FbXB0eUNsYXNzO1xuICAgIH1cbiAgICBzdGF0aWMgW1N5bWJvbC5oYXNJbnN0YW5jZV0oaW5zdGFuY2UpIHtcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlLnR5cGVOYW1lID09PSBJZGxUeXBlTmFtZS5FbXB0eUNsYXNzO1xuICAgIH1cbiAgICBhY2NlcHQodiwgZCkge1xuICAgICAgICByZXR1cm4gdi52aXNpdEVtcHR5KHRoaXMsIGQpO1xuICAgIH1cbiAgICBjb3ZhcmlhbnQoeCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgJHt0aGlzLmRpc3BsYXkoKX0gYXJndW1lbnQ6ICR7dG9SZWFkYWJsZVN0cmluZyh4KX1gKTtcbiAgICB9XG4gICAgZW5jb2RlVmFsdWUoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRW1wdHkgY2Fubm90IGFwcGVhciBhcyBhIGZ1bmN0aW9uIGFyZ3VtZW50Jyk7XG4gICAgfVxuICAgIHZhbHVlVG9TdHJpbmcoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRW1wdHkgY2Fubm90IGFwcGVhciBhcyBhIHZhbHVlJyk7XG4gICAgfVxuICAgIGVuY29kZVR5cGUoKSB7XG4gICAgICAgIHJldHVybiBzbGViRW5jb2RlKElETFR5cGVJZHMuRW1wdHkpO1xuICAgIH1cbiAgICBkZWNvZGVWYWx1ZSgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbXB0eSBjYW5ub3QgYXBwZWFyIGFzIGFuIG91dHB1dCcpO1xuICAgIH1cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuICdlbXB0eSc7XG4gICAgfVxufVxuLyoqXG4gKiBSZXByZXNlbnRzIGFuIElETCBVbmtub3duLCBhIHBsYWNlaG9sZGVyIHR5cGUgZm9yIGRlc2VyaWFsaXphdGlvbiBvbmx5LlxuICogV2hlbiBkZWNvZGluZyBhIHZhbHVlIGFzIFVua25vd24sIGFsbCBmaWVsZHMgd2lsbCBiZSByZXRhaW5lZCBidXQgdGhlIG5hbWVzIGFyZSBvbmx5IGF2YWlsYWJsZSBpblxuICogaGFzaGVkIGZvcm0uXG4gKiBBIGRlc2VyaWFsaXplZCB1bmtub3duIHdpbGwgb2ZmZXIgaXQncyBhY3R1YWwgdHlwZSBieSBjYWxsaW5nIHRoZSBgdHlwZSgpYCBmdW5jdGlvbi5cbiAqIFVua25vd24gY2Fubm90IGJlIHNlcmlhbGl6ZWQgYW5kIGF0dGVtcHRpbmcgdG8gZG8gc28gd2lsbCB0aHJvdyBhbiBlcnJvci5cbiAqL1xuZXhwb3J0IGNsYXNzIFVua25vd25DbGFzcyBleHRlbmRzIFR5cGUge1xuICAgIGdldCB0eXBlTmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIElkbFR5cGVOYW1lLlVua25vd25DbGFzcztcbiAgICB9XG4gICAgc3RhdGljIFtTeW1ib2wuaGFzSW5zdGFuY2VdKGluc3RhbmNlKSB7XG4gICAgICAgIHJldHVybiBpbnN0YW5jZS50eXBlTmFtZSA9PT0gSWRsVHlwZU5hbWUuVW5rbm93bkNsYXNzO1xuICAgIH1cbiAgICBjaGVja1R5cGUoX3QpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNZXRob2Qgbm90IGltcGxlbWVudGVkIGZvciB1bmtub3duLicpO1xuICAgIH1cbiAgICBhY2NlcHQodiwgZCkge1xuICAgICAgICB0aHJvdyB2LnZpc2l0VHlwZSh0aGlzLCBkKTtcbiAgICB9XG4gICAgY292YXJpYW50KHgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkICR7dGhpcy5kaXNwbGF5KCl9IGFyZ3VtZW50OiAke3RvUmVhZGFibGVTdHJpbmcoeCl9YCk7XG4gICAgfVxuICAgIGVuY29kZVZhbHVlKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gY2Fubm90IGFwcGVhciBhcyBhIGZ1bmN0aW9uIGFyZ3VtZW50Jyk7XG4gICAgfVxuICAgIHZhbHVlVG9TdHJpbmcoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBjYW5ub3QgYXBwZWFyIGFzIGEgdmFsdWUnKTtcbiAgICB9XG4gICAgZW5jb2RlVHlwZSgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGNhbm5vdCBiZSBzZXJpYWxpemVkJyk7XG4gICAgfVxuICAgIGRlY29kZVZhbHVlKGIsIHQpIHtcbiAgICAgICAgbGV0IGRlY29kZWRWYWx1ZSA9IHQuZGVjb2RlVmFsdWUoYiwgdCk7XG4gICAgICAgIGlmIChPYmplY3QoZGVjb2RlZFZhbHVlKSAhPT0gZGVjb2RlZFZhbHVlKSB7XG4gICAgICAgICAgICAvLyBkZWNvZGVkVmFsdWUgaXMgcHJpbWl0aXZlLiBCb3ggaXQsIG90aGVyd2lzZSB3ZSBjYW5ub3QgYWRkIHRoZSB0eXBlKCkgZnVuY3Rpb24uXG4gICAgICAgICAgICAvLyBUaGUgdHlwZSgpIGZ1bmN0aW9uIGlzIGltcG9ydGFudCBmb3IgcHJpbWl0aXZlcyBiZWNhdXNlIG90aGVyd2lzZSB3ZSBjYW5ub3QgdGVsbCBhcGFydCB0aGVcbiAgICAgICAgICAgIC8vIGRpZmZlcmVudCBudW1iZXIgdHlwZXMuXG4gICAgICAgICAgICBkZWNvZGVkVmFsdWUgPSBPYmplY3QoZGVjb2RlZFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdHlwZUZ1bmM7XG4gICAgICAgIGlmICh0IGluc3RhbmNlb2YgUmVjQ2xhc3MpIHtcbiAgICAgICAgICAgIHR5cGVGdW5jID0gKCkgPT4gdC5nZXRUeXBlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0eXBlRnVuYyA9ICgpID0+IHQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRG8gbm90IHVzZSAnZGVjb2RlZFZhbHVlLnR5cGUgPSB0eXBlRnVuYycgYmVjYXVzZSB0aGlzIHdvdWxkIGxlYWQgdG8gYW4gZW51bWVyYWJsZSBwcm9wZXJ0eVxuICAgICAgICAvLyAndHlwZScgd2hpY2ggbWVhbnMgaXQgd291bGQgYmUgc2VyaWFsaXplZCBpZiB0aGUgdmFsdWUgd291bGQgYmUgY2FuZGlkIGVuY29kZWQgYWdhaW4uXG4gICAgICAgIC8vIFRoaXMgaW4gdHVybiBsZWFkcyB0byBwcm9ibGVtcyBpZiB0aGUgZGVjb2RlZCB2YWx1ZSBpcyBhIHZhcmlhbnQgYmVjYXVzZSB0aGVzZSB2YWx1ZXMgYXJlXG4gICAgICAgIC8vIG9ubHkgYWxsb3dlZCB0byBoYXZlIGEgc2luZ2xlIHByb3BlcnR5LlxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZGVjb2RlZFZhbHVlLCAndHlwZScsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0eXBlRnVuYyxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZGVjb2RlZFZhbHVlO1xuICAgIH1cbiAgICBfYnVpbGRUeXBlVGFibGVJbXBsKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gY2Fubm90IGJlIHNlcmlhbGl6ZWQnKTtcbiAgICB9XG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiAnVW5rbm93bic7XG4gICAgfVxufVxuLyoqXG4gKiBSZXByZXNlbnRzIGFuIElETCBCb29sXG4gKi9cbmV4cG9ydCBjbGFzcyBCb29sQ2xhc3MgZXh0ZW5kcyBQcmltaXRpdmVUeXBlIHtcbiAgICBnZXQgdHlwZU5hbWUoKSB7XG4gICAgICAgIHJldHVybiBJZGxUeXBlTmFtZS5Cb29sQ2xhc3M7XG4gICAgfVxuICAgIHN0YXRpYyBbU3ltYm9sLmhhc0luc3RhbmNlXShpbnN0YW5jZSkge1xuICAgICAgICByZXR1cm4gaW5zdGFuY2UudHlwZU5hbWUgPT09IElkbFR5cGVOYW1lLkJvb2xDbGFzcztcbiAgICB9XG4gICAgYWNjZXB0KHYsIGQpIHtcbiAgICAgICAgcmV0dXJuIHYudmlzaXRCb29sKHRoaXMsIGQpO1xuICAgIH1cbiAgICBjb3ZhcmlhbnQoeCkge1xuICAgICAgICBpZiAodHlwZW9mIHggPT09ICdib29sZWFuJylcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgJHt0aGlzLmRpc3BsYXkoKX0gYXJndW1lbnQ6ICR7dG9SZWFkYWJsZVN0cmluZyh4KX1gKTtcbiAgICB9XG4gICAgZW5jb2RlVmFsdWUoeCkge1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoW3ggPyAxIDogMF0pO1xuICAgIH1cbiAgICBlbmNvZGVUeXBlKCkge1xuICAgICAgICByZXR1cm4gc2xlYkVuY29kZShJRExUeXBlSWRzLkJvb2wpO1xuICAgIH1cbiAgICBkZWNvZGVWYWx1ZShiLCB0KSB7XG4gICAgICAgIHRoaXMuY2hlY2tUeXBlKHQpO1xuICAgICAgICBzd2l0Y2ggKHNhZmVSZWFkVWludDgoYikpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQm9vbGVhbiB2YWx1ZSBvdXQgb2YgcmFuZ2UnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuICdib29sJztcbiAgICB9XG59XG4vKipcbiAqIFJlcHJlc2VudHMgYW4gSURMIE51bGxcbiAqL1xuZXhwb3J0IGNsYXNzIE51bGxDbGFzcyBleHRlbmRzIFByaW1pdGl2ZVR5cGUge1xuICAgIGdldCB0eXBlTmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIElkbFR5cGVOYW1lLk51bGxDbGFzcztcbiAgICB9XG4gICAgc3RhdGljIFtTeW1ib2wuaGFzSW5zdGFuY2VdKGluc3RhbmNlKSB7XG4gICAgICAgIHJldHVybiBpbnN0YW5jZS50eXBlTmFtZSA9PT0gSWRsVHlwZU5hbWUuTnVsbENsYXNzO1xuICAgIH1cbiAgICBhY2NlcHQodiwgZCkge1xuICAgICAgICByZXR1cm4gdi52aXNpdE51bGwodGhpcywgZCk7XG4gICAgfVxuICAgIGNvdmFyaWFudCh4KSB7XG4gICAgICAgIGlmICh4ID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCAke3RoaXMuZGlzcGxheSgpfSBhcmd1bWVudDogJHt0b1JlYWRhYmxlU3RyaW5nKHgpfWApO1xuICAgIH1cbiAgICBlbmNvZGVWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KDApO1xuICAgIH1cbiAgICBlbmNvZGVUeXBlKCkge1xuICAgICAgICByZXR1cm4gc2xlYkVuY29kZShJRExUeXBlSWRzLk51bGwpO1xuICAgIH1cbiAgICBkZWNvZGVWYWx1ZShfYiwgdCkge1xuICAgICAgICB0aGlzLmNoZWNrVHlwZSh0KTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gJ251bGwnO1xuICAgIH1cbn1cbi8qKlxuICogUmVwcmVzZW50cyBhbiBJREwgUmVzZXJ2ZWRcbiAqL1xuZXhwb3J0IGNsYXNzIFJlc2VydmVkQ2xhc3MgZXh0ZW5kcyBQcmltaXRpdmVUeXBlIHtcbiAgICBnZXQgdHlwZU5hbWUoKSB7XG4gICAgICAgIHJldHVybiBJZGxUeXBlTmFtZS5SZXNlcnZlZENsYXNzO1xuICAgIH1cbiAgICBzdGF0aWMgW1N5bWJvbC5oYXNJbnN0YW5jZV0oaW5zdGFuY2UpIHtcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlLnR5cGVOYW1lID09PSBJZGxUeXBlTmFtZS5SZXNlcnZlZENsYXNzO1xuICAgIH1cbiAgICBhY2NlcHQodiwgZCkge1xuICAgICAgICByZXR1cm4gdi52aXNpdFJlc2VydmVkKHRoaXMsIGQpO1xuICAgIH1cbiAgICBjb3ZhcmlhbnQoX3gpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGVuY29kZVZhbHVlKCkge1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoMCk7XG4gICAgfVxuICAgIGVuY29kZVR5cGUoKSB7XG4gICAgICAgIHJldHVybiBzbGViRW5jb2RlKElETFR5cGVJZHMuUmVzZXJ2ZWQpO1xuICAgIH1cbiAgICBkZWNvZGVWYWx1ZShiLCB0KSB7XG4gICAgICAgIGlmICh0Lm5hbWUgIT09IHRoaXMubmFtZSkge1xuICAgICAgICAgICAgdC5kZWNvZGVWYWx1ZShiLCB0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiAncmVzZXJ2ZWQnO1xuICAgIH1cbn1cbi8qKlxuICogUmVwcmVzZW50cyBhbiBJREwgVGV4dFxuICovXG5leHBvcnQgY2xhc3MgVGV4dENsYXNzIGV4dGVuZHMgUHJpbWl0aXZlVHlwZSB7XG4gICAgZ2V0IHR5cGVOYW1lKCkge1xuICAgICAgICByZXR1cm4gSWRsVHlwZU5hbWUuVGV4dENsYXNzO1xuICAgIH1cbiAgICBzdGF0aWMgW1N5bWJvbC5oYXNJbnN0YW5jZV0oaW5zdGFuY2UpIHtcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlLnR5cGVOYW1lID09PSBJZGxUeXBlTmFtZS5UZXh0Q2xhc3M7XG4gICAgfVxuICAgIGFjY2VwdCh2LCBkKSB7XG4gICAgICAgIHJldHVybiB2LnZpc2l0VGV4dCh0aGlzLCBkKTtcbiAgICB9XG4gICAgY292YXJpYW50KHgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB4ID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgJHt0aGlzLmRpc3BsYXkoKX0gYXJndW1lbnQ6ICR7dG9SZWFkYWJsZVN0cmluZyh4KX1gKTtcbiAgICB9XG4gICAgZW5jb2RlVmFsdWUoeCkge1xuICAgICAgICBjb25zdCBidWYgPSBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoeCk7XG4gICAgICAgIGNvbnN0IGxlbiA9IGxlYkVuY29kZShidWYuYnl0ZUxlbmd0aCk7XG4gICAgICAgIHJldHVybiBjb25jYXQobGVuLCBidWYpO1xuICAgIH1cbiAgICBlbmNvZGVUeXBlKCkge1xuICAgICAgICByZXR1cm4gc2xlYkVuY29kZShJRExUeXBlSWRzLlRleHQpO1xuICAgIH1cbiAgICBkZWNvZGVWYWx1ZShiLCB0KSB7XG4gICAgICAgIHRoaXMuY2hlY2tUeXBlKHQpO1xuICAgICAgICBjb25zdCBsZW4gPSBsZWJEZWNvZGUoYik7XG4gICAgICAgIGNvbnN0IGJ1ZiA9IHNhZmVSZWFkKGIsIE51bWJlcihsZW4pKTtcbiAgICAgICAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigndXRmOCcsIHsgZmF0YWw6IHRydWUgfSk7XG4gICAgICAgIHJldHVybiBkZWNvZGVyLmRlY29kZShidWYpO1xuICAgIH1cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuICd0ZXh0JztcbiAgICB9XG4gICAgdmFsdWVUb1N0cmluZyh4KSB7XG4gICAgICAgIHJldHVybiAnXCInICsgeCArICdcIic7XG4gICAgfVxufVxuLyoqXG4gKiBSZXByZXNlbnRzIGFuIElETCBJbnRcbiAqL1xuZXhwb3J0IGNsYXNzIEludENsYXNzIGV4dGVuZHMgUHJpbWl0aXZlVHlwZSB7XG4gICAgZ2V0IHR5cGVOYW1lKCkge1xuICAgICAgICByZXR1cm4gSWRsVHlwZU5hbWUuSW50Q2xhc3M7XG4gICAgfVxuICAgIHN0YXRpYyBbU3ltYm9sLmhhc0luc3RhbmNlXShpbnN0YW5jZSkge1xuICAgICAgICByZXR1cm4gaW5zdGFuY2UudHlwZU5hbWUgPT09IElkbFR5cGVOYW1lLkludENsYXNzO1xuICAgIH1cbiAgICBhY2NlcHQodiwgZCkge1xuICAgICAgICByZXR1cm4gdi52aXNpdEludCh0aGlzLCBkKTtcbiAgICB9XG4gICAgY292YXJpYW50KHgpIHtcbiAgICAgICAgLy8gV2UgYWxsb3cgZW5jb2Rpbmcgb2YgSmF2YVNjcmlwdCBwbGFpbiBudW1iZXJzLlxuICAgICAgICAvLyBCdXQgd2Ugd2lsbCBhbHdheXMgZGVjb2RlIHRvIGJpZ2ludC5cbiAgICAgICAgaWYgKHR5cGVvZiB4ID09PSAnYmlnaW50JyB8fCBOdW1iZXIuaXNJbnRlZ2VyKHgpKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCAke3RoaXMuZGlzcGxheSgpfSBhcmd1bWVudDogJHt0b1JlYWRhYmxlU3RyaW5nKHgpfWApO1xuICAgIH1cbiAgICBlbmNvZGVWYWx1ZSh4KSB7XG4gICAgICAgIHJldHVybiBzbGViRW5jb2RlKHgpO1xuICAgIH1cbiAgICBlbmNvZGVUeXBlKCkge1xuICAgICAgICByZXR1cm4gc2xlYkVuY29kZShJRExUeXBlSWRzLkludCk7XG4gICAgfVxuICAgIGRlY29kZVZhbHVlKGIsIHQpIHtcbiAgICAgICAgdGhpcy5jaGVja1R5cGUodCk7XG4gICAgICAgIHJldHVybiBzbGViRGVjb2RlKGIpO1xuICAgIH1cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuICdpbnQnO1xuICAgIH1cbiAgICB2YWx1ZVRvU3RyaW5nKHgpIHtcbiAgICAgICAgcmV0dXJuIHgudG9TdHJpbmcoKTtcbiAgICB9XG59XG4vKipcbiAqIFJlcHJlc2VudHMgYW4gSURMIE5hdFxuICovXG5leHBvcnQgY2xhc3MgTmF0Q2xhc3MgZXh0ZW5kcyBQcmltaXRpdmVUeXBlIHtcbiAgICBnZXQgdHlwZU5hbWUoKSB7XG4gICAgICAgIHJldHVybiBJZGxUeXBlTmFtZS5OYXRDbGFzcztcbiAgICB9XG4gICAgc3RhdGljIFtTeW1ib2wuaGFzSW5zdGFuY2VdKGluc3RhbmNlKSB7XG4gICAgICAgIHJldHVybiBpbnN0YW5jZS50eXBlTmFtZSA9PT0gSWRsVHlwZU5hbWUuTmF0Q2xhc3M7XG4gICAgfVxuICAgIGFjY2VwdCh2LCBkKSB7XG4gICAgICAgIHJldHVybiB2LnZpc2l0TmF0KHRoaXMsIGQpO1xuICAgIH1cbiAgICBjb3ZhcmlhbnQoeCkge1xuICAgICAgICAvLyBXZSBhbGxvdyBlbmNvZGluZyBvZiBKYXZhU2NyaXB0IHBsYWluIG51bWJlcnMuXG4gICAgICAgIC8vIEJ1dCB3ZSB3aWxsIGFsd2F5cyBkZWNvZGUgdG8gYmlnaW50LlxuICAgICAgICBpZiAoKHR5cGVvZiB4ID09PSAnYmlnaW50JyAmJiB4ID49IEJpZ0ludCgwKSkgfHwgKE51bWJlci5pc0ludGVnZXIoeCkgJiYgeCA+PSAwKSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgJHt0aGlzLmRpc3BsYXkoKX0gYXJndW1lbnQ6ICR7dG9SZWFkYWJsZVN0cmluZyh4KX1gKTtcbiAgICB9XG4gICAgZW5jb2RlVmFsdWUoeCkge1xuICAgICAgICByZXR1cm4gbGViRW5jb2RlKHgpO1xuICAgIH1cbiAgICBlbmNvZGVUeXBlKCkge1xuICAgICAgICByZXR1cm4gc2xlYkVuY29kZShJRExUeXBlSWRzLk5hdCk7XG4gICAgfVxuICAgIGRlY29kZVZhbHVlKGIsIHQpIHtcbiAgICAgICAgdGhpcy5jaGVja1R5cGUodCk7XG4gICAgICAgIHJldHVybiBsZWJEZWNvZGUoYik7XG4gICAgfVxuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gJ25hdCc7XG4gICAgfVxuICAgIHZhbHVlVG9TdHJpbmcoeCkge1xuICAgICAgICByZXR1cm4geC50b1N0cmluZygpO1xuICAgIH1cbn1cbi8qKlxuICogUmVwcmVzZW50cyBhbiBJREwgRmxvYXRcbiAqL1xuZXhwb3J0IGNsYXNzIEZsb2F0Q2xhc3MgZXh0ZW5kcyBQcmltaXRpdmVUeXBlIHtcbiAgICBnZXQgdHlwZU5hbWUoKSB7XG4gICAgICAgIHJldHVybiBJZGxUeXBlTmFtZS5GbG9hdENsYXNzO1xuICAgIH1cbiAgICBzdGF0aWMgW1N5bWJvbC5oYXNJbnN0YW5jZV0oaW5zdGFuY2UpIHtcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlLnR5cGVOYW1lID09PSBJZGxUeXBlTmFtZS5GbG9hdENsYXNzO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihfYml0cykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl9iaXRzID0gX2JpdHM7XG4gICAgICAgIGlmIChfYml0cyAhPT0gMzIgJiYgX2JpdHMgIT09IDY0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBhIHZhbGlkIGZsb2F0IHR5cGUnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhY2NlcHQodiwgZCkge1xuICAgICAgICByZXR1cm4gdi52aXNpdEZsb2F0KHRoaXMsIGQpO1xuICAgIH1cbiAgICBjb3ZhcmlhbnQoeCkge1xuICAgICAgICBpZiAodHlwZW9mIHggPT09ICdudW1iZXInIHx8IHggaW5zdGFuY2VvZiBOdW1iZXIpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkICR7dGhpcy5kaXNwbGF5KCl9IGFyZ3VtZW50OiAke3RvUmVhZGFibGVTdHJpbmcoeCl9YCk7XG4gICAgfVxuICAgIGVuY29kZVZhbHVlKHgpIHtcbiAgICAgICAgY29uc3QgYnVmID0gbmV3IEFycmF5QnVmZmVyKHRoaXMuX2JpdHMgLyA4KTtcbiAgICAgICAgY29uc3QgdmlldyA9IG5ldyBEYXRhVmlldyhidWYpO1xuICAgICAgICBpZiAodGhpcy5fYml0cyA9PT0gMzIpIHtcbiAgICAgICAgICAgIHZpZXcuc2V0RmxvYXQzMigwLCB4LCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZpZXcuc2V0RmxvYXQ2NCgwLCB4LCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnVmKTtcbiAgICB9XG4gICAgZW5jb2RlVHlwZSgpIHtcbiAgICAgICAgY29uc3Qgb3Bjb2RlID0gdGhpcy5fYml0cyA9PT0gMzIgPyBJRExUeXBlSWRzLkZsb2F0MzIgOiBJRExUeXBlSWRzLkZsb2F0NjQ7XG4gICAgICAgIHJldHVybiBzbGViRW5jb2RlKG9wY29kZSk7XG4gICAgfVxuICAgIGRlY29kZVZhbHVlKGIsIHQpIHtcbiAgICAgICAgdGhpcy5jaGVja1R5cGUodCk7XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gc2FmZVJlYWQoYiwgdGhpcy5fYml0cyAvIDgpO1xuICAgICAgICBjb25zdCB2aWV3ID0gdWludDhUb0RhdGFWaWV3KGJ5dGVzKTtcbiAgICAgICAgaWYgKHRoaXMuX2JpdHMgPT09IDMyKSB7XG4gICAgICAgICAgICByZXR1cm4gdmlldy5nZXRGbG9hdDMyKDAsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHZpZXcuZ2V0RmxvYXQ2NCgwLCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuICdmbG9hdCcgKyB0aGlzLl9iaXRzO1xuICAgIH1cbiAgICB2YWx1ZVRvU3RyaW5nKHgpIHtcbiAgICAgICAgcmV0dXJuIHgudG9TdHJpbmcoKTtcbiAgICB9XG59XG4vKipcbiAqIFJlcHJlc2VudHMgYW4gSURMIGZpeGVkLXdpZHRoIEludChuKVxuICovXG5leHBvcnQgY2xhc3MgRml4ZWRJbnRDbGFzcyBleHRlbmRzIFByaW1pdGl2ZVR5cGUge1xuICAgIGdldCB0eXBlTmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIElkbFR5cGVOYW1lLkZpeGVkSW50Q2xhc3M7XG4gICAgfVxuICAgIHN0YXRpYyBbU3ltYm9sLmhhc0luc3RhbmNlXShpbnN0YW5jZSkge1xuICAgICAgICByZXR1cm4gaW5zdGFuY2UudHlwZU5hbWUgPT09IElkbFR5cGVOYW1lLkZpeGVkSW50Q2xhc3M7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKF9iaXRzKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX2JpdHMgPSBfYml0cztcbiAgICB9XG4gICAgYWNjZXB0KHYsIGQpIHtcbiAgICAgICAgcmV0dXJuIHYudmlzaXRGaXhlZEludCh0aGlzLCBkKTtcbiAgICB9XG4gICAgY292YXJpYW50KHgpIHtcbiAgICAgICAgY29uc3QgbWluID0gaWV4cDIodGhpcy5fYml0cyAtIDEpICogQmlnSW50KC0xKTtcbiAgICAgICAgY29uc3QgbWF4ID0gaWV4cDIodGhpcy5fYml0cyAtIDEpIC0gQmlnSW50KDEpO1xuICAgICAgICBsZXQgb2sgPSBmYWxzZTtcbiAgICAgICAgaWYgKHR5cGVvZiB4ID09PSAnYmlnaW50Jykge1xuICAgICAgICAgICAgb2sgPSB4ID49IG1pbiAmJiB4IDw9IG1heDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChOdW1iZXIuaXNJbnRlZ2VyKHgpKSB7XG4gICAgICAgICAgICBjb25zdCB2ID0gQmlnSW50KHgpO1xuICAgICAgICAgICAgb2sgPSB2ID49IG1pbiAmJiB2IDw9IG1heDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9rID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9rKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCAke3RoaXMuZGlzcGxheSgpfSBhcmd1bWVudDogJHt0b1JlYWRhYmxlU3RyaW5nKHgpfWApO1xuICAgIH1cbiAgICBlbmNvZGVWYWx1ZSh4KSB7XG4gICAgICAgIHJldHVybiB3cml0ZUludExFKHgsIHRoaXMuX2JpdHMgLyA4KTtcbiAgICB9XG4gICAgZW5jb2RlVHlwZSgpIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gTWF0aC5sb2cyKHRoaXMuX2JpdHMpIC0gMztcbiAgICAgICAgcmV0dXJuIHNsZWJFbmNvZGUoLTkgLSBvZmZzZXQpO1xuICAgIH1cbiAgICBkZWNvZGVWYWx1ZShiLCB0KSB7XG4gICAgICAgIHRoaXMuY2hlY2tUeXBlKHQpO1xuICAgICAgICBjb25zdCBudW0gPSByZWFkSW50TEUoYiwgdGhpcy5fYml0cyAvIDgpO1xuICAgICAgICBpZiAodGhpcy5fYml0cyA8PSAzMikge1xuICAgICAgICAgICAgcmV0dXJuIE51bWJlcihudW0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIGBpbnQke3RoaXMuX2JpdHN9YDtcbiAgICB9XG4gICAgdmFsdWVUb1N0cmluZyh4KSB7XG4gICAgICAgIHJldHVybiB4LnRvU3RyaW5nKCk7XG4gICAgfVxufVxuLyoqXG4gKiBSZXByZXNlbnRzIGFuIElETCBmaXhlZC13aWR0aCBOYXQobilcbiAqL1xuZXhwb3J0IGNsYXNzIEZpeGVkTmF0Q2xhc3MgZXh0ZW5kcyBQcmltaXRpdmVUeXBlIHtcbiAgICBnZXQgdHlwZU5hbWUoKSB7XG4gICAgICAgIHJldHVybiBJZGxUeXBlTmFtZS5GaXhlZE5hdENsYXNzO1xuICAgIH1cbiAgICBzdGF0aWMgW1N5bWJvbC5oYXNJbnN0YW5jZV0oaW5zdGFuY2UpIHtcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlLnR5cGVOYW1lID09PSBJZGxUeXBlTmFtZS5GaXhlZE5hdENsYXNzO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihfYml0cykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl9iaXRzID0gX2JpdHM7XG4gICAgfVxuICAgIGFjY2VwdCh2LCBkKSB7XG4gICAgICAgIHJldHVybiB2LnZpc2l0Rml4ZWROYXQodGhpcywgZCk7XG4gICAgfVxuICAgIGNvdmFyaWFudCh4KSB7XG4gICAgICAgIGNvbnN0IG1heCA9IGlleHAyKHRoaXMuX2JpdHMpO1xuICAgICAgICBsZXQgb2sgPSBmYWxzZTtcbiAgICAgICAgaWYgKHR5cGVvZiB4ID09PSAnYmlnaW50JyAmJiB4ID49IEJpZ0ludCgwKSkge1xuICAgICAgICAgICAgb2sgPSB4IDwgbWF4O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKE51bWJlci5pc0ludGVnZXIoeCkgJiYgeCA+PSAwKSB7XG4gICAgICAgICAgICBjb25zdCB2ID0gQmlnSW50KHgpO1xuICAgICAgICAgICAgb2sgPSB2IDwgbWF4O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb2sgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2spXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkICR7dGhpcy5kaXNwbGF5KCl9IGFyZ3VtZW50OiAke3RvUmVhZGFibGVTdHJpbmcoeCl9YCk7XG4gICAgfVxuICAgIGVuY29kZVZhbHVlKHgpIHtcbiAgICAgICAgcmV0dXJuIHdyaXRlVUludExFKHgsIHRoaXMuX2JpdHMgLyA4KTtcbiAgICB9XG4gICAgZW5jb2RlVHlwZSgpIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gTWF0aC5sb2cyKHRoaXMuX2JpdHMpIC0gMztcbiAgICAgICAgcmV0dXJuIHNsZWJFbmNvZGUoLTUgLSBvZmZzZXQpO1xuICAgIH1cbiAgICBkZWNvZGVWYWx1ZShiLCB0KSB7XG4gICAgICAgIHRoaXMuY2hlY2tUeXBlKHQpO1xuICAgICAgICBjb25zdCBudW0gPSByZWFkVUludExFKGIsIHRoaXMuX2JpdHMgLyA4KTtcbiAgICAgICAgaWYgKHRoaXMuX2JpdHMgPD0gMzIpIHtcbiAgICAgICAgICAgIHJldHVybiBOdW1iZXIobnVtKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudW07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiBgbmF0JHt0aGlzLl9iaXRzfWA7XG4gICAgfVxuICAgIHZhbHVlVG9TdHJpbmcoeCkge1xuICAgICAgICByZXR1cm4geC50b1N0cmluZygpO1xuICAgIH1cbn1cbi8qKlxuICogUmVwcmVzZW50cyBhbiBJREwgQXJyYXlcbiAqXG4gKiBBcnJheXMgb2YgZml4ZWQtc2l6ZWQgbmF0L2ludCB0eXBlIChlLmcuIG5hdDgpLCBhcmUgZW5jb2RlZCBmcm9tIGFuZCBkZWNvZGVkIHRvIFR5cGVkQXJyYXlzIChlLmcuIFVpbnQ4QXJyYXkpLlxuICogQXJyYXlzIG9mIGZsb2F0IG9yIG90aGVyIG5vbi1wcmltaXRpdmUgdHlwZXMgYXJlIGVuY29kZWQvZGVjb2RlZCBhcyB1bnR5cGVkIGFycmF5IGluIEphdmFzY3JpcHQuXG4gKiBAcGFyYW0ge1R5cGV9IHRcbiAqL1xuZXhwb3J0IGNsYXNzIFZlY0NsYXNzIGV4dGVuZHMgQ29uc3RydWN0VHlwZSB7XG4gICAgZ2V0IHR5cGVOYW1lKCkge1xuICAgICAgICByZXR1cm4gSWRsVHlwZU5hbWUuVmVjQ2xhc3M7XG4gICAgfVxuICAgIHN0YXRpYyBbU3ltYm9sLmhhc0luc3RhbmNlXShpbnN0YW5jZSkge1xuICAgICAgICByZXR1cm4gaW5zdGFuY2UudHlwZU5hbWUgPT09IElkbFR5cGVOYW1lLlZlY0NsYXNzO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihfdHlwZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl90eXBlID0gX3R5cGU7XG4gICAgICAgIC8vIElmIHRydWUsIHRoaXMgdmVjdG9yIGlzIHJlYWxseSBhIGJsb2IgYW5kIHdlIGNhbiBqdXN0IHVzZSBtZW1jcHkuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIE5PVEU6XG4gICAgICAgIC8vIFdpdGggc3VwcG9ydCBvZiBlbmNvZGluZy9kZW5jb2Rpbmcgb2YgVHlwZWRBcnJheXMsIHRoaXMgb3B0aW1pemF0aW9uIGlzXG4gICAgICAgIC8vIG9ubHkgdXNlZCB3aGVuIHBsYWluIGFycmF5IG9mIGJ5dGVzIGFyZSBwYXNzZWQgYXMgZW5jb2RpbmcgaW5wdXQgaW4gb3JkZXJcbiAgICAgICAgLy8gdG8gYmUgYmFja3dhcmQgY29tcGF0aWJsZS5cbiAgICAgICAgdGhpcy5fYmxvYk9wdGltaXphdGlvbiA9IGZhbHNlO1xuICAgICAgICBpZiAoX3R5cGUgaW5zdGFuY2VvZiBGaXhlZE5hdENsYXNzICYmIF90eXBlLl9iaXRzID09PSA4KSB7XG4gICAgICAgICAgICB0aGlzLl9ibG9iT3B0aW1pemF0aW9uID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhY2NlcHQodiwgZCkge1xuICAgICAgICByZXR1cm4gdi52aXNpdFZlYyh0aGlzLCB0aGlzLl90eXBlLCBkKTtcbiAgICB9XG4gICAgY292YXJpYW50KHgpIHtcbiAgICAgICAgLy8gU3BlY2lhbCBjYXNlIGZvciBBcnJheUJ1ZmZlclxuICAgICAgICBjb25zdCBiaXRzID0gdGhpcy5fdHlwZSBpbnN0YW5jZW9mIEZpeGVkTmF0Q2xhc3NcbiAgICAgICAgICAgID8gdGhpcy5fdHlwZS5fYml0c1xuICAgICAgICAgICAgOiB0aGlzLl90eXBlIGluc3RhbmNlb2YgRml4ZWRJbnRDbGFzc1xuICAgICAgICAgICAgICAgID8gdGhpcy5fdHlwZS5fYml0c1xuICAgICAgICAgICAgICAgIDogMDtcbiAgICAgICAgaWYgKChBcnJheUJ1ZmZlci5pc1ZpZXcoeCkgJiYgYml0cyA9PSB4LkJZVEVTX1BFUl9FTEVNRU5UICogOCkgfHxcbiAgICAgICAgICAgIChBcnJheS5pc0FycmF5KHgpICYmXG4gICAgICAgICAgICAgICAgeC5ldmVyeSgodiwgaWR4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdHlwZS5jb3ZhcmlhbnQodik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCAke3RoaXMuZGlzcGxheSgpfSBhcmd1bWVudDogXFxuXFxuaW5kZXggJHtpZHh9IC0+ICR7ZS5tZXNzYWdlfWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkpKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCAke3RoaXMuZGlzcGxheSgpfSBhcmd1bWVudDogJHt0b1JlYWRhYmxlU3RyaW5nKHgpfWApO1xuICAgIH1cbiAgICBlbmNvZGVWYWx1ZSh4KSB7XG4gICAgICAgIGNvbnN0IGxlbiA9IGxlYkVuY29kZSh4Lmxlbmd0aCk7XG4gICAgICAgIGlmICh0aGlzLl9ibG9iT3B0aW1pemF0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gY29uY2F0KGxlbiwgbmV3IFVpbnQ4QXJyYXkoeCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoeCkpIHtcbiAgICAgICAgICAgIC8vIEhhbmRsZSBUeXBlZEFycmF5cyB3aXRoIGVuZGlhbm5lc3MgY29uY2VybnNcbiAgICAgICAgICAgIGlmICh4IGluc3RhbmNlb2YgSW50MTZBcnJheSB8fCB4IGluc3RhbmNlb2YgVWludDE2QXJyYXkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBidWZmZXIgPSBuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKHgubGVuZ3RoICogMikpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgeC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoeCBpbnN0YW5jZW9mIEludDE2QXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci5zZXRJbnQxNihpICogMiwgeFtpXSwgdHJ1ZSk7IC8vIHRydWUgPSBsaXR0bGUtZW5kaWFuXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIuc2V0VWludDE2KGkgKiAyLCB4W2ldLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY29uY2F0KGxlbiwgbmV3IFVpbnQ4QXJyYXkoYnVmZmVyLmJ1ZmZlcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoeCBpbnN0YW5jZW9mIEludDMyQXJyYXkgfHwgeCBpbnN0YW5jZW9mIFVpbnQzMkFycmF5KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYnVmZmVyID0gbmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcih4Lmxlbmd0aCAqIDQpKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHggaW5zdGFuY2VvZiBJbnQzMkFycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIuc2V0SW50MzIoaSAqIDQsIHhbaV0sIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLnNldFVpbnQzMihpICogNCwgeFtpXSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbmNhdChsZW4sIG5ldyBVaW50OEFycmF5KGJ1ZmZlci5idWZmZXIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHggaW5zdGFuY2VvZiBCaWdJbnQ2NEFycmF5IHx8IHggaW5zdGFuY2VvZiBCaWdVaW50NjRBcnJheSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoeC5sZW5ndGggKiA4KSk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB4Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh4IGluc3RhbmNlb2YgQmlnSW50NjRBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLnNldEJpZ0ludDY0KGkgKiA4LCB4W2ldLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci5zZXRCaWdVaW50NjQoaSAqIDgsIHhbaV0sIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjb25jYXQobGVuLCBuZXcgVWludDhBcnJheShidWZmZXIuYnVmZmVyKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBGb3IgVWludDhBcnJheSwgSW50OEFycmF5LCBldGMuIHRoYXQgZG9uJ3QgaGF2ZSBlbmRpYW5uZXNzIGNvbmNlcm5zXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbmNhdChsZW4sIG5ldyBVaW50OEFycmF5KHguYnVmZmVyLCB4LmJ5dGVPZmZzZXQsIHguYnl0ZUxlbmd0aCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJ1ZiA9IG5ldyBQaXBlKG5ldyBVaW50OEFycmF5KGxlbi5ieXRlTGVuZ3RoICsgeC5sZW5ndGgpLCAwKTtcbiAgICAgICAgYnVmLndyaXRlKGxlbik7XG4gICAgICAgIGZvciAoY29uc3QgZCBvZiB4KSB7XG4gICAgICAgICAgICBjb25zdCBlbmNvZGVkID0gdGhpcy5fdHlwZS5lbmNvZGVWYWx1ZShkKTtcbiAgICAgICAgICAgIGJ1Zi53cml0ZShuZXcgVWludDhBcnJheShlbmNvZGVkKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ1Zi5idWZmZXI7XG4gICAgfVxuICAgIF9idWlsZFR5cGVUYWJsZUltcGwodHlwZVRhYmxlKSB7XG4gICAgICAgIHRoaXMuX3R5cGUuYnVpbGRUeXBlVGFibGUodHlwZVRhYmxlKTtcbiAgICAgICAgY29uc3Qgb3BDb2RlID0gc2xlYkVuY29kZShJRExUeXBlSWRzLlZlY3Rvcik7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IHRoaXMuX3R5cGUuZW5jb2RlVHlwZSh0eXBlVGFibGUpO1xuICAgICAgICB0eXBlVGFibGUuYWRkKHRoaXMsIGNvbmNhdChvcENvZGUsIGJ1ZmZlcikpO1xuICAgIH1cbiAgICBkZWNvZGVWYWx1ZShiLCB0KSB7XG4gICAgICAgIGNvbnN0IHZlYyA9IHRoaXMuY2hlY2tUeXBlKHQpO1xuICAgICAgICBpZiAoISh2ZWMgaW5zdGFuY2VvZiBWZWNDbGFzcykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGEgdmVjdG9yIHR5cGUnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsZW4gPSBOdW1iZXIobGViRGVjb2RlKGIpKTtcbiAgICAgICAgaWYgKHRoaXMuX3R5cGUgaW5zdGFuY2VvZiBGaXhlZE5hdENsYXNzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fdHlwZS5fYml0cyA9PSA4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGIucmVhZChsZW4pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl90eXBlLl9iaXRzID09IDE2KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYnl0ZXMgPSBiLnJlYWQobGVuICogMik7XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgd2UgbmVlZCB0byBzd2FwIGJ5dGVzIGZvciBlbmRpYW5uZXNzXG4gICAgICAgICAgICAgICAgY29uc3QgdTE2ID0gbmV3IFVpbnQxNkFycmF5KGJ5dGVzLmJ1ZmZlciwgYnl0ZXMuYnl0ZU9mZnNldCwgbGVuKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdTE2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX3R5cGUuX2JpdHMgPT0gMzIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBieXRlcyA9IGIucmVhZChsZW4gKiA0KTtcbiAgICAgICAgICAgICAgICBjb25zdCB1MzIgPSBuZXcgVWludDMyQXJyYXkoYnl0ZXMuYnVmZmVyLCBieXRlcy5ieXRlT2Zmc2V0LCBsZW4pO1xuICAgICAgICAgICAgICAgIHJldHVybiB1MzI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fdHlwZS5fYml0cyA9PSA2NCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQmlnVWludDY0QXJyYXkoYi5yZWFkKGxlbiAqIDgpLmJ1ZmZlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3R5cGUgaW5zdGFuY2VvZiBGaXhlZEludENsYXNzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fdHlwZS5fYml0cyA9PSA4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnQ4QXJyYXkoYi5yZWFkKGxlbikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX3R5cGUuX2JpdHMgPT0gMTYpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBieXRlcyA9IGIucmVhZChsZW4gKiAyKTtcbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgYSBEYXRhVmlldyB0byBwcm9wZXJseSBoYW5kbGUgZW5kaWFubmVzc1xuICAgICAgICAgICAgICAgIGNvbnN0IHZpZXcgPSBuZXcgRGF0YVZpZXcoYnl0ZXMuYnVmZmVyLCBieXRlcy5ieXRlT2Zmc2V0LCBieXRlcy5ieXRlTGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgcmVzdWx0IGFycmF5IHdpdGggY29ycmVjdCBlbmRpYW5uZXNzXG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IEludDE2QXJyYXkobGVuKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlYWQgZWFjaCB2YWx1ZSBhcyBsaXR0bGUtZW5kaWFuIChDYW5kaWQgd2lyZSBmb3JtYXQgaXMgbGl0dGxlLWVuZGlhbilcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2ldID0gdmlldy5nZXRJbnQxNihpICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fdHlwZS5fYml0cyA9PSAzMikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJ5dGVzID0gYi5yZWFkKGxlbiAqIDQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHZpZXcgPSBuZXcgRGF0YVZpZXcoYnl0ZXMuYnVmZmVyLCBieXRlcy5ieXRlT2Zmc2V0LCBieXRlcy5ieXRlTGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgSW50MzJBcnJheShsZW4pO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2ldID0gdmlldy5nZXRJbnQzMihpICogNCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fdHlwZS5fYml0cyA9PSA2NCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJ5dGVzID0gYi5yZWFkKGxlbiAqIDgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHZpZXcgPSBuZXcgRGF0YVZpZXcoYnl0ZXMuYnVmZmVyLCBieXRlcy5ieXRlT2Zmc2V0LCBieXRlcy5ieXRlTGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgQmlnSW50NjRBcnJheShsZW4pO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2ldID0gdmlldy5nZXRCaWdJbnQ2NChpICogOCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmV0cyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICByZXRzLnB1c2godGhpcy5fdHlwZS5kZWNvZGVWYWx1ZShiLCB2ZWMuX3R5cGUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0cztcbiAgICB9XG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiBgdmVjICR7dGhpcy5fdHlwZS5uYW1lfWA7XG4gICAgfVxuICAgIGRpc3BsYXkoKSB7XG4gICAgICAgIHJldHVybiBgdmVjICR7dGhpcy5fdHlwZS5kaXNwbGF5KCl9YDtcbiAgICB9XG4gICAgdmFsdWVUb1N0cmluZyh4KSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRzID0geC5tYXAoZSA9PiB0aGlzLl90eXBlLnZhbHVlVG9TdHJpbmcoZSkpO1xuICAgICAgICByZXR1cm4gJ3ZlYyB7JyArIGVsZW1lbnRzLmpvaW4oJzsgJykgKyAnfSc7XG4gICAgfVxufVxuLyoqXG4gKiBSZXByZXNlbnRzIGFuIElETCBPcHRpb25cbiAqIEBwYXJhbSB7VHlwZX0gdFxuICovXG5leHBvcnQgY2xhc3MgT3B0Q2xhc3MgZXh0ZW5kcyBDb25zdHJ1Y3RUeXBlIHtcbiAgICBnZXQgdHlwZU5hbWUoKSB7XG4gICAgICAgIHJldHVybiBJZGxUeXBlTmFtZS5PcHRDbGFzcztcbiAgICB9XG4gICAgc3RhdGljIFtTeW1ib2wuaGFzSW5zdGFuY2VdKGluc3RhbmNlKSB7XG4gICAgICAgIHJldHVybiBpbnN0YW5jZS50eXBlTmFtZSA9PT0gSWRsVHlwZU5hbWUuT3B0Q2xhc3M7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKF90eXBlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX3R5cGUgPSBfdHlwZTtcbiAgICB9XG4gICAgYWNjZXB0KHYsIGQpIHtcbiAgICAgICAgcmV0dXJuIHYudmlzaXRPcHQodGhpcywgdGhpcy5fdHlwZSwgZCk7XG4gICAgfVxuICAgIGNvdmFyaWFudCh4KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh4KSAmJiAoeC5sZW5ndGggPT09IDAgfHwgKHgubGVuZ3RoID09PSAxICYmIHRoaXMuX3R5cGUuY292YXJpYW50KHhbMF0pKSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCAke3RoaXMuZGlzcGxheSgpfSBhcmd1bWVudDogJHt0b1JlYWRhYmxlU3RyaW5nKHgpfSBcXG5cXG4tPiAke2UubWVzc2FnZX1gKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgJHt0aGlzLmRpc3BsYXkoKX0gYXJndW1lbnQ6ICR7dG9SZWFkYWJsZVN0cmluZyh4KX1gKTtcbiAgICB9XG4gICAgZW5jb2RlVmFsdWUoeCkge1xuICAgICAgICBpZiAoeC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbMF0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGNvbmNhdChuZXcgVWludDhBcnJheShbMV0pLCB0aGlzLl90eXBlLmVuY29kZVZhbHVlKHhbMF0pKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfYnVpbGRUeXBlVGFibGVJbXBsKHR5cGVUYWJsZSkge1xuICAgICAgICB0aGlzLl90eXBlLmJ1aWxkVHlwZVRhYmxlKHR5cGVUYWJsZSk7XG4gICAgICAgIGNvbnN0IG9wQ29kZSA9IHNsZWJFbmNvZGUoSURMVHlwZUlkcy5PcHQpO1xuICAgICAgICBjb25zdCBidWZmZXIgPSB0aGlzLl90eXBlLmVuY29kZVR5cGUodHlwZVRhYmxlKTtcbiAgICAgICAgdHlwZVRhYmxlLmFkZCh0aGlzLCBjb25jYXQob3BDb2RlLCBidWZmZXIpKTtcbiAgICB9XG4gICAgZGVjb2RlVmFsdWUoYiwgdCkge1xuICAgICAgICBpZiAodCBpbnN0YW5jZW9mIE51bGxDbGFzcykge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0IGluc3RhbmNlb2YgUmVzZXJ2ZWRDbGFzcykge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGxldCB3aXJlVHlwZSA9IHQ7XG4gICAgICAgIC8vIHVuZm9sZCB3aXJlVHlwZSwgaWYgbmVlZGVkXG4gICAgICAgIGlmICh0IGluc3RhbmNlb2YgUmVjQ2xhc3MpIHtcbiAgICAgICAgICAgIGNvbnN0IHR5ID0gdC5nZXRUeXBlKCk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHR5ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndHlwZSBtaXNtYXRjaCB3aXRoIHVuaW5pdGlhbGl6ZWQgdHlwZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHdpcmVUeXBlID0gdHk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdpcmVUeXBlIGluc3RhbmNlb2YgT3B0Q2xhc3MpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoc2FmZVJlYWRVaW50OChiKSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgICAgIGNhc2UgMToge1xuICAgICAgICAgICAgICAgICAgICAvLyBTYXZlIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBQaXBlIGBiYCB0byBhbGxvdyByb2xsYmFjayBpbiBjYXNlIG9mIGFuIGVycm9yXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoZWNrcG9pbnQgPSBiLnNhdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEF0dGVtcHQgdG8gZGVjb2RlIGEgdmFsdWUgdXNpbmcgdGhlIGBfdHlwZWAgb2YgdGhlIGN1cnJlbnQgaW5zdGFuY2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHYgPSB0aGlzLl90eXBlLmRlY29kZVZhbHVlKGIsIHdpcmVUeXBlLl90eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbdl07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIGFuIGVycm9yIG9jY3VycyBkdXJpbmcgZGVjb2RpbmcsIHJlc3RvcmUgdGhlIFBpcGUgYGJgIHRvIGl0cyBwcmV2aW91cyBzdGF0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgYi5yZXN0b3JlKGNoZWNrcG9pbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2tpcCB0aGUgdmFsdWUgYXQgdGhlIGN1cnJlbnQgd2lyZSB0eXBlIHRvIGFkdmFuY2UgdGhlIFBpcGUgYGJgIHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICB3aXJlVHlwZS5fdHlwZS5kZWNvZGVWYWx1ZShiLCB3aXJlVHlwZS5fdHlwZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXR1cm4gYW4gZW1wdHkgYXJyYXkgdG8gaW5kaWNhdGUgYSBgbm9uZWAgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBhbiBvcHRpb24gdmFsdWUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChcbiAgICAgICAgLy8gdGhpcyBjaGVjayBjb3JyZXNwb25kcyB0byBgbm90IChudWxsIDw6IDx0PilgIGluIHRoZSBzcGVjXG4gICAgICAgIHRoaXMuX3R5cGUgaW5zdGFuY2VvZiBOdWxsQ2xhc3MgfHxcbiAgICAgICAgICAgIHRoaXMuX3R5cGUgaW5zdGFuY2VvZiBPcHRDbGFzcyB8fFxuICAgICAgICAgICAgdGhpcy5fdHlwZSBpbnN0YW5jZW9mIFJlc2VydmVkQ2xhc3MpIHtcbiAgICAgICAgICAgIC8vIG51bGwgPDogPHQ+IDpcbiAgICAgICAgICAgIC8vIHNraXAgdmFsdWUgYXQgd2lyZSB0eXBlICh0byBhZHZhbmNlIGIpIGFuZCByZXR1cm4gXCJudWxsXCIsIGkuZS4gW11cbiAgICAgICAgICAgIHdpcmVUeXBlLmRlY29kZVZhbHVlKGIsIHdpcmVUeXBlKTtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIG5vdCAobnVsbCA8OiB0KSA6XG4gICAgICAgICAgICAvLyB0cnkgY29uc3RpdHVlbnQgdHlwZVxuICAgICAgICAgICAgY29uc3QgY2hlY2twb2ludCA9IGIuc2F2ZSgpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCB2ID0gdGhpcy5fdHlwZS5kZWNvZGVWYWx1ZShiLCB0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gW3ZdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvLyBkZWNvZGluZyBmYWlsZWQsIGJ1dCB0aGlzIGlzIG9wdCwgc28gcmV0dXJuIFwibnVsbFwiLCBpLmUuIFtdXG4gICAgICAgICAgICAgICAgYi5yZXN0b3JlKGNoZWNrcG9pbnQpO1xuICAgICAgICAgICAgICAgIC8vIHNraXAgdmFsdWUgYXQgd2lyZSB0eXBlICh0byBhZHZhbmNlIGIpXG4gICAgICAgICAgICAgICAgd2lyZVR5cGUuZGVjb2RlVmFsdWUoYiwgdCk7XG4gICAgICAgICAgICAgICAgLy8gcmV0dXJuIFwibnVsbFwiXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gYG9wdCAke3RoaXMuX3R5cGUubmFtZX1gO1xuICAgIH1cbiAgICBkaXNwbGF5KCkge1xuICAgICAgICByZXR1cm4gYG9wdCAke3RoaXMuX3R5cGUuZGlzcGxheSgpfWA7XG4gICAgfVxuICAgIHZhbHVlVG9TdHJpbmcoeCkge1xuICAgICAgICBpZiAoeC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAnbnVsbCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gYG9wdCAke3RoaXMuX3R5cGUudmFsdWVUb1N0cmluZyh4WzBdKX1gO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBSZXByZXNlbnRzIGFuIElETCBSZWNvcmRcbiAqIEBwYXJhbSB7b2JqZWN0fSBbZmllbGRzXSAtIG1hcHBpbmcgb2YgZnVuY3Rpb24gbmFtZSB0byBUeXBlXG4gKi9cbmV4cG9ydCBjbGFzcyBSZWNvcmRDbGFzcyBleHRlbmRzIENvbnN0cnVjdFR5cGUge1xuICAgIGdldCB0eXBlTmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIElkbFR5cGVOYW1lLlJlY29yZENsYXNzO1xuICAgIH1cbiAgICBzdGF0aWMgW1N5bWJvbC5oYXNJbnN0YW5jZV0oaW5zdGFuY2UpIHtcbiAgICAgICAgLy8gVHVwbGVDbGFzcyBleHRlbmRzIFJlY29yZENsYXNzLCBzbyB3ZSBuZWVkIHRvIGNoZWNrIGJvdGggaGVyZVxuICAgICAgICByZXR1cm4gKGluc3RhbmNlLnR5cGVOYW1lID09PSBJZGxUeXBlTmFtZS5SZWNvcmRDbGFzcyB8fCBpbnN0YW5jZS50eXBlTmFtZSA9PT0gSWRsVHlwZU5hbWUuVHVwbGVDbGFzcyk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGZpZWxkcyA9IHt9KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX2ZpZWxkcyA9IE9iamVjdC5lbnRyaWVzKGZpZWxkcykuc29ydCgoYSwgYikgPT4gaWRsTGFiZWxUb0lkKGFbMF0pIC0gaWRsTGFiZWxUb0lkKGJbMF0pKTtcbiAgICB9XG4gICAgYWNjZXB0KHYsIGQpIHtcbiAgICAgICAgcmV0dXJuIHYudmlzaXRSZWNvcmQodGhpcywgdGhpcy5fZmllbGRzLCBkKTtcbiAgICB9XG4gICAgdHJ5QXNUdXBsZSgpIHtcbiAgICAgICAgY29uc3QgcmVzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fZmllbGRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBba2V5LCB0eXBlXSA9IHRoaXMuX2ZpZWxkc1tpXTtcbiAgICAgICAgICAgIGlmIChrZXkgIT09IGBfJHtpfV9gKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXMucHVzaCh0eXBlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBjb3ZhcmlhbnQoeCkge1xuICAgICAgICBpZiAodHlwZW9mIHggPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICB0aGlzLl9maWVsZHMuZXZlcnkoKFtrLCB0XSkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICAgICAgICAgIGlmICgheC5oYXNPd25Qcm9wZXJ0eShrKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFJlY29yZCBpcyBtaXNzaW5nIGtleSBcIiR7a31cIi5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHQuY292YXJpYW50KHhba10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgJHt0aGlzLmRpc3BsYXkoKX0gYXJndW1lbnQ6IFxcblxcbmZpZWxkICR7a30gLT4gJHtlLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkICR7dGhpcy5kaXNwbGF5KCl9IGFyZ3VtZW50OiAke3RvUmVhZGFibGVTdHJpbmcoeCl9YCk7XG4gICAgfVxuICAgIGVuY29kZVZhbHVlKHgpIHtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gdGhpcy5fZmllbGRzLm1hcCgoW2tleV0pID0+IHhba2V5XSk7XG4gICAgICAgIGNvbnN0IGJ1ZnMgPSB6aXBXaXRoKHRoaXMuX2ZpZWxkcywgdmFsdWVzLCAoWywgY10sIGQpID0+IGMuZW5jb2RlVmFsdWUoZCkpO1xuICAgICAgICByZXR1cm4gY29uY2F0KC4uLmJ1ZnMpO1xuICAgIH1cbiAgICBfYnVpbGRUeXBlVGFibGVJbXBsKFQpIHtcbiAgICAgICAgdGhpcy5fZmllbGRzLmZvckVhY2goKFtfLCB2YWx1ZV0pID0+IHZhbHVlLmJ1aWxkVHlwZVRhYmxlKFQpKTtcbiAgICAgICAgY29uc3Qgb3BDb2RlID0gc2xlYkVuY29kZShJRExUeXBlSWRzLlJlY29yZCk7XG4gICAgICAgIGNvbnN0IGxlbiA9IGxlYkVuY29kZSh0aGlzLl9maWVsZHMubGVuZ3RoKTtcbiAgICAgICAgY29uc3QgZmllbGRzID0gdGhpcy5fZmllbGRzLm1hcCgoW2tleSwgdmFsdWVdKSA9PiBjb25jYXQobGViRW5jb2RlKGlkbExhYmVsVG9JZChrZXkpKSwgdmFsdWUuZW5jb2RlVHlwZShUKSkpO1xuICAgICAgICBULmFkZCh0aGlzLCBjb25jYXQob3BDb2RlLCBsZW4sIGNvbmNhdCguLi5maWVsZHMpKSk7XG4gICAgfVxuICAgIGRlY29kZVZhbHVlKGIsIHQpIHtcbiAgICAgICAgY29uc3QgcmVjb3JkID0gdGhpcy5jaGVja1R5cGUodCk7XG4gICAgICAgIGlmICghKHJlY29yZCBpbnN0YW5jZW9mIFJlY29yZENsYXNzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgYSByZWNvcmQgdHlwZScpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHggPSB7fTtcbiAgICAgICAgbGV0IGV4cGVjdGVkUmVjb3JkSWR4ID0gMDtcbiAgICAgICAgbGV0IGFjdHVhbFJlY29yZElkeCA9IDA7XG4gICAgICAgIHdoaWxlIChhY3R1YWxSZWNvcmRJZHggPCByZWNvcmQuX2ZpZWxkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IFtoYXNoLCB0eXBlXSA9IHJlY29yZC5fZmllbGRzW2FjdHVhbFJlY29yZElkeF07XG4gICAgICAgICAgICBpZiAoZXhwZWN0ZWRSZWNvcmRJZHggPj0gdGhpcy5fZmllbGRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIC8vIHNraXAgdW5leHBlY3RlZCBsZWZ0IG92ZXIgZmllbGRzIHByZXNlbnQgb24gdGhlIHdpcmVcbiAgICAgICAgICAgICAgICB0eXBlLmRlY29kZVZhbHVlKGIsIHR5cGUpO1xuICAgICAgICAgICAgICAgIGFjdHVhbFJlY29yZElkeCsrO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgW2V4cGVjdEtleSwgZXhwZWN0VHlwZV0gPSB0aGlzLl9maWVsZHNbZXhwZWN0ZWRSZWNvcmRJZHhdO1xuICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWRJZCA9IGlkbExhYmVsVG9JZCh0aGlzLl9maWVsZHNbZXhwZWN0ZWRSZWNvcmRJZHhdWzBdKTtcbiAgICAgICAgICAgIGNvbnN0IGFjdHVhbElkID0gaWRsTGFiZWxUb0lkKGhhc2gpO1xuICAgICAgICAgICAgaWYgKGV4cGVjdGVkSWQgPT09IGFjdHVhbElkKSB7XG4gICAgICAgICAgICAgICAgLy8gdGhlIGN1cnJlbnQgZmllbGQgb24gdGhlIHdpcmUgbWF0Y2hlcyB0aGUgZXhwZWN0ZWQgZmllbGRcbiAgICAgICAgICAgICAgICB4W2V4cGVjdEtleV0gPSBleHBlY3RUeXBlLmRlY29kZVZhbHVlKGIsIHR5cGUpO1xuICAgICAgICAgICAgICAgIGV4cGVjdGVkUmVjb3JkSWR4Kys7XG4gICAgICAgICAgICAgICAgYWN0dWFsUmVjb3JkSWR4Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhY3R1YWxJZCA+IGV4cGVjdGVkSWQpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgZXhwZWN0ZWQgZmllbGQgZG9lcyBub3QgZXhpc3Qgb24gdGhlIHdpcmVcbiAgICAgICAgICAgICAgICBpZiAoZXhwZWN0VHlwZSBpbnN0YW5jZW9mIE9wdENsYXNzIHx8IGV4cGVjdFR5cGUgaW5zdGFuY2VvZiBSZXNlcnZlZENsYXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIHhbZXhwZWN0S2V5XSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBleHBlY3RlZFJlY29yZElkeCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCByZXF1aXJlZCBmaWVsZCAnICsgZXhwZWN0S2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgZmllbGQgb24gdGhlIHdpcmUgZG9lcyBub3QgZXhpc3QgaW4gdGhlIG91dHB1dCB0eXBlLCBzbyB3ZSBjYW4gc2tpcCBpdFxuICAgICAgICAgICAgICAgIHR5cGUuZGVjb2RlVmFsdWUoYiwgdHlwZSk7XG4gICAgICAgICAgICAgICAgYWN0dWFsUmVjb3JkSWR4Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gaW5pdGlhbGl6ZSBsZWZ0IG92ZXIgZXhwZWN0ZWQgb3B0aW9uYWwgZmllbGRzXG4gICAgICAgIGZvciAoY29uc3QgW2V4cGVjdEtleSwgZXhwZWN0VHlwZV0gb2YgdGhpcy5fZmllbGRzLnNsaWNlKGV4cGVjdGVkUmVjb3JkSWR4KSkge1xuICAgICAgICAgICAgaWYgKGV4cGVjdFR5cGUgaW5zdGFuY2VvZiBPcHRDbGFzcyB8fCBleHBlY3RUeXBlIGluc3RhbmNlb2YgUmVzZXJ2ZWRDbGFzcykge1xuICAgICAgICAgICAgICAgIC8vIFRPRE8gdGhpcyBhc3N1bWVzIG51bGwgdmFsdWUgaW4gb3B0IGlzIHJlcHJlc2VudGVkIGFzIFtdXG4gICAgICAgICAgICAgICAgeFtleHBlY3RLZXldID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIHJlcXVpcmVkIGZpZWxkICcgKyBleHBlY3RLZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB4O1xuICAgIH1cbiAgICBnZXQgZmllbGRzQXNPYmplY3QoKSB7XG4gICAgICAgIGNvbnN0IGZpZWxkcyA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IFtuYW1lLCB0eV0gb2YgdGhpcy5fZmllbGRzKSB7XG4gICAgICAgICAgICBmaWVsZHNbaWRsTGFiZWxUb0lkKG5hbWUpXSA9IHR5O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmaWVsZHM7XG4gICAgfVxuICAgIGdldCBuYW1lKCkge1xuICAgICAgICBjb25zdCBmaWVsZHMgPSB0aGlzLl9maWVsZHMubWFwKChba2V5LCB2YWx1ZV0pID0+IGtleSArICc6JyArIHZhbHVlLm5hbWUpO1xuICAgICAgICByZXR1cm4gYHJlY29yZCB7JHtmaWVsZHMuam9pbignOyAnKX19YDtcbiAgICB9XG4gICAgZGlzcGxheSgpIHtcbiAgICAgICAgY29uc3QgZmllbGRzID0gdGhpcy5fZmllbGRzLm1hcCgoW2tleSwgdmFsdWVdKSA9PiBrZXkgKyAnOicgKyB2YWx1ZS5kaXNwbGF5KCkpO1xuICAgICAgICByZXR1cm4gYHJlY29yZCB7JHtmaWVsZHMuam9pbignOyAnKX19YDtcbiAgICB9XG4gICAgdmFsdWVUb1N0cmluZyh4KSB7XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IHRoaXMuX2ZpZWxkcy5tYXAoKFtrZXldKSA9PiB4W2tleV0pO1xuICAgICAgICBjb25zdCBmaWVsZHMgPSB6aXBXaXRoKHRoaXMuX2ZpZWxkcywgdmFsdWVzLCAoW2ssIGNdLCBkKSA9PiBrICsgJz0nICsgYy52YWx1ZVRvU3RyaW5nKGQpKTtcbiAgICAgICAgcmV0dXJuIGByZWNvcmQgeyR7ZmllbGRzLmpvaW4oJzsgJyl9fWA7XG4gICAgfVxufVxuLyoqXG4gKiBSZXByZXNlbnRzIFR1cGxlLCBhIHN5bnRhY3RpYyBzdWdhciBmb3IgUmVjb3JkLlxuICogQHBhcmFtIHtUeXBlfSBjb21wb25lbnRzXG4gKi9cbmV4cG9ydCBjbGFzcyBUdXBsZUNsYXNzIGV4dGVuZHMgUmVjb3JkQ2xhc3Mge1xuICAgIGdldCB0eXBlTmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIElkbFR5cGVOYW1lLlR1cGxlQ2xhc3M7XG4gICAgfVxuICAgIHN0YXRpYyBbU3ltYm9sLmhhc0luc3RhbmNlXShpbnN0YW5jZSkge1xuICAgICAgICByZXR1cm4gaW5zdGFuY2UudHlwZU5hbWUgPT09IElkbFR5cGVOYW1lLlR1cGxlQ2xhc3M7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKF9jb21wb25lbnRzKSB7XG4gICAgICAgIGNvbnN0IHggPSB7fTtcbiAgICAgICAgX2NvbXBvbmVudHMuZm9yRWFjaCgoZSwgaSkgPT4gKHhbJ18nICsgaSArICdfJ10gPSBlKSk7XG4gICAgICAgIHN1cGVyKHgpO1xuICAgICAgICB0aGlzLl9jb21wb25lbnRzID0gX2NvbXBvbmVudHM7XG4gICAgfVxuICAgIGFjY2VwdCh2LCBkKSB7XG4gICAgICAgIHJldHVybiB2LnZpc2l0VHVwbGUodGhpcywgdGhpcy5fY29tcG9uZW50cywgZCk7XG4gICAgfVxuICAgIGNvdmFyaWFudCh4KSB7XG4gICAgICAgIC8vIGA+PWAgYmVjYXVzZSB0dXBsZXMgY2FuIGJlIGNvdmFyaWFudCB3aGVuIGVuY29kZWQuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHgpICYmXG4gICAgICAgICAgICB4Lmxlbmd0aCA+PSB0aGlzLl9maWVsZHMubGVuZ3RoICYmXG4gICAgICAgICAgICB0aGlzLl9jb21wb25lbnRzLmV2ZXJ5KCh0LCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHQuY292YXJpYW50KHhbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgJHt0aGlzLmRpc3BsYXkoKX0gYXJndW1lbnQ6IFxcblxcbmluZGV4ICR7aX0gLT4gJHtlLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkICR7dGhpcy5kaXNwbGF5KCl9IGFyZ3VtZW50OiAke3RvUmVhZGFibGVTdHJpbmcoeCl9YCk7XG4gICAgfVxuICAgIGVuY29kZVZhbHVlKHgpIHtcbiAgICAgICAgY29uc3QgYnVmcyA9IHppcFdpdGgodGhpcy5fY29tcG9uZW50cywgeCwgKGMsIGQpID0+IGMuZW5jb2RlVmFsdWUoZCkpO1xuICAgICAgICByZXR1cm4gY29uY2F0KC4uLmJ1ZnMpO1xuICAgIH1cbiAgICBkZWNvZGVWYWx1ZShiLCB0KSB7XG4gICAgICAgIGNvbnN0IHR1cGxlID0gdGhpcy5jaGVja1R5cGUodCk7XG4gICAgICAgIGlmICghKHR1cGxlIGluc3RhbmNlb2YgVHVwbGVDbGFzcykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbm90IGEgdHVwbGUgdHlwZScpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0dXBsZS5fY29tcG9uZW50cy5sZW5ndGggPCB0aGlzLl9jb21wb25lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0dXBsZSBtaXNtYXRjaCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlcyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IFtpLCB3aXJlVHlwZV0gb2YgdHVwbGUuX2NvbXBvbmVudHMuZW50cmllcygpKSB7XG4gICAgICAgICAgICBpZiAoaSA+PSB0aGlzLl9jb21wb25lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIC8vIHNraXAgdmFsdWVcbiAgICAgICAgICAgICAgICB3aXJlVHlwZS5kZWNvZGVWYWx1ZShiLCB3aXJlVHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXMucHVzaCh0aGlzLl9jb21wb25lbnRzW2ldLmRlY29kZVZhbHVlKGIsIHdpcmVUeXBlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgZGlzcGxheSgpIHtcbiAgICAgICAgY29uc3QgZmllbGRzID0gdGhpcy5fY29tcG9uZW50cy5tYXAodmFsdWUgPT4gdmFsdWUuZGlzcGxheSgpKTtcbiAgICAgICAgcmV0dXJuIGByZWNvcmQgeyR7ZmllbGRzLmpvaW4oJzsgJyl9fWA7XG4gICAgfVxuICAgIHZhbHVlVG9TdHJpbmcodmFsdWVzKSB7XG4gICAgICAgIGNvbnN0IGZpZWxkcyA9IHppcFdpdGgodGhpcy5fY29tcG9uZW50cywgdmFsdWVzLCAoYywgZCkgPT4gYy52YWx1ZVRvU3RyaW5nKGQpKTtcbiAgICAgICAgcmV0dXJuIGByZWNvcmQgeyR7ZmllbGRzLmpvaW4oJzsgJyl9fWA7XG4gICAgfVxufVxuLyoqXG4gKiBSZXByZXNlbnRzIGFuIElETCBWYXJpYW50XG4gKiBAcGFyYW0ge29iamVjdH0gW2ZpZWxkc10gLSBtYXBwaW5nIG9mIGZ1bmN0aW9uIG5hbWUgdG8gVHlwZVxuICovXG5leHBvcnQgY2xhc3MgVmFyaWFudENsYXNzIGV4dGVuZHMgQ29uc3RydWN0VHlwZSB7XG4gICAgZ2V0IHR5cGVOYW1lKCkge1xuICAgICAgICByZXR1cm4gSWRsVHlwZU5hbWUuVmFyaWFudENsYXNzO1xuICAgIH1cbiAgICBzdGF0aWMgW1N5bWJvbC5oYXNJbnN0YW5jZV0oaW5zdGFuY2UpIHtcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlLnR5cGVOYW1lID09PSBJZGxUeXBlTmFtZS5WYXJpYW50Q2xhc3M7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGZpZWxkcyA9IHt9KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX2ZpZWxkcyA9IE9iamVjdC5lbnRyaWVzKGZpZWxkcykuc29ydCgoYSwgYikgPT4gaWRsTGFiZWxUb0lkKGFbMF0pIC0gaWRsTGFiZWxUb0lkKGJbMF0pKTtcbiAgICB9XG4gICAgYWNjZXB0KHYsIGQpIHtcbiAgICAgICAgcmV0dXJuIHYudmlzaXRWYXJpYW50KHRoaXMsIHRoaXMuX2ZpZWxkcywgZCk7XG4gICAgfVxuICAgIGNvdmFyaWFudCh4KSB7XG4gICAgICAgIGlmICh0eXBlb2YgeCA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKHgpLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICAgICAgdGhpcy5fZmllbGRzLmV2ZXJ5KChbaywgdl0pID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICF4Lmhhc093blByb3BlcnR5KGspIHx8IHYuY292YXJpYW50KHhba10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgJHt0aGlzLmRpc3BsYXkoKX0gYXJndW1lbnQ6IFxcblxcbnZhcmlhbnQgJHtrfSAtPiAke2UubWVzc2FnZX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgJHt0aGlzLmRpc3BsYXkoKX0gYXJndW1lbnQ6ICR7dG9SZWFkYWJsZVN0cmluZyh4KX1gKTtcbiAgICB9XG4gICAgZW5jb2RlVmFsdWUoeCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2ZpZWxkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgW25hbWUsIHR5cGVdID0gdGhpcy5fZmllbGRzW2ldO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgICAgICBpZiAoeC5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlkeCA9IGxlYkVuY29kZShpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBidWYgPSB0eXBlLmVuY29kZVZhbHVlKHhbbmFtZV0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBjb25jYXQoaWR4LCBidWYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRocm93IEVycm9yKCdWYXJpYW50IGhhcyBubyBkYXRhOiAnICsgeCk7XG4gICAgfVxuICAgIF9idWlsZFR5cGVUYWJsZUltcGwodHlwZVRhYmxlKSB7XG4gICAgICAgIHRoaXMuX2ZpZWxkcy5mb3JFYWNoKChbLCB0eXBlXSkgPT4ge1xuICAgICAgICAgICAgdHlwZS5idWlsZFR5cGVUYWJsZSh0eXBlVGFibGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3Qgb3BDb2RlID0gc2xlYkVuY29kZShJRExUeXBlSWRzLlZhcmlhbnQpO1xuICAgICAgICBjb25zdCBsZW4gPSBsZWJFbmNvZGUodGhpcy5fZmllbGRzLmxlbmd0aCk7XG4gICAgICAgIGNvbnN0IGZpZWxkcyA9IHRoaXMuX2ZpZWxkcy5tYXAoKFtrZXksIHZhbHVlXSkgPT4gY29uY2F0KGxlYkVuY29kZShpZGxMYWJlbFRvSWQoa2V5KSksIHZhbHVlLmVuY29kZVR5cGUodHlwZVRhYmxlKSkpO1xuICAgICAgICB0eXBlVGFibGUuYWRkKHRoaXMsIGNvbmNhdChvcENvZGUsIGxlbiwgLi4uZmllbGRzKSk7XG4gICAgfVxuICAgIGRlY29kZVZhbHVlKGIsIHQpIHtcbiAgICAgICAgY29uc3QgdmFyaWFudCA9IHRoaXMuY2hlY2tUeXBlKHQpO1xuICAgICAgICBpZiAoISh2YXJpYW50IGluc3RhbmNlb2YgVmFyaWFudENsYXNzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgYSB2YXJpYW50IHR5cGUnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpZHggPSBOdW1iZXIobGViRGVjb2RlKGIpKTtcbiAgICAgICAgaWYgKGlkeCA+PSB2YXJpYW50Ll9maWVsZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcignSW52YWxpZCB2YXJpYW50IGluZGV4OiAnICsgaWR4KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBbd2lyZUhhc2gsIHdpcmVUeXBlXSA9IHZhcmlhbnQuX2ZpZWxkc1tpZHhdO1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIGV4cGVjdFR5cGVdIG9mIHRoaXMuX2ZpZWxkcykge1xuICAgICAgICAgICAgaWYgKGlkbExhYmVsVG9JZCh3aXJlSGFzaCkgPT09IGlkbExhYmVsVG9JZChrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBleHBlY3RUeXBlLmRlY29kZVZhbHVlKGIsIHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBba2V5XTogdmFsdWUgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIGZpZWxkIGhhc2ggJyArIHdpcmVIYXNoKTtcbiAgICB9XG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIGNvbnN0IGZpZWxkcyA9IHRoaXMuX2ZpZWxkcy5tYXAoKFtrZXksIHR5cGVdKSA9PiBrZXkgKyAnOicgKyB0eXBlLm5hbWUpO1xuICAgICAgICByZXR1cm4gYHZhcmlhbnQgeyR7ZmllbGRzLmpvaW4oJzsgJyl9fWA7XG4gICAgfVxuICAgIGRpc3BsYXkoKSB7XG4gICAgICAgIGNvbnN0IGZpZWxkcyA9IHRoaXMuX2ZpZWxkcy5tYXAoKFtrZXksIHR5cGVdKSA9PiBrZXkgKyAodHlwZS5uYW1lID09PSAnbnVsbCcgPyAnJyA6IGA6JHt0eXBlLmRpc3BsYXkoKX1gKSk7XG4gICAgICAgIHJldHVybiBgdmFyaWFudCB7JHtmaWVsZHMuam9pbignOyAnKX19YDtcbiAgICB9XG4gICAgdmFsdWVUb1N0cmluZyh4KSB7XG4gICAgICAgIGZvciAoY29uc3QgW25hbWUsIHR5cGVdIG9mIHRoaXMuX2ZpZWxkcykge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgICAgICBpZiAoeC5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdHlwZS52YWx1ZVRvU3RyaW5nKHhbbmFtZV0pO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gJ251bGwnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBgdmFyaWFudCB7JHtuYW1lfX1gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGB2YXJpYW50IHske25hbWV9PSR7dmFsdWV9fWA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVmFyaWFudCBoYXMgbm8gZGF0YTogJyArIHgpO1xuICAgIH1cbiAgICBnZXQgYWx0ZXJuYXRpdmVzQXNPYmplY3QoKSB7XG4gICAgICAgIGNvbnN0IGFsdGVybmF0aXZlcyA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IFtuYW1lLCB0eV0gb2YgdGhpcy5fZmllbGRzKSB7XG4gICAgICAgICAgICBhbHRlcm5hdGl2ZXNbaWRsTGFiZWxUb0lkKG5hbWUpXSA9IHR5O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhbHRlcm5hdGl2ZXM7XG4gICAgfVxufVxuLyoqXG4gKiBSZXByZXNlbnRzIGEgcmVmZXJlbmNlIHRvIGFuIElETCB0eXBlLCB1c2VkIGZvciBkZWZpbmluZyByZWN1cnNpdmUgZGF0YVxuICogdHlwZXMuXG4gKi9cbmV4cG9ydCBjbGFzcyBSZWNDbGFzcyBleHRlbmRzIENvbnN0cnVjdFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLl9pZCA9IFJlY0NsYXNzLl9jb3VudGVyKys7XG4gICAgfVxuICAgIGdldCB0eXBlTmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIElkbFR5cGVOYW1lLlJlY0NsYXNzO1xuICAgIH1cbiAgICBzdGF0aWMgeyB0aGlzLl9jb3VudGVyID0gMDsgfVxuICAgIHN0YXRpYyBbU3ltYm9sLmhhc0luc3RhbmNlXShpbnN0YW5jZSkge1xuICAgICAgICByZXR1cm4gaW5zdGFuY2UudHlwZU5hbWUgPT09IElkbFR5cGVOYW1lLlJlY0NsYXNzO1xuICAgIH1cbiAgICBhY2NlcHQodiwgZCkge1xuICAgICAgICBpZiAoIXRoaXMuX3R5cGUpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdSZWN1cnNpdmUgdHlwZSB1bmluaXRpYWxpemVkLicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2LnZpc2l0UmVjKHRoaXMsIHRoaXMuX3R5cGUsIGQpO1xuICAgIH1cbiAgICBmaWxsKHQpIHtcbiAgICAgICAgdGhpcy5fdHlwZSA9IHQ7XG4gICAgfVxuICAgIGdldFR5cGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90eXBlO1xuICAgIH1cbiAgICBjb3ZhcmlhbnQoeCkge1xuICAgICAgICBpZiAodGhpcy5fdHlwZSA/IHRoaXMuX3R5cGUuY292YXJpYW50KHgpIDogZmFsc2UpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkICR7dGhpcy5kaXNwbGF5KCl9IGFyZ3VtZW50OiAke3RvUmVhZGFibGVTdHJpbmcoeCl9YCk7XG4gICAgfVxuICAgIGVuY29kZVZhbHVlKHgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl90eXBlKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcignUmVjdXJzaXZlIHR5cGUgdW5pbml0aWFsaXplZC4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fdHlwZS5lbmNvZGVWYWx1ZSh4KTtcbiAgICB9XG4gICAgX2J1aWxkVHlwZVRhYmxlSW1wbCh0eXBlVGFibGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLl90eXBlKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcignUmVjdXJzaXZlIHR5cGUgdW5pbml0aWFsaXplZC4nKTtcbiAgICAgICAgfVxuICAgICAgICB0eXBlVGFibGUuYWRkKHRoaXMsIG5ldyBVaW50OEFycmF5KFtdKSk7XG4gICAgICAgIHRoaXMuX3R5cGUuYnVpbGRUeXBlVGFibGUodHlwZVRhYmxlKTtcbiAgICAgICAgdHlwZVRhYmxlLm1lcmdlKHRoaXMsIHRoaXMuX3R5cGUubmFtZSk7XG4gICAgfVxuICAgIGRlY29kZVZhbHVlKGIsIHQpIHtcbiAgICAgICAgaWYgKCF0aGlzLl90eXBlKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcignUmVjdXJzaXZlIHR5cGUgdW5pbml0aWFsaXplZC4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fdHlwZS5kZWNvZGVWYWx1ZShiLCB0KTtcbiAgICB9XG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiBgcmVjXyR7dGhpcy5faWR9YDtcbiAgICB9XG4gICAgZGlzcGxheSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl90eXBlKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcignUmVjdXJzaXZlIHR5cGUgdW5pbml0aWFsaXplZC4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYM68JHt0aGlzLm5hbWV9LiR7dGhpcy5fdHlwZS5uYW1lfWA7XG4gICAgfVxuICAgIHZhbHVlVG9TdHJpbmcoeCkge1xuICAgICAgICBpZiAoIXRoaXMuX3R5cGUpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdSZWN1cnNpdmUgdHlwZSB1bmluaXRpYWxpemVkLicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl90eXBlLnZhbHVlVG9TdHJpbmcoeCk7XG4gICAgfVxufVxuZnVuY3Rpb24gZGVjb2RlUHJpbmNpcGFsSWQoYikge1xuICAgIGNvbnN0IHggPSBzYWZlUmVhZFVpbnQ4KGIpO1xuICAgIGlmICh4ICE9PSAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGRlY29kZSBwcmluY2lwYWwnKTtcbiAgICB9XG4gICAgY29uc3QgbGVuID0gTnVtYmVyKGxlYkRlY29kZShiKSk7XG4gICAgcmV0dXJuIFByaW5jaXBhbElkLmZyb21VaW50OEFycmF5KG5ldyBVaW50OEFycmF5KHNhZmVSZWFkKGIsIGxlbikpKTtcbn1cbi8qKlxuICogUmVwcmVzZW50cyBhbiBJREwgcHJpbmNpcGFsIHJlZmVyZW5jZVxuICovXG5leHBvcnQgY2xhc3MgUHJpbmNpcGFsQ2xhc3MgZXh0ZW5kcyBQcmltaXRpdmVUeXBlIHtcbiAgICBnZXQgdHlwZU5hbWUoKSB7XG4gICAgICAgIHJldHVybiBJZGxUeXBlTmFtZS5QcmluY2lwYWxDbGFzcztcbiAgICB9XG4gICAgc3RhdGljIFtTeW1ib2wuaGFzSW5zdGFuY2VdKGluc3RhbmNlKSB7XG4gICAgICAgIHJldHVybiBpbnN0YW5jZS50eXBlTmFtZSA9PT0gSWRsVHlwZU5hbWUuUHJpbmNpcGFsQ2xhc3M7XG4gICAgfVxuICAgIGFjY2VwdCh2LCBkKSB7XG4gICAgICAgIHJldHVybiB2LnZpc2l0UHJpbmNpcGFsKHRoaXMsIGQpO1xuICAgIH1cbiAgICBjb3ZhcmlhbnQoeCkge1xuICAgICAgICBpZiAoeCAmJiB4Ll9pc1ByaW5jaXBhbClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgJHt0aGlzLmRpc3BsYXkoKX0gYXJndW1lbnQ6ICR7dG9SZWFkYWJsZVN0cmluZyh4KX1gKTtcbiAgICB9XG4gICAgZW5jb2RlVmFsdWUoeCkge1xuICAgICAgICBjb25zdCBidWYgPSB4LnRvVWludDhBcnJheSgpO1xuICAgICAgICBjb25zdCBsZW4gPSBsZWJFbmNvZGUoYnVmLmJ5dGVMZW5ndGgpO1xuICAgICAgICByZXR1cm4gY29uY2F0KG5ldyBVaW50OEFycmF5KFsxXSksIGxlbiwgYnVmKTtcbiAgICB9XG4gICAgZW5jb2RlVHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHNsZWJFbmNvZGUoSURMVHlwZUlkcy5QcmluY2lwYWwpO1xuICAgIH1cbiAgICBkZWNvZGVWYWx1ZShiLCB0KSB7XG4gICAgICAgIHRoaXMuY2hlY2tUeXBlKHQpO1xuICAgICAgICByZXR1cm4gZGVjb2RlUHJpbmNpcGFsSWQoYik7XG4gICAgfVxuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gJ3ByaW5jaXBhbCc7XG4gICAgfVxuICAgIHZhbHVlVG9TdHJpbmcoeCkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5uYW1lfSBcIiR7eC50b1RleHQoKX1cImA7XG4gICAgfVxufVxuLyoqXG4gKiBSZXByZXNlbnRzIGFuIElETCBmdW5jdGlvbiByZWZlcmVuY2UuXG4gKiBAcGFyYW0gYXJnVHlwZXMgQXJndW1lbnQgdHlwZXMuXG4gKiBAcGFyYW0gcmV0VHlwZXMgUmV0dXJuIHR5cGVzLlxuICogQHBhcmFtIGFubm90YXRpb25zIEZ1bmN0aW9uIGFubm90YXRpb25zLlxuICovXG5leHBvcnQgY2xhc3MgRnVuY0NsYXNzIGV4dGVuZHMgQ29uc3RydWN0VHlwZSB7XG4gICAgZ2V0IHR5cGVOYW1lKCkge1xuICAgICAgICByZXR1cm4gSWRsVHlwZU5hbWUuRnVuY0NsYXNzO1xuICAgIH1cbiAgICBzdGF0aWMgW1N5bWJvbC5oYXNJbnN0YW5jZV0oaW5zdGFuY2UpIHtcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlLnR5cGVOYW1lID09PSBJZGxUeXBlTmFtZS5GdW5jQ2xhc3M7XG4gICAgfVxuICAgIHN0YXRpYyBhcmdzVG9TdHJpbmcodHlwZXMsIHYpIHtcbiAgICAgICAgaWYgKHR5cGVzLmxlbmd0aCAhPT0gdi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXJpdHkgbWlzbWF0Y2gnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJygnICsgdHlwZXMubWFwKCh0LCBpKSA9PiB0LnZhbHVlVG9TdHJpbmcodltpXSkpLmpvaW4oJywgJykgKyAnKSc7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGFyZ1R5cGVzLCByZXRUeXBlcywgYW5ub3RhdGlvbnMgPSBbXSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmFyZ1R5cGVzID0gYXJnVHlwZXM7XG4gICAgICAgIHRoaXMucmV0VHlwZXMgPSByZXRUeXBlcztcbiAgICAgICAgdGhpcy5hbm5vdGF0aW9ucyA9IGFubm90YXRpb25zO1xuICAgIH1cbiAgICBhY2NlcHQodiwgZCkge1xuICAgICAgICByZXR1cm4gdi52aXNpdEZ1bmModGhpcywgZCk7XG4gICAgfVxuICAgIGNvdmFyaWFudCh4KSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHgpICYmIHgubGVuZ3RoID09PSAyICYmIHhbMF0gJiYgeFswXS5faXNQcmluY2lwYWwgJiYgdHlwZW9mIHhbMV0gPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCAke3RoaXMuZGlzcGxheSgpfSBhcmd1bWVudDogJHt0b1JlYWRhYmxlU3RyaW5nKHgpfWApO1xuICAgIH1cbiAgICBlbmNvZGVWYWx1ZShbcHJpbmNpcGFsLCBtZXRob2ROYW1lXSkge1xuICAgICAgICBjb25zdCBidWYgPSBwcmluY2lwYWwudG9VaW50OEFycmF5KCk7XG4gICAgICAgIGNvbnN0IGxlbiA9IGxlYkVuY29kZShidWYuYnl0ZUxlbmd0aCk7XG4gICAgICAgIGNvbnN0IGNhbmlzdGVyID0gY29uY2F0KG5ldyBVaW50OEFycmF5KFsxXSksIGxlbiwgYnVmKTtcbiAgICAgICAgY29uc3QgbWV0aG9kID0gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKG1ldGhvZE5hbWUpO1xuICAgICAgICBjb25zdCBtZXRob2RMZW4gPSBsZWJFbmNvZGUobWV0aG9kLmJ5dGVMZW5ndGgpO1xuICAgICAgICByZXR1cm4gY29uY2F0KG5ldyBVaW50OEFycmF5KFsxXSksIGNhbmlzdGVyLCBtZXRob2RMZW4sIG1ldGhvZCk7XG4gICAgfVxuICAgIF9idWlsZFR5cGVUYWJsZUltcGwoVCkge1xuICAgICAgICB0aGlzLmFyZ1R5cGVzLmZvckVhY2goYXJnID0+IGFyZy5idWlsZFR5cGVUYWJsZShUKSk7XG4gICAgICAgIHRoaXMucmV0VHlwZXMuZm9yRWFjaChhcmcgPT4gYXJnLmJ1aWxkVHlwZVRhYmxlKFQpKTtcbiAgICAgICAgY29uc3Qgb3BDb2RlID0gc2xlYkVuY29kZShJRExUeXBlSWRzLkZ1bmMpO1xuICAgICAgICBjb25zdCBhcmdMZW4gPSBsZWJFbmNvZGUodGhpcy5hcmdUeXBlcy5sZW5ndGgpO1xuICAgICAgICBjb25zdCBhcmdzID0gY29uY2F0KC4uLnRoaXMuYXJnVHlwZXMubWFwKGFyZyA9PiBhcmcuZW5jb2RlVHlwZShUKSkpO1xuICAgICAgICBjb25zdCByZXRMZW4gPSBsZWJFbmNvZGUodGhpcy5yZXRUeXBlcy5sZW5ndGgpO1xuICAgICAgICBjb25zdCByZXRzID0gY29uY2F0KC4uLnRoaXMucmV0VHlwZXMubWFwKGFyZyA9PiBhcmcuZW5jb2RlVHlwZShUKSkpO1xuICAgICAgICBjb25zdCBhbm5MZW4gPSBsZWJFbmNvZGUodGhpcy5hbm5vdGF0aW9ucy5sZW5ndGgpO1xuICAgICAgICBjb25zdCBhbm5zID0gY29uY2F0KC4uLnRoaXMuYW5ub3RhdGlvbnMubWFwKGEgPT4gdGhpcy5lbmNvZGVBbm5vdGF0aW9uKGEpKSk7XG4gICAgICAgIFQuYWRkKHRoaXMsIGNvbmNhdChvcENvZGUsIGFyZ0xlbiwgYXJncywgcmV0TGVuLCByZXRzLCBhbm5MZW4sIGFubnMpKTtcbiAgICB9XG4gICAgZGVjb2RlVmFsdWUoYiwgdCkge1xuICAgICAgICBjb25zdCB0dCA9IHQgaW5zdGFuY2VvZiBSZWNDbGFzcyA/ICh0LmdldFR5cGUoKSA/PyB0KSA6IHQ7XG4gICAgICAgIGlmICghc3VidHlwZSh0dCwgdGhpcykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGRlY29kZSBmdW5jdGlvbiByZWZlcmVuY2UgYXQgdHlwZSAke3RoaXMuZGlzcGxheSgpfSBmcm9tIHdpcmUgdHlwZSAke3R0LmRpc3BsYXkoKX1gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB4ID0gc2FmZVJlYWRVaW50OChiKTtcbiAgICAgICAgaWYgKHggIT09IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGRlY29kZSBmdW5jdGlvbiByZWZlcmVuY2UnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjYW5pc3RlciA9IGRlY29kZVByaW5jaXBhbElkKGIpO1xuICAgICAgICBjb25zdCBtTGVuID0gTnVtYmVyKGxlYkRlY29kZShiKSk7XG4gICAgICAgIGNvbnN0IGJ1ZiA9IHNhZmVSZWFkKGIsIG1MZW4pO1xuICAgICAgICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCd1dGY4JywgeyBmYXRhbDogdHJ1ZSB9KTtcbiAgICAgICAgY29uc3QgbWV0aG9kID0gZGVjb2Rlci5kZWNvZGUoYnVmKTtcbiAgICAgICAgcmV0dXJuIFtjYW5pc3RlciwgbWV0aG9kXTtcbiAgICB9XG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSB0aGlzLmFyZ1R5cGVzLm1hcChhcmcgPT4gYXJnLm5hbWUpLmpvaW4oJywgJyk7XG4gICAgICAgIGNvbnN0IHJldHMgPSB0aGlzLnJldFR5cGVzLm1hcChhcmcgPT4gYXJnLm5hbWUpLmpvaW4oJywgJyk7XG4gICAgICAgIGNvbnN0IGFubm9uID0gJyAnICsgdGhpcy5hbm5vdGF0aW9ucy5qb2luKCcgJyk7XG4gICAgICAgIHJldHVybiBgKCR7YXJnc30pIC0+ICgke3JldHN9KSR7YW5ub259YDtcbiAgICB9XG4gICAgdmFsdWVUb1N0cmluZyhbcHJpbmNpcGFsLCBzdHJdKSB7XG4gICAgICAgIHJldHVybiBgZnVuYyBcIiR7cHJpbmNpcGFsLnRvVGV4dCgpfVwiLiR7c3RyfWA7XG4gICAgfVxuICAgIGRpc3BsYXkoKSB7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSB0aGlzLmFyZ1R5cGVzLm1hcChhcmcgPT4gYXJnLmRpc3BsYXkoKSkuam9pbignLCAnKTtcbiAgICAgICAgY29uc3QgcmV0cyA9IHRoaXMucmV0VHlwZXMubWFwKGFyZyA9PiBhcmcuZGlzcGxheSgpKS5qb2luKCcsICcpO1xuICAgICAgICBjb25zdCBhbm5vbiA9ICcgJyArIHRoaXMuYW5ub3RhdGlvbnMuam9pbignICcpO1xuICAgICAgICByZXR1cm4gYCgke2FyZ3N9KSDihpIgKCR7cmV0c30pJHthbm5vbn1gO1xuICAgIH1cbiAgICBlbmNvZGVBbm5vdGF0aW9uKGFubikge1xuICAgICAgICBpZiAoYW5uID09PSAncXVlcnknKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzFdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhbm4gPT09ICdvbmV3YXknKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzJdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhbm4gPT09ICdjb21wb3NpdGVfcXVlcnknKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzNdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSWxsZWdhbCBmdW5jdGlvbiBhbm5vdGF0aW9uJyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnQgY2xhc3MgU2VydmljZUNsYXNzIGV4dGVuZHMgQ29uc3RydWN0VHlwZSB7XG4gICAgZ2V0IHR5cGVOYW1lKCkge1xuICAgICAgICByZXR1cm4gSWRsVHlwZU5hbWUuU2VydmljZUNsYXNzO1xuICAgIH1cbiAgICBzdGF0aWMgW1N5bWJvbC5oYXNJbnN0YW5jZV0oaW5zdGFuY2UpIHtcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlLnR5cGVOYW1lID09PSBJZGxUeXBlTmFtZS5TZXJ2aWNlQ2xhc3M7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl9maWVsZHMgPSBPYmplY3QuZW50cmllcyhmaWVsZHMpLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgICAgICAgIGlmIChhWzBdIDwgYlswXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhWzBdID4gYlswXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhY2NlcHQodiwgZCkge1xuICAgICAgICByZXR1cm4gdi52aXNpdFNlcnZpY2UodGhpcywgZCk7XG4gICAgfVxuICAgIGNvdmFyaWFudCh4KSB7XG4gICAgICAgIGlmICh4ICYmIHguX2lzUHJpbmNpcGFsKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCAke3RoaXMuZGlzcGxheSgpfSBhcmd1bWVudDogJHt0b1JlYWRhYmxlU3RyaW5nKHgpfWApO1xuICAgIH1cbiAgICBlbmNvZGVWYWx1ZSh4KSB7XG4gICAgICAgIGNvbnN0IGJ1ZiA9IHgudG9VaW50OEFycmF5KCk7XG4gICAgICAgIGNvbnN0IGxlbiA9IGxlYkVuY29kZShidWYubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIGNvbmNhdChuZXcgVWludDhBcnJheShbMV0pLCBsZW4sIGJ1Zik7XG4gICAgfVxuICAgIF9idWlsZFR5cGVUYWJsZUltcGwoVCkge1xuICAgICAgICB0aGlzLl9maWVsZHMuZm9yRWFjaCgoW18sIGZ1bmNdKSA9PiBmdW5jLmJ1aWxkVHlwZVRhYmxlKFQpKTtcbiAgICAgICAgY29uc3Qgb3BDb2RlID0gc2xlYkVuY29kZShJRExUeXBlSWRzLlNlcnZpY2UpO1xuICAgICAgICBjb25zdCBsZW4gPSBsZWJFbmNvZGUodGhpcy5fZmllbGRzLmxlbmd0aCk7XG4gICAgICAgIGNvbnN0IG1ldGhzID0gdGhpcy5fZmllbGRzLm1hcCgoW2xhYmVsLCBmdW5jXSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbGFiZWxCdWYgPSBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUobGFiZWwpO1xuICAgICAgICAgICAgY29uc3QgbGFiZWxMZW4gPSBsZWJFbmNvZGUobGFiZWxCdWYubGVuZ3RoKTtcbiAgICAgICAgICAgIHJldHVybiBjb25jYXQobGFiZWxMZW4sIGxhYmVsQnVmLCBmdW5jLmVuY29kZVR5cGUoVCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgVC5hZGQodGhpcywgY29uY2F0KG9wQ29kZSwgbGVuLCAuLi5tZXRocykpO1xuICAgIH1cbiAgICBkZWNvZGVWYWx1ZShiLCB0KSB7XG4gICAgICAgIGNvbnN0IHR0ID0gdCBpbnN0YW5jZW9mIFJlY0NsYXNzID8gKHQuZ2V0VHlwZSgpID8/IHQpIDogdDtcbiAgICAgICAgaWYgKCFzdWJ0eXBlKHR0LCB0aGlzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgZGVjb2RlIHNlcnZpY2UgcmVmZXJlbmNlIGF0IHR5cGUgJHt0aGlzLmRpc3BsYXkoKX0gZnJvbSB3aXJlIHR5cGUgJHt0dC5kaXNwbGF5KCl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlY29kZVByaW5jaXBhbElkKGIpO1xuICAgIH1cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgY29uc3QgZmllbGRzID0gdGhpcy5fZmllbGRzLm1hcCgoW2tleSwgdmFsdWVdKSA9PiBrZXkgKyAnOicgKyB2YWx1ZS5uYW1lKTtcbiAgICAgICAgcmV0dXJuIGBzZXJ2aWNlIHske2ZpZWxkcy5qb2luKCc7ICcpfX1gO1xuICAgIH1cbiAgICB2YWx1ZVRvU3RyaW5nKHgpIHtcbiAgICAgICAgcmV0dXJuIGBzZXJ2aWNlIFwiJHt4LnRvVGV4dCgpfVwiYDtcbiAgICB9XG4gICAgZmllbGRzQXNPYmplY3QoKSB7XG4gICAgICAgIGNvbnN0IGZpZWxkcyA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IFtuYW1lLCB0eV0gb2YgdGhpcy5fZmllbGRzKSB7XG4gICAgICAgICAgICBmaWVsZHNbbmFtZV0gPSB0eTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmllbGRzO1xuICAgIH1cbn1cbi8qKlxuICogVGFrZXMgYW4gdW5rbm93biB2YWx1ZSBhbmQgcmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBpdC5cbiAqIEBwYXJhbSB4IC0gdW5rbm93biB2YWx1ZVxuICogQHJldHVybnMge3N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB2YWx1ZVxuICovXG5mdW5jdGlvbiB0b1JlYWRhYmxlU3RyaW5nKHgpIHtcbiAgICBjb25zdCBzdHIgPSBKU09OLnN0cmluZ2lmeSh4LCAoX2tleSwgdmFsdWUpID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ2JpZ2ludCcgPyBgQmlnSW50KCR7dmFsdWV9KWAgOiB2YWx1ZSk7XG4gICAgcmV0dXJuIHN0ciAmJiBzdHIubGVuZ3RoID4gdG9SZWFkYWJsZVN0cmluZ19tYXhcbiAgICAgICAgPyBzdHIuc3Vic3RyaW5nKDAsIHRvUmVhZGFibGVTdHJpbmdfbWF4IC0gMykgKyAnLi4uJ1xuICAgICAgICA6IHN0cjtcbn1cbi8qKlxuICogRW5jb2RlIGEgYXJyYXkgb2YgdmFsdWVzXG4gKiBAcGFyYW0gYXJnVHlwZXMgLSBhcnJheSBvZiBUeXBlc1xuICogQHBhcmFtIGFyZ3MgLSBhcnJheSBvZiB2YWx1ZXNcbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fSBzZXJpYWxpc2VkIHZhbHVlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGUoYXJnVHlwZXMsIGFyZ3MpIHtcbiAgICBpZiAoYXJncy5sZW5ndGggPCBhcmdUeXBlcy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ1dyb25nIG51bWJlciBvZiBtZXNzYWdlIGFyZ3VtZW50cycpO1xuICAgIH1cbiAgICBjb25zdCB0eXBlVGFibGUgPSBuZXcgVHlwZVRhYmxlKCk7XG4gICAgYXJnVHlwZXMuZm9yRWFjaCh0ID0+IHQuYnVpbGRUeXBlVGFibGUodHlwZVRhYmxlKSk7XG4gICAgY29uc3QgbWFnaWMgPSBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUobWFnaWNOdW1iZXIpO1xuICAgIGNvbnN0IHRhYmxlID0gdHlwZVRhYmxlLmVuY29kZSgpO1xuICAgIGNvbnN0IGxlbiA9IGxlYkVuY29kZShhcmdzLmxlbmd0aCk7XG4gICAgY29uc3QgdHlwcyA9IGNvbmNhdCguLi5hcmdUeXBlcy5tYXAodCA9PiB0LmVuY29kZVR5cGUodHlwZVRhYmxlKSkpO1xuICAgIGNvbnN0IHZhbHMgPSBjb25jYXQoLi4uemlwV2l0aChhcmdUeXBlcywgYXJncywgKHQsIHgpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHQuY292YXJpYW50KHgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoZS5tZXNzYWdlICsgJ1xcblxcbicpO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0LmVuY29kZVZhbHVlKHgpO1xuICAgIH0pKTtcbiAgICByZXR1cm4gY29uY2F0KG1hZ2ljLCB0YWJsZSwgbGVuLCB0eXBzLCB2YWxzKTtcbn1cbi8qKlxuICogRGVjb2RlIGEgYmluYXJ5IHZhbHVlXG4gKiBAcGFyYW0gcmV0VHlwZXMgLSBUeXBlcyBleHBlY3RlZCBpbiB0aGUgYnVmZmVyLlxuICogQHBhcmFtIGJ5dGVzIC0gaGV4LWVuY29kZWQgc3RyaW5nLCBvciBidWZmZXIuXG4gKiBAcmV0dXJucyBWYWx1ZSBkZXNlcmlhbGlzZWQgdG8gSlMgdHlwZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlKHJldFR5cGVzLCBieXRlcykge1xuICAgIGNvbnN0IGIgPSBuZXcgUGlwZShieXRlcyk7XG4gICAgaWYgKGJ5dGVzLmJ5dGVMZW5ndGggPCBtYWdpY051bWJlci5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNZXNzYWdlIGxlbmd0aCBzbWFsbGVyIHRoYW4gbWFnaWMgbnVtYmVyJyk7XG4gICAgfVxuICAgIGNvbnN0IG1hZ2ljQnVmZmVyID0gc2FmZVJlYWQoYiwgbWFnaWNOdW1iZXIubGVuZ3RoKTtcbiAgICBjb25zdCBtYWdpYyA9IG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShtYWdpY0J1ZmZlcik7XG4gICAgaWYgKG1hZ2ljICE9PSBtYWdpY051bWJlcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dyb25nIG1hZ2ljIG51bWJlcjogJyArIEpTT04uc3RyaW5naWZ5KG1hZ2ljKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlYWRUeXBlVGFibGUocGlwZSkge1xuICAgICAgICBjb25zdCB0eXBlVGFibGUgPSBbXTtcbiAgICAgICAgY29uc3QgbGVuID0gTnVtYmVyKGxlYkRlY29kZShwaXBlKSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHR5ID0gTnVtYmVyKHNsZWJEZWNvZGUocGlwZSkpO1xuICAgICAgICAgICAgc3dpdGNoICh0eSkge1xuICAgICAgICAgICAgICAgIGNhc2UgSURMVHlwZUlkcy5PcHQ6XG4gICAgICAgICAgICAgICAgY2FzZSBJRExUeXBlSWRzLlZlY3Rvcjoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0ID0gTnVtYmVyKHNsZWJEZWNvZGUocGlwZSkpO1xuICAgICAgICAgICAgICAgICAgICB0eXBlVGFibGUucHVzaChbdHksIHRdKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgSURMVHlwZUlkcy5SZWNvcmQ6XG4gICAgICAgICAgICAgICAgY2FzZSBJRExUeXBlSWRzLlZhcmlhbnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmllbGRzID0gW107XG4gICAgICAgICAgICAgICAgICAgIGxldCBvYmplY3RMZW5ndGggPSBOdW1iZXIobGViRGVjb2RlKHBpcGUpKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHByZXZIYXNoO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAob2JqZWN0TGVuZ3RoLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGhhc2ggPSBOdW1iZXIobGViRGVjb2RlKHBpcGUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXNoID49IE1hdGgucG93KDIsIDMyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZmllbGQgaWQgb3V0IG9mIDMyLWJpdCByYW5nZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwcmV2SGFzaCA9PT0gJ251bWJlcicgJiYgcHJldkhhc2ggPj0gaGFzaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZmllbGQgaWQgY29sbGlzaW9uIG9yIG5vdCBzb3J0ZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXZIYXNoID0gaGFzaDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHQgPSBOdW1iZXIoc2xlYkRlY29kZShwaXBlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWVsZHMucHVzaChbaGFzaCwgdF0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHR5cGVUYWJsZS5wdXNoKFt0eSwgZmllbGRzXSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIElETFR5cGVJZHMuRnVuYzoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhcmdzID0gW107XG4gICAgICAgICAgICAgICAgICAgIGxldCBhcmdMZW5ndGggPSBOdW1iZXIobGViRGVjb2RlKHBpcGUpKTtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGFyZ0xlbmd0aC0tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzLnB1c2goTnVtYmVyKHNsZWJEZWNvZGUocGlwZSkpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXR1cm5WYWx1ZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJldHVyblZhbHVlc0xlbmd0aCA9IE51bWJlcihsZWJEZWNvZGUocGlwZSkpO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAocmV0dXJuVmFsdWVzTGVuZ3RoLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblZhbHVlcy5wdXNoKE51bWJlcihzbGViRGVjb2RlKHBpcGUpKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYW5ub3RhdGlvbnMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGFubm90YXRpb25MZW5ndGggPSBOdW1iZXIobGViRGVjb2RlKHBpcGUpKTtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGFubm90YXRpb25MZW5ndGgtLSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYW5ub3RhdGlvbiA9IE51bWJlcihsZWJEZWNvZGUocGlwZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChhbm5vdGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFubm90YXRpb25zLnB1c2goJ3F1ZXJ5Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5ub3RhdGlvbnMucHVzaCgnb25ld2F5Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5ub3RhdGlvbnMucHVzaCgnY29tcG9zaXRlX3F1ZXJ5Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24gYW5ub3RhdGlvbicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHR5cGVUYWJsZS5wdXNoKFt0eSwgW2FyZ3MsIHJldHVyblZhbHVlcywgYW5ub3RhdGlvbnNdXSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIElETFR5cGVJZHMuU2VydmljZToge1xuICAgICAgICAgICAgICAgICAgICBsZXQgc2Vydkxlbmd0aCA9IE51bWJlcihsZWJEZWNvZGUocGlwZSkpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtZXRob2RzID0gW107XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChzZXJ2TGVuZ3RoLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5hbWVMZW5ndGggPSBOdW1iZXIobGViRGVjb2RlKHBpcGUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZ1bmNOYW1lID0gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKHNhZmVSZWFkKHBpcGUsIG5hbWVMZW5ndGgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZ1bmNUeXBlID0gc2xlYkRlY29kZShwaXBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZHMucHVzaChbZnVuY05hbWUsIGZ1bmNUeXBlXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdHlwZVRhYmxlLnB1c2goW3R5LCBtZXRob2RzXSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgb3BfY29kZTogJyArIHR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCByYXdMaXN0ID0gW107XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IE51bWJlcihsZWJEZWNvZGUocGlwZSkpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByYXdMaXN0LnB1c2goTnVtYmVyKHNsZWJEZWNvZGUocGlwZSkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW3R5cGVUYWJsZSwgcmF3TGlzdF07XG4gICAgfVxuICAgIGNvbnN0IFtyYXdUYWJsZSwgcmF3VHlwZXNdID0gcmVhZFR5cGVUYWJsZShiKTtcbiAgICBpZiAocmF3VHlwZXMubGVuZ3RoIDwgcmV0VHlwZXMubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignV3JvbmcgbnVtYmVyIG9mIHJldHVybiB2YWx1ZXMnKTtcbiAgICB9XG4gICAgY29uc3QgdGFibGUgPSByYXdUYWJsZS5tYXAoXyA9PiBSZWMoKSk7XG4gICAgZnVuY3Rpb24gZ2V0VHlwZSh0KSB7XG4gICAgICAgIGlmICh0IDwgLTI0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Z1dHVyZSB2YWx1ZSBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHQgPCAwKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIC0xOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTnVsbDtcbiAgICAgICAgICAgICAgICBjYXNlIC0yOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQm9vbDtcbiAgICAgICAgICAgICAgICBjYXNlIC0zOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTmF0O1xuICAgICAgICAgICAgICAgIGNhc2UgLTQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBJbnQ7XG4gICAgICAgICAgICAgICAgY2FzZSAtNTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE5hdDg7XG4gICAgICAgICAgICAgICAgY2FzZSAtNjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE5hdDE2O1xuICAgICAgICAgICAgICAgIGNhc2UgLTc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBOYXQzMjtcbiAgICAgICAgICAgICAgICBjYXNlIC04OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTmF0NjQ7XG4gICAgICAgICAgICAgICAgY2FzZSAtOTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEludDg7XG4gICAgICAgICAgICAgICAgY2FzZSAtMTA6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBJbnQxNjtcbiAgICAgICAgICAgICAgICBjYXNlIC0xMTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEludDMyO1xuICAgICAgICAgICAgICAgIGNhc2UgLTEyOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gSW50NjQ7XG4gICAgICAgICAgICAgICAgY2FzZSAtMTM6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBGbG9hdDMyO1xuICAgICAgICAgICAgICAgIGNhc2UgLTE0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRmxvYXQ2NDtcbiAgICAgICAgICAgICAgICBjYXNlIC0xNTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFRleHQ7XG4gICAgICAgICAgICAgICAgY2FzZSAtMTY6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBSZXNlcnZlZDtcbiAgICAgICAgICAgICAgICBjYXNlIC0xNzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEVtcHR5O1xuICAgICAgICAgICAgICAgIGNhc2UgLTI0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJpbmNpcGFsO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSWxsZWdhbCBvcF9jb2RlOiAnICsgdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHQgPj0gcmF3VGFibGUubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3R5cGUgaW5kZXggb3V0IG9mIHJhbmdlJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhYmxlW3RdO1xuICAgIH1cbiAgICBmdW5jdGlvbiBidWlsZFR5cGUoZW50cnkpIHtcbiAgICAgICAgc3dpdGNoIChlbnRyeVswXSkge1xuICAgICAgICAgICAgY2FzZSBJRExUeXBlSWRzLlZlY3Rvcjoge1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5ID0gZ2V0VHlwZShlbnRyeVsxXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFZlYyh0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIElETFR5cGVJZHMuT3B0OiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdHkgPSBnZXRUeXBlKGVudHJ5WzFdKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gT3B0KHR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgSURMVHlwZUlkcy5SZWNvcmQ6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWVsZHMgPSB7fTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtoYXNoLCB0eV0gb2YgZW50cnlbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmFtZSA9IGBfJHtoYXNofV9gO1xuICAgICAgICAgICAgICAgICAgICBmaWVsZHNbbmFtZV0gPSBnZXRUeXBlKHR5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcmVjb3JkID0gUmVjb3JkKGZpZWxkcyk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHVwbGUgPSByZWNvcmQudHJ5QXNUdXBsZSgpO1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHR1cGxlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gVHVwbGUoLi4udHVwbGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlY29yZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIElETFR5cGVJZHMuVmFyaWFudDoge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkcyA9IHt9O1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgW2hhc2gsIHR5XSBvZiBlbnRyeVsxXSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuYW1lID0gYF8ke2hhc2h9X2A7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkc1tuYW1lXSA9IGdldFR5cGUodHkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gVmFyaWFudChmaWVsZHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBJRExUeXBlSWRzLkZ1bmM6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBbYXJncywgcmV0dXJuVmFsdWVzLCBhbm5vdGF0aW9uc10gPSBlbnRyeVsxXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gRnVuYyhhcmdzLm1hcCgodCkgPT4gZ2V0VHlwZSh0KSksIHJldHVyblZhbHVlcy5tYXAoKHQpID0+IGdldFR5cGUodCkpLCBhbm5vdGF0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIElETFR5cGVJZHMuU2VydmljZToge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlYyA9IHt9O1xuICAgICAgICAgICAgICAgIGNvbnN0IG1ldGhvZHMgPSBlbnRyeVsxXTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtuYW1lLCB0eXBlUmVmXSBvZiBtZXRob2RzKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0eXBlID0gZ2V0VHlwZSh0eXBlUmVmKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgaW5zdGFuY2VvZiBSZWNDbGFzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdW5wYWNrIHJlZmVyZW5jZSB0eXBlXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlID0gdHlwZS5nZXRUeXBlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodHlwZSBpbnN0YW5jZW9mIEZ1bmNDbGFzcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSWxsZWdhbCBzZXJ2aWNlIGRlZmluaXRpb246IHNlcnZpY2VzIGNhbiBvbmx5IGNvbnRhaW4gZnVuY3Rpb25zJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVjW25hbWVdID0gdHlwZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFNlcnZpY2UocmVjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbGxlZ2FsIG9wX2NvZGU6ICcgKyBlbnRyeVswXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmF3VGFibGUuZm9yRWFjaCgoZW50cnksIGkpID0+IHtcbiAgICAgICAgLy8gUHJvY2VzcyBmdW5jdGlvbiB0eXBlIGZpcnN0LCBzbyB0aGF0IHdlIGNhbiBjb25zdHJ1Y3QgdGhlIGNvcnJlY3Qgc2VydmljZSB0eXBlXG4gICAgICAgIGlmIChlbnRyeVswXSA9PT0gSURMVHlwZUlkcy5GdW5jKSB7XG4gICAgICAgICAgICBjb25zdCB0ID0gYnVpbGRUeXBlKGVudHJ5KTtcbiAgICAgICAgICAgIHRhYmxlW2ldLmZpbGwodCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByYXdUYWJsZS5mb3JFYWNoKChlbnRyeSwgaSkgPT4ge1xuICAgICAgICBpZiAoZW50cnlbMF0gIT09IElETFR5cGVJZHMuRnVuYykge1xuICAgICAgICAgICAgY29uc3QgdCA9IGJ1aWxkVHlwZShlbnRyeSk7XG4gICAgICAgICAgICB0YWJsZVtpXS5maWxsKHQpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmVzZXRTdWJ0eXBlQ2FjaGUoKTtcbiAgICBjb25zdCB0eXBlcyA9IHJhd1R5cGVzLm1hcCh0ID0+IGdldFR5cGUodCkpO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IHJldFR5cGVzLm1hcCgodCwgaSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHQuZGVjb2RlVmFsdWUoYiwgdHlwZXNbaV0pO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gc2tpcCB1bnVzZWQgdmFsdWVzXG4gICAgICAgIGZvciAobGV0IGluZCA9IHJldFR5cGVzLmxlbmd0aDsgaW5kIDwgdHlwZXMubGVuZ3RoOyBpbmQrKykge1xuICAgICAgICAgICAgdHlwZXNbaW5kXS5kZWNvZGVWYWx1ZShiLCB0eXBlc1tpbmRdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYi5ieXRlTGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkZWNvZGU6IExlZnQtb3ZlciBieXRlcycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICByZXNldFN1YnR5cGVDYWNoZSgpO1xuICAgIH1cbn1cbi8vIEV4cG9ydCBUeXBlcyBpbnN0YW5jZXMuXG5leHBvcnQgY29uc3QgRW1wdHkgPSBuZXcgRW1wdHlDbGFzcygpO1xuZXhwb3J0IGNvbnN0IFJlc2VydmVkID0gbmV3IFJlc2VydmVkQ2xhc3MoKTtcbi8qKlxuICogQ2xpZW50LW9ubHkgdHlwZSBmb3IgZGVzZXJpYWxpemluZyB1bmtub3duIGRhdGEuIE5vdCBzdXBwb3J0ZWQgYnkgQ2FuZGlkLCBhbmQgaXRzIHVzZSBpcyBkaXNjb3VyYWdlZC5cbiAqL1xuZXhwb3J0IGNvbnN0IFVua25vd24gPSBuZXcgVW5rbm93bkNsYXNzKCk7XG5leHBvcnQgY29uc3QgQm9vbCA9IG5ldyBCb29sQ2xhc3MoKTtcbmV4cG9ydCBjb25zdCBOdWxsID0gbmV3IE51bGxDbGFzcygpO1xuZXhwb3J0IGNvbnN0IFRleHQgPSBuZXcgVGV4dENsYXNzKCk7XG5leHBvcnQgY29uc3QgSW50ID0gbmV3IEludENsYXNzKCk7XG5leHBvcnQgY29uc3QgTmF0ID0gbmV3IE5hdENsYXNzKCk7XG5leHBvcnQgY29uc3QgRmxvYXQzMiA9IG5ldyBGbG9hdENsYXNzKDMyKTtcbmV4cG9ydCBjb25zdCBGbG9hdDY0ID0gbmV3IEZsb2F0Q2xhc3MoNjQpO1xuZXhwb3J0IGNvbnN0IEludDggPSBuZXcgRml4ZWRJbnRDbGFzcyg4KTtcbmV4cG9ydCBjb25zdCBJbnQxNiA9IG5ldyBGaXhlZEludENsYXNzKDE2KTtcbmV4cG9ydCBjb25zdCBJbnQzMiA9IG5ldyBGaXhlZEludENsYXNzKDMyKTtcbmV4cG9ydCBjb25zdCBJbnQ2NCA9IG5ldyBGaXhlZEludENsYXNzKDY0KTtcbmV4cG9ydCBjb25zdCBOYXQ4ID0gbmV3IEZpeGVkTmF0Q2xhc3MoOCk7XG5leHBvcnQgY29uc3QgTmF0MTYgPSBuZXcgRml4ZWROYXRDbGFzcygxNik7XG5leHBvcnQgY29uc3QgTmF0MzIgPSBuZXcgRml4ZWROYXRDbGFzcygzMik7XG5leHBvcnQgY29uc3QgTmF0NjQgPSBuZXcgRml4ZWROYXRDbGFzcyg2NCk7XG5leHBvcnQgY29uc3QgUHJpbmNpcGFsID0gbmV3IFByaW5jaXBhbENsYXNzKCk7XG4vKipcbiAqXG4gKiBAcGFyYW0gdHlwZXMgYXJyYXkgb2YgYW55IHR5cGVzXG4gKiBAcmV0dXJucyBUdXBsZUNsYXNzIGZyb20gdGhvc2UgdHlwZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFR1cGxlKC4uLnR5cGVzKSB7XG4gICAgcmV0dXJuIG5ldyBUdXBsZUNsYXNzKHR5cGVzKTtcbn1cbi8qKlxuICpcbiAqIEBwYXJhbSB0IElETCBUeXBlXG4gKiBAcmV0dXJucyBWZWNDbGFzcyBmcm9tIHRoYXQgdHlwZVxuICovXG5leHBvcnQgZnVuY3Rpb24gVmVjKHQpIHtcbiAgICByZXR1cm4gbmV3IFZlY0NsYXNzKHQpO1xufVxuLyoqXG4gKlxuICogQHBhcmFtIHQgSURMIFR5cGVcbiAqIEByZXR1cm5zIE9wdENsYXNzIG9mIFR5cGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIE9wdCh0KSB7XG4gICAgcmV0dXJuIG5ldyBPcHRDbGFzcyh0KTtcbn1cbi8qKlxuICpcbiAqIEBwYXJhbSB0IFJlY29yZCBvZiBzdHJpbmcgYW5kIElETCBUeXBlXG4gKiBAcmV0dXJucyBSZWNvcmRDbGFzcyBvZiBzdHJpbmcgYW5kIFR5cGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFJlY29yZCh0KSB7XG4gICAgcmV0dXJuIG5ldyBSZWNvcmRDbGFzcyh0KTtcbn1cbi8qKlxuICpcbiAqIEBwYXJhbSBmaWVsZHMgUmVjb3JkIG9mIHN0cmluZyBhbmQgSURMIFR5cGVcbiAqIEByZXR1cm5zIFZhcmlhbnRDbGFzc1xuICovXG5leHBvcnQgZnVuY3Rpb24gVmFyaWFudChmaWVsZHMpIHtcbiAgICByZXR1cm4gbmV3IFZhcmlhbnRDbGFzcyhmaWVsZHMpO1xufVxuLyoqXG4gKlxuICogQHJldHVybnMgbmV3IFJlY0NsYXNzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBSZWMoKSB7XG4gICAgcmV0dXJuIG5ldyBSZWNDbGFzcygpO1xufVxuLyoqXG4gKlxuICogQHBhcmFtIGFyZ3MgYXJyYXkgb2YgSURMIFR5cGVzXG4gKiBAcGFyYW0gcmV0IGFycmF5IG9mIElETCBUeXBlc1xuICogQHBhcmFtIGFubm90YXRpb25zIGFycmF5IG9mIHN0cmluZ3MsIFtdIGJ5IGRlZmF1bHRcbiAqIEByZXR1cm5zIG5ldyBGdW5jQ2xhc3NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIEZ1bmMoYXJncywgcmV0LCBhbm5vdGF0aW9ucyA9IFtdKSB7XG4gICAgcmV0dXJuIG5ldyBGdW5jQ2xhc3MoYXJncywgcmV0LCBhbm5vdGF0aW9ucyk7XG59XG4vKipcbiAqXG4gKiBAcGFyYW0gdCBSZWNvcmQgb2Ygc3RyaW5nIGFuZCBGdW5jQ2xhc3NcbiAqIEByZXR1cm5zIFNlcnZpY2VDbGFzc1xuICovXG5leHBvcnQgZnVuY3Rpb24gU2VydmljZSh0KSB7XG4gICAgcmV0dXJuIG5ldyBTZXJ2aWNlQ2xhc3ModCk7XG59XG4vKipcbiAqIFRoZSBsaXN0IG9mIHJlbGF0aW9ucyBiZXR3ZWVuIHR5cGVzIHdlIGFzc3VtZSB0byBob2xkLiBVc2VzIHRoZSB0eXBlcyAubmFtZSBwcm9wZXJ0eSBhcyBrZXlcbiAqL1xuY2xhc3MgUmVsYXRpb25zIHtcbiAgICBjb25zdHJ1Y3RvcihyZWxhdGlvbnMgPSBuZXcgTWFwKCkpIHtcbiAgICAgICAgdGhpcy5yZWxzID0gcmVsYXRpb25zO1xuICAgIH1cbiAgICBjb3B5KCkge1xuICAgICAgICBjb25zdCBjb3B5ID0gbmV3IE1hcCgpO1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiB0aGlzLnJlbHMuZW50cmllcygpKSB7XG4gICAgICAgICAgICBjb25zdCB2YWxDb3B5ID0gbmV3IE1hcCh2YWx1ZSk7XG4gICAgICAgICAgICBjb3B5LnNldChrZXksIHZhbENvcHkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUmVsYXRpb25zKGNvcHkpO1xuICAgIH1cbiAgICAvLy8gUmV0dXJucyB3aGV0aGVyIHdlIGtub3cgZm9yIHN1cmUgdGhhdCBhIHJlbGF0aW9uIGhvbGRzIG9yIGRvZXNuJ3QgKGB0cnVlYCBvciBgZmFsc2VgKSwgb3JcbiAgICAvLy8gaWYgd2UgZG9uJ3Qga25vdyB5ZXQgKGB1bmRlZmluZWRgKVxuICAgIGtub3duKHQxLCB0Mikge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWxzLmdldCh0MS5uYW1lKT8uZ2V0KHQyLm5hbWUpO1xuICAgIH1cbiAgICBhZGROZWdhdGl2ZSh0MSwgdDIpIHtcbiAgICAgICAgdGhpcy5hZGROYW1lcyh0MS5uYW1lLCB0Mi5uYW1lLCBmYWxzZSk7XG4gICAgfVxuICAgIGFkZCh0MSwgdDIpIHtcbiAgICAgICAgdGhpcy5hZGROYW1lcyh0MS5uYW1lLCB0Mi5uYW1lLCB0cnVlKTtcbiAgICB9XG4gICAgZGlzcGxheSgpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9ICcnO1xuICAgICAgICBmb3IgKGNvbnN0IFt0MSwgdl0gb2YgdGhpcy5yZWxzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFt0Miwga25vd25dIG9mIHYpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdWJ0eSA9IGtub3duID8gJzo8JyA6ICchPDonO1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBgJHt0MX0gJHtzdWJ0eX0gJHt0Mn1cXG5gO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGFkZE5hbWVzKHQxLCB0MiwgaXNTdWJ0eXBlKSB7XG4gICAgICAgIGNvbnN0IHQxTWFwID0gdGhpcy5yZWxzLmdldCh0MSk7XG4gICAgICAgIGlmICh0MU1hcCA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld01hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIG5ld01hcC5zZXQodDIsIGlzU3VidHlwZSk7XG4gICAgICAgICAgICB0aGlzLnJlbHMuc2V0KHQxLCBuZXdNYXApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdDFNYXAuc2V0KHQyLCBpc1N1YnR5cGUpO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8vIGBzdWJ0eXBlQ2FjaGVgIGhvbGRzIHN1YnR5cGluZyByZWxhdGlvbnMgd2UndmUgcHJldmlvdXNseSBjb21wdXRlZCB3aGlsZSBkZWNvZGluZyBhIG1lc3NhZ2VcbmxldCBzdWJ0eXBlQ2FjaGUgPSBuZXcgUmVsYXRpb25zKCk7XG4vKiogUmVzZXRzIHRoZSBnbG9iYWwgc3VidHlwaW5nIGNhY2hlICovXG5leHBvcnQgZnVuY3Rpb24gcmVzZXRTdWJ0eXBlQ2FjaGUoKSB7XG4gICAgc3VidHlwZUNhY2hlID0gbmV3IFJlbGF0aW9ucygpO1xufVxuZnVuY3Rpb24gZXFGdW5jdGlvbkFubm90YXRpb25zKHQxLCB0Mikge1xuICAgIGNvbnN0IHQxQW5ub3RhdGlvbnMgPSBuZXcgU2V0KHQxLmFubm90YXRpb25zKTtcbiAgICBjb25zdCB0MkFubm90YXRpb25zID0gbmV3IFNldCh0Mi5hbm5vdGF0aW9ucyk7XG4gICAgaWYgKHQxQW5ub3RhdGlvbnMuc2l6ZSAhPT0gdDJBbm5vdGF0aW9ucy5zaXplKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBhIG9mIHQxQW5ub3RhdGlvbnMpIHtcbiAgICAgICAgaWYgKCF0MkFubm90YXRpb25zLmhhcyhhKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBjYW5CZU9tbWl0dGVkKHQpIHtcbiAgICByZXR1cm4gdCBpbnN0YW5jZW9mIE9wdENsYXNzIHx8IHQgaW5zdGFuY2VvZiBOdWxsQ2xhc3MgfHwgdCBpbnN0YW5jZW9mIFJlc2VydmVkQ2xhc3M7XG59XG4vKipcbiAqIFN1YnR5cGluZyBvbiBDYW5kaWQgdHlwZXMgdDEgPDogdDIgKEV4cG9ydGVkIGZvciB0ZXN0aW5nKVxuICogQHBhcmFtIHQxIFRoZSBwb3RlbnRpYWwgc3VidHlwZVxuICogQHBhcmFtIHQyIFRoZSBwb3RlbnRpYWwgc3VwZXJ0eXBlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdWJ0eXBlKHQxLCB0Mikge1xuICAgIGNvbnN0IHJlbGF0aW9ucyA9IHN1YnR5cGVDYWNoZS5jb3B5KCk7XG4gICAgY29uc3QgaXNTdWJ0eXBlID0gc3VidHlwZV8ocmVsYXRpb25zLCB0MSwgdDIpO1xuICAgIGlmIChpc1N1YnR5cGUpIHtcbiAgICAgICAgc3VidHlwZUNhY2hlLmFkZCh0MSwgdDIpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc3VidHlwZUNhY2hlLmFkZE5lZ2F0aXZlKHQxLCB0Mik7XG4gICAgfVxuICAgIHJldHVybiBpc1N1YnR5cGU7XG59XG5mdW5jdGlvbiBzdWJ0eXBlXyhyZWxhdGlvbnMsIHQxLCB0Mikge1xuICAgIGlmICh0MS5uYW1lID09PSB0Mi5uYW1lKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBjb25zdCBrbm93biA9IHJlbGF0aW9ucy5rbm93bih0MSwgdDIpO1xuICAgIGlmIChrbm93biAhPT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4ga25vd247XG4gICAgcmVsYXRpb25zLmFkZCh0MSwgdDIpO1xuICAgIGlmICh0MiBpbnN0YW5jZW9mIFJlc2VydmVkQ2xhc3MpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGlmICh0MSBpbnN0YW5jZW9mIEVtcHR5Q2xhc3MpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGlmICh0MSBpbnN0YW5jZW9mIE5hdENsYXNzICYmIHQyIGluc3RhbmNlb2YgSW50Q2xhc3MpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGlmICh0MSBpbnN0YW5jZW9mIFZlY0NsYXNzICYmIHQyIGluc3RhbmNlb2YgVmVjQ2xhc3MpXG4gICAgICAgIHJldHVybiBzdWJ0eXBlXyhyZWxhdGlvbnMsIHQxLl90eXBlLCB0Mi5fdHlwZSk7XG4gICAgaWYgKHQyIGluc3RhbmNlb2YgT3B0Q2xhc3MpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGlmICh0MSBpbnN0YW5jZW9mIFJlY29yZENsYXNzICYmIHQyIGluc3RhbmNlb2YgUmVjb3JkQ2xhc3MpIHtcbiAgICAgICAgY29uc3QgdDFPYmplY3QgPSB0MS5maWVsZHNBc09iamVjdDtcbiAgICAgICAgZm9yIChjb25zdCBbbGFiZWwsIHR5Ml0gb2YgdDIuX2ZpZWxkcykge1xuICAgICAgICAgICAgY29uc3QgdHkxID0gdDFPYmplY3RbaWRsTGFiZWxUb0lkKGxhYmVsKV07XG4gICAgICAgICAgICBpZiAoIXR5MSkge1xuICAgICAgICAgICAgICAgIGlmICghY2FuQmVPbW1pdHRlZCh0eTIpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIXN1YnR5cGVfKHJlbGF0aW9ucywgdHkxLCB0eTIpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICh0MSBpbnN0YW5jZW9mIEZ1bmNDbGFzcyAmJiB0MiBpbnN0YW5jZW9mIEZ1bmNDbGFzcykge1xuICAgICAgICBpZiAoIWVxRnVuY3Rpb25Bbm5vdGF0aW9ucyh0MSwgdDIpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHQxLmFyZ1R5cGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBhcmdUeTEgPSB0MS5hcmdUeXBlc1tpXTtcbiAgICAgICAgICAgIGlmIChpIDwgdDIuYXJnVHlwZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzdWJ0eXBlXyhyZWxhdGlvbnMsIHQyLmFyZ1R5cGVzW2ldLCBhcmdUeTEpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIWNhbkJlT21taXR0ZWQoYXJnVHkxKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdDIucmV0VHlwZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHJldFR5MiA9IHQyLnJldFR5cGVzW2ldO1xuICAgICAgICAgICAgaWYgKGkgPCB0MS5yZXRUeXBlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXN1YnR5cGVfKHJlbGF0aW9ucywgdDEucmV0VHlwZXNbaV0sIHJldFR5MikpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICghY2FuQmVPbW1pdHRlZChyZXRUeTIpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICh0MSBpbnN0YW5jZW9mIFZhcmlhbnRDbGFzcyAmJiB0MiBpbnN0YW5jZW9mIFZhcmlhbnRDbGFzcykge1xuICAgICAgICBjb25zdCB0Mk9iamVjdCA9IHQyLmFsdGVybmF0aXZlc0FzT2JqZWN0O1xuICAgICAgICBmb3IgKGNvbnN0IFtsYWJlbCwgdHkxXSBvZiB0MS5fZmllbGRzKSB7XG4gICAgICAgICAgICBjb25zdCB0eTIgPSB0Mk9iamVjdFtpZGxMYWJlbFRvSWQobGFiZWwpXTtcbiAgICAgICAgICAgIGlmICghdHkyKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGlmICghc3VidHlwZV8ocmVsYXRpb25zLCB0eTEsIHR5MikpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAodDEgaW5zdGFuY2VvZiBTZXJ2aWNlQ2xhc3MgJiYgdDIgaW5zdGFuY2VvZiBTZXJ2aWNlQ2xhc3MpIHtcbiAgICAgICAgY29uc3QgdDFPYmplY3QgPSB0MS5maWVsZHNBc09iamVjdCgpO1xuICAgICAgICBmb3IgKGNvbnN0IFtuYW1lLCB0eTJdIG9mIHQyLl9maWVsZHMpIHtcbiAgICAgICAgICAgIGNvbnN0IHR5MSA9IHQxT2JqZWN0W25hbWVdO1xuICAgICAgICAgICAgaWYgKCF0eTEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaWYgKCFzdWJ0eXBlXyhyZWxhdGlvbnMsIHR5MSwgdHkyKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICh0MSBpbnN0YW5jZW9mIFJlY0NsYXNzKSB7XG4gICAgICAgIHJldHVybiBzdWJ0eXBlXyhyZWxhdGlvbnMsIHQxLmdldFR5cGUoKSwgdDIpO1xuICAgIH1cbiAgICBpZiAodDIgaW5zdGFuY2VvZiBSZWNDbGFzcykge1xuICAgICAgICByZXR1cm4gc3VidHlwZV8ocmVsYXRpb25zLCB0MSwgdDIuZ2V0VHlwZSgpKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aWRsLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../packages/sdk-js/node_modules/@dfinity/candid/lib/esm/idl.js\n");

/***/ }),

/***/ "(ssr)/../../packages/sdk-js/node_modules/@dfinity/candid/lib/esm/utils/bigint-math.js":
/*!***************************************************************************************!*\
  !*** ../../packages/sdk-js/node_modules/@dfinity/candid/lib/esm/utils/bigint-math.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   iexp2: () => (/* binding */ iexp2),\n/* harmony export */   ilog2: () => (/* binding */ ilog2)\n/* harmony export */ });\n/**\n * Equivalent to `Math.log2(n)` with support for `BigInt` values\n * @param n bigint or integer\n * @returns integer\n */\nfunction ilog2(n) {\n    const nBig = BigInt(n);\n    if (n <= 0) {\n        throw new RangeError('Input must be positive');\n    }\n    return nBig.toString(2).length - 1;\n}\n/**\n * Equivalent to `2 ** n` with support for `BigInt` values\n * (necessary for browser preprocessors which replace the `**` operator with `Math.pow`)\n * @param n bigint or integer\n * @returns bigint\n */\nfunction iexp2(n) {\n    const nBig = BigInt(n);\n    if (n < 0) {\n        throw new RangeError('Input must be non-negative');\n    }\n    return BigInt(1) << nBig;\n}\n//# sourceMappingURL=bigint-math.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vcGFja2FnZXMvc2RrLWpzL25vZGVfbW9kdWxlcy9AZGZpbml0eS9jYW5kaWQvbGliL2VzbS91dGlscy9iaWdpbnQtbWF0aC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AaXF1YmUvb3BzLWNvbnNvbGUvLi4vLi4vcGFja2FnZXMvc2RrLWpzL25vZGVfbW9kdWxlcy9AZGZpbml0eS9jYW5kaWQvbGliL2VzbS91dGlscy9iaWdpbnQtbWF0aC5qcz80NzhmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogRXF1aXZhbGVudCB0byBgTWF0aC5sb2cyKG4pYCB3aXRoIHN1cHBvcnQgZm9yIGBCaWdJbnRgIHZhbHVlc1xuICogQHBhcmFtIG4gYmlnaW50IG9yIGludGVnZXJcbiAqIEByZXR1cm5zIGludGVnZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlsb2cyKG4pIHtcbiAgICBjb25zdCBuQmlnID0gQmlnSW50KG4pO1xuICAgIGlmIChuIDw9IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0lucHV0IG11c3QgYmUgcG9zaXRpdmUnKTtcbiAgICB9XG4gICAgcmV0dXJuIG5CaWcudG9TdHJpbmcoMikubGVuZ3RoIC0gMTtcbn1cbi8qKlxuICogRXF1aXZhbGVudCB0byBgMiAqKiBuYCB3aXRoIHN1cHBvcnQgZm9yIGBCaWdJbnRgIHZhbHVlc1xuICogKG5lY2Vzc2FyeSBmb3IgYnJvd3NlciBwcmVwcm9jZXNzb3JzIHdoaWNoIHJlcGxhY2UgdGhlIGAqKmAgb3BlcmF0b3Igd2l0aCBgTWF0aC5wb3dgKVxuICogQHBhcmFtIG4gYmlnaW50IG9yIGludGVnZXJcbiAqIEByZXR1cm5zIGJpZ2ludFxuICovXG5leHBvcnQgZnVuY3Rpb24gaWV4cDIobikge1xuICAgIGNvbnN0IG5CaWcgPSBCaWdJbnQobik7XG4gICAgaWYgKG4gPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnB1dCBtdXN0IGJlIG5vbi1uZWdhdGl2ZScpO1xuICAgIH1cbiAgICByZXR1cm4gQmlnSW50KDEpIDw8IG5CaWc7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iaWdpbnQtbWF0aC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../packages/sdk-js/node_modules/@dfinity/candid/lib/esm/utils/bigint-math.js\n");

/***/ }),

/***/ "(ssr)/../../packages/sdk-js/node_modules/@dfinity/candid/lib/esm/utils/buffer.js":
/*!**********************************************************************************!*\
  !*** ../../packages/sdk-js/node_modules/@dfinity/candid/lib/esm/utils/buffer.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PipeArrayBuffer: () => (/* binding */ PipeArrayBuffer),\n/* harmony export */   compare: () => (/* binding */ compare),\n/* harmony export */   concat: () => (/* binding */ concat),\n/* harmony export */   uint8Equals: () => (/* binding */ uint8Equals),\n/* harmony export */   uint8FromBufLike: () => (/* binding */ uint8FromBufLike),\n/* harmony export */   uint8ToDataView: () => (/* binding */ uint8ToDataView)\n/* harmony export */ });\n/**\n * Concatenate multiple Uint8Arrays.\n * @param uint8Arrays The Uint8Arrays to concatenate.\n */\nfunction concat(...uint8Arrays) {\n    const result = new Uint8Array(uint8Arrays.reduce((acc, curr) => acc + curr.byteLength, 0));\n    let index = 0;\n    for (const b of uint8Arrays) {\n        result.set(b, index);\n        index += b.byteLength;\n    }\n    return result;\n}\n/**\n * A class that abstracts a pipe-like Uint8Array.\n */\nclass PipeArrayBuffer {\n    /**\n     * Save a checkpoint of the reading view (for backtracking)\n     */\n    save() {\n        return this._view;\n    }\n    /**\n     * Restore a checkpoint of the reading view (for backtracking)\n     * @param checkPoint a previously saved checkpoint\n     */\n    restore(checkPoint) {\n        if (!(checkPoint instanceof Uint8Array)) {\n            throw new Error('Checkpoint must be a Uint8Array');\n        }\n        this._view = checkPoint;\n    }\n    /**\n     * Creates a new instance of a pipe\n     * @param buffer an optional buffer to start with\n     * @param length an optional amount of bytes to use for the length.\n     */\n    constructor(buffer, length = buffer?.byteLength || 0) {\n        if (buffer && !(buffer instanceof Uint8Array)) {\n            try {\n                buffer = uint8FromBufLike(buffer);\n            }\n            catch {\n                throw new Error('Buffer must be a Uint8Array');\n            }\n        }\n        if (length < 0 || !Number.isInteger(length)) {\n            throw new Error('Length must be a non-negative integer');\n        }\n        if (buffer && length > buffer.byteLength) {\n            throw new Error('Length cannot exceed buffer length');\n        }\n        this._buffer = buffer || new Uint8Array(0);\n        this._view = new Uint8Array(this._buffer.buffer, 0, length);\n    }\n    get buffer() {\n        // Return a copy of the buffer.\n        return this._view.slice();\n    }\n    get byteLength() {\n        return this._view.byteLength;\n    }\n    /**\n     * Read `num` number of bytes from the front of the pipe.\n     * @param num The number of bytes to read.\n     */\n    read(num) {\n        const result = this._view.subarray(0, num);\n        this._view = this._view.subarray(num);\n        return result.slice();\n    }\n    readUint8() {\n        if (this._view.byteLength === 0) {\n            return undefined;\n        }\n        const result = this._view[0];\n        this._view = this._view.subarray(1);\n        return result;\n    }\n    /**\n     * Write a buffer to the end of the pipe.\n     * @param buf The bytes to write.\n     */\n    write(buf) {\n        if (!(buf instanceof Uint8Array)) {\n            throw new Error('Buffer must be a Uint8Array');\n        }\n        const offset = this._view.byteLength;\n        if (this._view.byteOffset + this._view.byteLength + buf.byteLength >= this._buffer.byteLength) {\n            // Alloc grow the view to include the new bytes.\n            this.alloc(buf.byteLength);\n        }\n        else {\n            // Update the view to include the new bytes.\n            this._view = new Uint8Array(this._buffer.buffer, this._view.byteOffset, this._view.byteLength + buf.byteLength);\n        }\n        this._view.set(buf, offset);\n    }\n    /**\n     * Whether or not there is more data to read from the buffer\n     */\n    get end() {\n        return this._view.byteLength === 0;\n    }\n    /**\n     * Allocate a fixed amount of memory in the buffer. This does not affect the view.\n     * @param amount A number of bytes to add to the buffer.\n     */\n    alloc(amount) {\n        if (amount <= 0 || !Number.isInteger(amount)) {\n            throw new Error('Amount must be a positive integer');\n        }\n        // Add a little bit of exponential growth.\n        const b = new Uint8Array(((this._buffer.byteLength + amount) * 1.2) | 0);\n        const v = new Uint8Array(b.buffer, 0, this._view.byteLength + amount);\n        v.set(this._view);\n        this._buffer = b;\n        this._view = v;\n    }\n}\n/**\n * Returns a true Uint8Array from an ArrayBufferLike object.\n * @param bufLike a buffer-like object\n * @returns Uint8Array\n */\nfunction uint8FromBufLike(bufLike) {\n    if (!bufLike) {\n        throw new Error('Input cannot be null or undefined');\n    }\n    if (bufLike instanceof Uint8Array) {\n        return bufLike;\n    }\n    if (bufLike instanceof ArrayBuffer) {\n        return new Uint8Array(bufLike);\n    }\n    if (Array.isArray(bufLike)) {\n        return new Uint8Array(bufLike);\n    }\n    if ('buffer' in bufLike) {\n        return uint8FromBufLike(bufLike.buffer);\n    }\n    return new Uint8Array(bufLike);\n}\n/**\n *\n * @param u1 uint8Array 1\n * @param u2 uint8Array 2\n * @returns number - negative if u1 < u2, positive if u1 > u2, 0 if u1 === u2\n */\nfunction compare(u1, u2) {\n    if (u1.byteLength !== u2.byteLength) {\n        return u1.byteLength - u2.byteLength;\n    }\n    for (let i = 0; i < u1.length; i++) {\n        if (u1[i] !== u2[i]) {\n            return u1[i] - u2[i];\n        }\n    }\n    return 0;\n}\n/**\n * Checks two uint8Arrays for equality.\n * @param u1 uint8Array 1\n * @param u2 uint8Array 2\n * @returns boolean\n */\nfunction uint8Equals(u1, u2) {\n    return compare(u1, u2) === 0;\n}\n/**\n * Helpers to convert a Uint8Array to a DataView.\n * @param uint8 Uint8Array\n * @returns DataView\n */\nfunction uint8ToDataView(uint8) {\n    if (!(uint8 instanceof Uint8Array)) {\n        throw new Error('Input must be a Uint8Array');\n    }\n    return new DataView(uint8.buffer, uint8.byteOffset, uint8.byteLength);\n}\n//# sourceMappingURL=buffer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vcGFja2FnZXMvc2RrLWpzL25vZGVfbW9kdWxlcy9AZGZpbml0eS9jYW5kaWQvbGliL2VzbS91dGlscy9idWZmZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZUFBZTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AaXF1YmUvb3BzLWNvbnNvbGUvLi4vLi4vcGFja2FnZXMvc2RrLWpzL25vZGVfbW9kdWxlcy9AZGZpbml0eS9jYW5kaWQvbGliL2VzbS91dGlscy9idWZmZXIuanM/YmQ2YSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvbmNhdGVuYXRlIG11bHRpcGxlIFVpbnQ4QXJyYXlzLlxuICogQHBhcmFtIHVpbnQ4QXJyYXlzIFRoZSBVaW50OEFycmF5cyB0byBjb25jYXRlbmF0ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbmNhdCguLi51aW50OEFycmF5cykge1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KHVpbnQ4QXJyYXlzLnJlZHVjZSgoYWNjLCBjdXJyKSA9PiBhY2MgKyBjdXJyLmJ5dGVMZW5ndGgsIDApKTtcbiAgICBsZXQgaW5kZXggPSAwO1xuICAgIGZvciAoY29uc3QgYiBvZiB1aW50OEFycmF5cykge1xuICAgICAgICByZXN1bHQuc2V0KGIsIGluZGV4KTtcbiAgICAgICAgaW5kZXggKz0gYi5ieXRlTGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBBIGNsYXNzIHRoYXQgYWJzdHJhY3RzIGEgcGlwZS1saWtlIFVpbnQ4QXJyYXkuXG4gKi9cbmV4cG9ydCBjbGFzcyBQaXBlQXJyYXlCdWZmZXIge1xuICAgIC8qKlxuICAgICAqIFNhdmUgYSBjaGVja3BvaW50IG9mIHRoZSByZWFkaW5nIHZpZXcgKGZvciBiYWNrdHJhY2tpbmcpXG4gICAgICovXG4gICAgc2F2ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZpZXc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc3RvcmUgYSBjaGVja3BvaW50IG9mIHRoZSByZWFkaW5nIHZpZXcgKGZvciBiYWNrdHJhY2tpbmcpXG4gICAgICogQHBhcmFtIGNoZWNrUG9pbnQgYSBwcmV2aW91c2x5IHNhdmVkIGNoZWNrcG9pbnRcbiAgICAgKi9cbiAgICByZXN0b3JlKGNoZWNrUG9pbnQpIHtcbiAgICAgICAgaWYgKCEoY2hlY2tQb2ludCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NoZWNrcG9pbnQgbXVzdCBiZSBhIFVpbnQ4QXJyYXknKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl92aWV3ID0gY2hlY2tQb2ludDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBhIHBpcGVcbiAgICAgKiBAcGFyYW0gYnVmZmVyIGFuIG9wdGlvbmFsIGJ1ZmZlciB0byBzdGFydCB3aXRoXG4gICAgICogQHBhcmFtIGxlbmd0aCBhbiBvcHRpb25hbCBhbW91bnQgb2YgYnl0ZXMgdG8gdXNlIGZvciB0aGUgbGVuZ3RoLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGJ1ZmZlciwgbGVuZ3RoID0gYnVmZmVyPy5ieXRlTGVuZ3RoIHx8IDApIHtcbiAgICAgICAgaWYgKGJ1ZmZlciAmJiAhKGJ1ZmZlciBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGJ1ZmZlciA9IHVpbnQ4RnJvbUJ1Zkxpa2UoYnVmZmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0J1ZmZlciBtdXN0IGJlIGEgVWludDhBcnJheScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChsZW5ndGggPCAwIHx8ICFOdW1iZXIuaXNJbnRlZ2VyKGxlbmd0aCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTGVuZ3RoIG11c3QgYmUgYSBub24tbmVnYXRpdmUgaW50ZWdlcicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChidWZmZXIgJiYgbGVuZ3RoID4gYnVmZmVyLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTGVuZ3RoIGNhbm5vdCBleGNlZWQgYnVmZmVyIGxlbmd0aCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2J1ZmZlciA9IGJ1ZmZlciB8fCBuZXcgVWludDhBcnJheSgwKTtcbiAgICAgICAgdGhpcy5fdmlldyA9IG5ldyBVaW50OEFycmF5KHRoaXMuX2J1ZmZlci5idWZmZXIsIDAsIGxlbmd0aCk7XG4gICAgfVxuICAgIGdldCBidWZmZXIoKSB7XG4gICAgICAgIC8vIFJldHVybiBhIGNvcHkgb2YgdGhlIGJ1ZmZlci5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZpZXcuc2xpY2UoKTtcbiAgICB9XG4gICAgZ2V0IGJ5dGVMZW5ndGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92aWV3LmJ5dGVMZW5ndGg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWQgYG51bWAgbnVtYmVyIG9mIGJ5dGVzIGZyb20gdGhlIGZyb250IG9mIHRoZSBwaXBlLlxuICAgICAqIEBwYXJhbSBudW0gVGhlIG51bWJlciBvZiBieXRlcyB0byByZWFkLlxuICAgICAqL1xuICAgIHJlYWQobnVtKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX3ZpZXcuc3ViYXJyYXkoMCwgbnVtKTtcbiAgICAgICAgdGhpcy5fdmlldyA9IHRoaXMuX3ZpZXcuc3ViYXJyYXkobnVtKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5zbGljZSgpO1xuICAgIH1cbiAgICByZWFkVWludDgoKSB7XG4gICAgICAgIGlmICh0aGlzLl92aWV3LmJ5dGVMZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fdmlld1swXTtcbiAgICAgICAgdGhpcy5fdmlldyA9IHRoaXMuX3ZpZXcuc3ViYXJyYXkoMSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlIGEgYnVmZmVyIHRvIHRoZSBlbmQgb2YgdGhlIHBpcGUuXG4gICAgICogQHBhcmFtIGJ1ZiBUaGUgYnl0ZXMgdG8gd3JpdGUuXG4gICAgICovXG4gICAgd3JpdGUoYnVmKSB7XG4gICAgICAgIGlmICghKGJ1ZiBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0J1ZmZlciBtdXN0IGJlIGEgVWludDhBcnJheScpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuX3ZpZXcuYnl0ZUxlbmd0aDtcbiAgICAgICAgaWYgKHRoaXMuX3ZpZXcuYnl0ZU9mZnNldCArIHRoaXMuX3ZpZXcuYnl0ZUxlbmd0aCArIGJ1Zi5ieXRlTGVuZ3RoID49IHRoaXMuX2J1ZmZlci5ieXRlTGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBBbGxvYyBncm93IHRoZSB2aWV3IHRvIGluY2x1ZGUgdGhlIG5ldyBieXRlcy5cbiAgICAgICAgICAgIHRoaXMuYWxsb2MoYnVmLmJ5dGVMZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSB2aWV3IHRvIGluY2x1ZGUgdGhlIG5ldyBieXRlcy5cbiAgICAgICAgICAgIHRoaXMuX3ZpZXcgPSBuZXcgVWludDhBcnJheSh0aGlzLl9idWZmZXIuYnVmZmVyLCB0aGlzLl92aWV3LmJ5dGVPZmZzZXQsIHRoaXMuX3ZpZXcuYnl0ZUxlbmd0aCArIGJ1Zi5ieXRlTGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl92aWV3LnNldChidWYsIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgb3Igbm90IHRoZXJlIGlzIG1vcmUgZGF0YSB0byByZWFkIGZyb20gdGhlIGJ1ZmZlclxuICAgICAqL1xuICAgIGdldCBlbmQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92aWV3LmJ5dGVMZW5ndGggPT09IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFsbG9jYXRlIGEgZml4ZWQgYW1vdW50IG9mIG1lbW9yeSBpbiB0aGUgYnVmZmVyLiBUaGlzIGRvZXMgbm90IGFmZmVjdCB0aGUgdmlldy5cbiAgICAgKiBAcGFyYW0gYW1vdW50IEEgbnVtYmVyIG9mIGJ5dGVzIHRvIGFkZCB0byB0aGUgYnVmZmVyLlxuICAgICAqL1xuICAgIGFsbG9jKGFtb3VudCkge1xuICAgICAgICBpZiAoYW1vdW50IDw9IDAgfHwgIU51bWJlci5pc0ludGVnZXIoYW1vdW50KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBbW91bnQgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXInKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgYSBsaXR0bGUgYml0IG9mIGV4cG9uZW50aWFsIGdyb3d0aC5cbiAgICAgICAgY29uc3QgYiA9IG5ldyBVaW50OEFycmF5KCgodGhpcy5fYnVmZmVyLmJ5dGVMZW5ndGggKyBhbW91bnQpICogMS4yKSB8IDApO1xuICAgICAgICBjb25zdCB2ID0gbmV3IFVpbnQ4QXJyYXkoYi5idWZmZXIsIDAsIHRoaXMuX3ZpZXcuYnl0ZUxlbmd0aCArIGFtb3VudCk7XG4gICAgICAgIHYuc2V0KHRoaXMuX3ZpZXcpO1xuICAgICAgICB0aGlzLl9idWZmZXIgPSBiO1xuICAgICAgICB0aGlzLl92aWV3ID0gdjtcbiAgICB9XG59XG4vKipcbiAqIFJldHVybnMgYSB0cnVlIFVpbnQ4QXJyYXkgZnJvbSBhbiBBcnJheUJ1ZmZlckxpa2Ugb2JqZWN0LlxuICogQHBhcmFtIGJ1Zkxpa2UgYSBidWZmZXItbGlrZSBvYmplY3RcbiAqIEByZXR1cm5zIFVpbnQ4QXJyYXlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVpbnQ4RnJvbUJ1Zkxpa2UoYnVmTGlrZSkge1xuICAgIGlmICghYnVmTGlrZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IGNhbm5vdCBiZSBudWxsIG9yIHVuZGVmaW5lZCcpO1xuICAgIH1cbiAgICBpZiAoYnVmTGlrZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIGJ1Zkxpa2U7XG4gICAgfVxuICAgIGlmIChidWZMaWtlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJ1Zkxpa2UpO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShidWZMaWtlKSkge1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnVmTGlrZSk7XG4gICAgfVxuICAgIGlmICgnYnVmZmVyJyBpbiBidWZMaWtlKSB7XG4gICAgICAgIHJldHVybiB1aW50OEZyb21CdWZMaWtlKGJ1Zkxpa2UuYnVmZmVyKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJ1Zkxpa2UpO1xufVxuLyoqXG4gKlxuICogQHBhcmFtIHUxIHVpbnQ4QXJyYXkgMVxuICogQHBhcmFtIHUyIHVpbnQ4QXJyYXkgMlxuICogQHJldHVybnMgbnVtYmVyIC0gbmVnYXRpdmUgaWYgdTEgPCB1MiwgcG9zaXRpdmUgaWYgdTEgPiB1MiwgMCBpZiB1MSA9PT0gdTJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXBhcmUodTEsIHUyKSB7XG4gICAgaWYgKHUxLmJ5dGVMZW5ndGggIT09IHUyLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHUxLmJ5dGVMZW5ndGggLSB1Mi5ieXRlTGVuZ3RoO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHUxLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh1MVtpXSAhPT0gdTJbaV0pIHtcbiAgICAgICAgICAgIHJldHVybiB1MVtpXSAtIHUyW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAwO1xufVxuLyoqXG4gKiBDaGVja3MgdHdvIHVpbnQ4QXJyYXlzIGZvciBlcXVhbGl0eS5cbiAqIEBwYXJhbSB1MSB1aW50OEFycmF5IDFcbiAqIEBwYXJhbSB1MiB1aW50OEFycmF5IDJcbiAqIEByZXR1cm5zIGJvb2xlYW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVpbnQ4RXF1YWxzKHUxLCB1Mikge1xuICAgIHJldHVybiBjb21wYXJlKHUxLCB1MikgPT09IDA7XG59XG4vKipcbiAqIEhlbHBlcnMgdG8gY29udmVydCBhIFVpbnQ4QXJyYXkgdG8gYSBEYXRhVmlldy5cbiAqIEBwYXJhbSB1aW50OCBVaW50OEFycmF5XG4gKiBAcmV0dXJucyBEYXRhVmlld1xuICovXG5leHBvcnQgZnVuY3Rpb24gdWludDhUb0RhdGFWaWV3KHVpbnQ4KSB7XG4gICAgaWYgKCEodWludDggaW5zdGFuY2VvZiBVaW50OEFycmF5KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IG11c3QgYmUgYSBVaW50OEFycmF5Jyk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgRGF0YVZpZXcodWludDguYnVmZmVyLCB1aW50OC5ieXRlT2Zmc2V0LCB1aW50OC5ieXRlTGVuZ3RoKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1ZmZlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../packages/sdk-js/node_modules/@dfinity/candid/lib/esm/utils/buffer.js\n");

/***/ }),

/***/ "(ssr)/../../packages/sdk-js/node_modules/@dfinity/candid/lib/esm/utils/hash.js":
/*!********************************************************************************!*\
  !*** ../../packages/sdk-js/node_modules/@dfinity/candid/lib/esm/utils/hash.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   idlLabelToId: () => (/* binding */ idlLabelToId)\n/* harmony export */ });\n/**\n * Hashes a string to a number. Algorithm can be found here:\n * https://caml.inria.fr/pub/papers/garrigue-polymorphic_variants-ml98.pdf\n * @param s - string to hash\n * @returns number representing hashed string\n */\nfunction idlHash(s) {\n    const utf8encoder = new TextEncoder();\n    const array = utf8encoder.encode(s);\n    let h = 0;\n    for (const c of array) {\n        h = (h * 223 + c) % 2 ** 32;\n    }\n    return h;\n}\n/**\n *\n * @param label string\n * @returns number representing hashed label\n */\nfunction idlLabelToId(label) {\n    if (/^_\\d+_$/.test(label) || /^_0x[0-9a-fA-F]+_$/.test(label)) {\n        const num = +label.slice(1, -1);\n        if (Number.isSafeInteger(num) && num >= 0 && num < 2 ** 32) {\n            return num;\n        }\n    }\n    return idlHash(label);\n}\n//# sourceMappingURL=hash.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vcGFja2FnZXMvc2RrLWpzL25vZGVfbW9kdWxlcy9AZGZpbml0eS9jYW5kaWQvbGliL2VzbS91dGlscy9oYXNoLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AaXF1YmUvb3BzLWNvbnNvbGUvLi4vLi4vcGFja2FnZXMvc2RrLWpzL25vZGVfbW9kdWxlcy9AZGZpbml0eS9jYW5kaWQvbGliL2VzbS91dGlscy9oYXNoLmpzPzU5NGIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBIYXNoZXMgYSBzdHJpbmcgdG8gYSBudW1iZXIuIEFsZ29yaXRobSBjYW4gYmUgZm91bmQgaGVyZTpcbiAqIGh0dHBzOi8vY2FtbC5pbnJpYS5mci9wdWIvcGFwZXJzL2dhcnJpZ3VlLXBvbHltb3JwaGljX3ZhcmlhbnRzLW1sOTgucGRmXG4gKiBAcGFyYW0gcyAtIHN0cmluZyB0byBoYXNoXG4gKiBAcmV0dXJucyBudW1iZXIgcmVwcmVzZW50aW5nIGhhc2hlZCBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gaWRsSGFzaChzKSB7XG4gICAgY29uc3QgdXRmOGVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgICBjb25zdCBhcnJheSA9IHV0ZjhlbmNvZGVyLmVuY29kZShzKTtcbiAgICBsZXQgaCA9IDA7XG4gICAgZm9yIChjb25zdCBjIG9mIGFycmF5KSB7XG4gICAgICAgIGggPSAoaCAqIDIyMyArIGMpICUgMiAqKiAzMjtcbiAgICB9XG4gICAgcmV0dXJuIGg7XG59XG4vKipcbiAqXG4gKiBAcGFyYW0gbGFiZWwgc3RyaW5nXG4gKiBAcmV0dXJucyBudW1iZXIgcmVwcmVzZW50aW5nIGhhc2hlZCBsYWJlbFxuICovXG5leHBvcnQgZnVuY3Rpb24gaWRsTGFiZWxUb0lkKGxhYmVsKSB7XG4gICAgaWYgKC9eX1xcZCtfJC8udGVzdChsYWJlbCkgfHwgL15fMHhbMC05YS1mQS1GXStfJC8udGVzdChsYWJlbCkpIHtcbiAgICAgICAgY29uc3QgbnVtID0gK2xhYmVsLnNsaWNlKDEsIC0xKTtcbiAgICAgICAgaWYgKE51bWJlci5pc1NhZmVJbnRlZ2VyKG51bSkgJiYgbnVtID49IDAgJiYgbnVtIDwgMiAqKiAzMikge1xuICAgICAgICAgICAgcmV0dXJuIG51bTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaWRsSGFzaChsYWJlbCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oYXNoLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../packages/sdk-js/node_modules/@dfinity/candid/lib/esm/utils/hash.js\n");

/***/ }),

/***/ "(ssr)/../../packages/sdk-js/node_modules/@dfinity/candid/lib/esm/utils/leb128.js":
/*!**********************************************************************************!*\
  !*** ../../packages/sdk-js/node_modules/@dfinity/candid/lib/esm/utils/leb128.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   lebDecode: () => (/* binding */ lebDecode),\n/* harmony export */   lebEncode: () => (/* binding */ lebEncode),\n/* harmony export */   readIntLE: () => (/* binding */ readIntLE),\n/* harmony export */   readUIntLE: () => (/* binding */ readUIntLE),\n/* harmony export */   safeRead: () => (/* binding */ safeRead),\n/* harmony export */   safeReadUint8: () => (/* binding */ safeReadUint8),\n/* harmony export */   slebDecode: () => (/* binding */ slebDecode),\n/* harmony export */   slebEncode: () => (/* binding */ slebEncode),\n/* harmony export */   writeIntLE: () => (/* binding */ writeIntLE),\n/* harmony export */   writeUIntLE: () => (/* binding */ writeUIntLE)\n/* harmony export */ });\n/* harmony import */ var _buffer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./buffer.js */ \"(ssr)/../../packages/sdk-js/node_modules/@dfinity/candid/lib/esm/utils/buffer.js\");\n/* harmony import */ var _bigint_math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bigint-math.js */ \"(ssr)/../../packages/sdk-js/node_modules/@dfinity/candid/lib/esm/utils/bigint-math.js\");\n// Note: this file uses buffer-pipe, which on Node only, uses the Node Buffer\n//       implementation, which isn't compatible with the NPM buffer package\n//       which we use everywhere else. This means that we have to transform\n//       one into the other, hence why every function that returns a Buffer\n//       actually return `new Buffer(pipe.buffer)`.\n// TODO: The best solution would be to have our own buffer type around\n//       Uint8Array which is standard.\n\n\nfunction eob() {\n    throw new Error('unexpected end of buffer');\n}\n/**\n *\n * @param pipe Pipe from buffer-pipe\n * @param num number\n * @returns Uint8Array\n */\nfunction safeRead(pipe, num) {\n    if (pipe.byteLength < num) {\n        eob();\n    }\n    return pipe.read(num);\n}\n/**\n * @param pipe - PipeArrayBuffer simulating buffer-pipe api\n */\nfunction safeReadUint8(pipe) {\n    const byte = pipe.readUint8();\n    if (byte === undefined) {\n        eob();\n    }\n    return byte;\n}\n/**\n * Encode a positive number (or bigint) into a Buffer. The number will be floored to the\n * nearest integer.\n * @param value The number to encode.\n */\nfunction lebEncode(value) {\n    if (typeof value === 'number') {\n        value = BigInt(value);\n    }\n    if (value < BigInt(0)) {\n        throw new Error('Cannot leb encode negative values.');\n    }\n    const byteLength = (value === BigInt(0) ? 0 : (0,_bigint_math_js__WEBPACK_IMPORTED_MODULE_0__.ilog2)(value)) + 1;\n    const pipe = new _buffer_js__WEBPACK_IMPORTED_MODULE_1__.PipeArrayBuffer(new Uint8Array(byteLength), 0);\n    while (true) {\n        const i = Number(value & BigInt(0x7f));\n        value /= BigInt(0x80);\n        if (value === BigInt(0)) {\n            pipe.write(new Uint8Array([i]));\n            break;\n        }\n        else {\n            pipe.write(new Uint8Array([i | 0x80]));\n        }\n    }\n    return pipe.buffer;\n}\n/**\n * Decode a leb encoded buffer into a bigint. The number will always be positive (does not\n * support signed leb encoding).\n * @param pipe A Buffer containing the leb encoded bits.\n */\nfunction lebDecode(pipe) {\n    let weight = BigInt(1);\n    let value = BigInt(0);\n    let byte;\n    do {\n        byte = safeReadUint8(pipe);\n        value += BigInt(byte & 0x7f).valueOf() * weight;\n        weight *= BigInt(128);\n    } while (byte >= 0x80);\n    return value;\n}\n/**\n * Encode a number (or bigint) into a Buffer, with support for negative numbers. The number\n * will be floored to the nearest integer.\n * @param value The number to encode.\n */\nfunction slebEncode(value) {\n    if (typeof value === 'number') {\n        value = BigInt(value);\n    }\n    const isNeg = value < BigInt(0);\n    if (isNeg) {\n        value = -value - BigInt(1);\n    }\n    const byteLength = (value === BigInt(0) ? 0 : (0,_bigint_math_js__WEBPACK_IMPORTED_MODULE_0__.ilog2)(value)) + 1;\n    const pipe = new _buffer_js__WEBPACK_IMPORTED_MODULE_1__.PipeArrayBuffer(new Uint8Array(byteLength), 0);\n    while (true) {\n        const i = getLowerBytes(value);\n        value /= BigInt(0x80);\n        // prettier-ignore\n        if ((isNeg && value === BigInt(0) && (i & 0x40) !== 0)\n            || (!isNeg && value === BigInt(0) && (i & 0x40) === 0)) {\n            pipe.write(new Uint8Array([i]));\n            break;\n        }\n        else {\n            pipe.write(new Uint8Array([i | 0x80]));\n        }\n    }\n    function getLowerBytes(num) {\n        const bytes = num % BigInt(0x80);\n        if (isNeg) {\n            // We swap the bits here again, and remove 1 to do two's complement.\n            return Number(BigInt(0x80) - bytes - BigInt(1));\n        }\n        else {\n            return Number(bytes);\n        }\n    }\n    return pipe.buffer;\n}\n/**\n * Decode a leb encoded buffer into a bigint. The number is decoded with support for negative\n * signed-leb encoding.\n * @param pipe A Buffer containing the signed leb encoded bits.\n */\nfunction slebDecode(pipe) {\n    // Get the size of the buffer, then cut a buffer of that size.\n    const pipeView = new Uint8Array(pipe.buffer);\n    let len = 0;\n    for (; len < pipeView.byteLength; len++) {\n        if (pipeView[len] < 0x80) {\n            // If it's a positive number, we reuse lebDecode.\n            if ((pipeView[len] & 0x40) === 0) {\n                return lebDecode(pipe);\n            }\n            break;\n        }\n    }\n    const bytes = new Uint8Array(safeRead(pipe, len + 1));\n    let value = BigInt(0);\n    for (let i = bytes.byteLength - 1; i >= 0; i--) {\n        value = value * BigInt(0x80) + BigInt(0x80 - (bytes[i] & 0x7f) - 1);\n    }\n    return -value - BigInt(1);\n}\n/**\n *\n * @param value bigint or number\n * @param byteLength number\n * @returns Uint8Array\n */\nfunction writeUIntLE(value, byteLength) {\n    if (BigInt(value) < BigInt(0)) {\n        throw new Error('Cannot write negative values.');\n    }\n    return writeIntLE(value, byteLength);\n}\n/**\n *\n * @param value - bigint or number\n * @param byteLength - number\n * @returns Uint8Array\n */\nfunction writeIntLE(value, byteLength) {\n    value = BigInt(value);\n    const pipe = new _buffer_js__WEBPACK_IMPORTED_MODULE_1__.PipeArrayBuffer(new Uint8Array(Math.min(1, byteLength)), 0);\n    let i = 0;\n    let mul = BigInt(256);\n    let sub = BigInt(0);\n    let byte = Number(value % mul);\n    pipe.write(new Uint8Array([byte]));\n    while (++i < byteLength) {\n        if (value < 0 && sub === BigInt(0) && byte !== 0) {\n            sub = BigInt(1);\n        }\n        byte = Number((value / mul - sub) % BigInt(256));\n        pipe.write(new Uint8Array([byte]));\n        mul *= BigInt(256);\n    }\n    return pipe.buffer;\n}\n/**\n *\n * @param pipe Pipe from buffer-pipe\n * @param byteLength number\n * @returns bigint\n */\nfunction readUIntLE(pipe, byteLength) {\n    if (byteLength <= 0 || !Number.isInteger(byteLength)) {\n        throw new Error('Byte length must be a positive integer');\n    }\n    let val = BigInt(safeReadUint8(pipe));\n    let mul = BigInt(1);\n    let i = 0;\n    while (++i < byteLength) {\n        mul *= BigInt(256);\n        const byte = BigInt(safeReadUint8(pipe));\n        val = val + mul * byte;\n    }\n    return val;\n}\n/**\n *\n * @param pipe Pipe from buffer-pipe\n * @param byteLength number\n * @returns bigint\n */\nfunction readIntLE(pipe, byteLength) {\n    if (byteLength <= 0 || !Number.isInteger(byteLength)) {\n        throw new Error('Byte length must be a positive integer');\n    }\n    let val = readUIntLE(pipe, byteLength);\n    const mul = BigInt(2) ** (BigInt(8) * BigInt(byteLength - 1) + BigInt(7));\n    if (val >= mul) {\n        val -= mul * BigInt(2);\n    }\n    return val;\n}\n//# sourceMappingURL=leb128.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vcGFja2FnZXMvc2RrLWpzL25vZGVfbW9kdWxlcy9AZGZpbml0eS9jYW5kaWQvbGliL2VzbS91dGlscy9sZWIxMjguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDc0Q7QUFDYjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxzREFBSztBQUN2RCxxQkFBcUIsdURBQUk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Qsc0RBQUs7QUFDdkQscUJBQXFCLHVEQUFJO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsV0FBVywyQkFBMkI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsUUFBUTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxxQkFBcUIsdURBQUk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BpcXViZS9vcHMtY29uc29sZS8uLi8uLi9wYWNrYWdlcy9zZGstanMvbm9kZV9tb2R1bGVzL0BkZmluaXR5L2NhbmRpZC9saWIvZXNtL3V0aWxzL2xlYjEyOC5qcz80ODQ3Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIE5vdGU6IHRoaXMgZmlsZSB1c2VzIGJ1ZmZlci1waXBlLCB3aGljaCBvbiBOb2RlIG9ubHksIHVzZXMgdGhlIE5vZGUgQnVmZmVyXG4vLyAgICAgICBpbXBsZW1lbnRhdGlvbiwgd2hpY2ggaXNuJ3QgY29tcGF0aWJsZSB3aXRoIHRoZSBOUE0gYnVmZmVyIHBhY2thZ2Vcbi8vICAgICAgIHdoaWNoIHdlIHVzZSBldmVyeXdoZXJlIGVsc2UuIFRoaXMgbWVhbnMgdGhhdCB3ZSBoYXZlIHRvIHRyYW5zZm9ybVxuLy8gICAgICAgb25lIGludG8gdGhlIG90aGVyLCBoZW5jZSB3aHkgZXZlcnkgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgQnVmZmVyXG4vLyAgICAgICBhY3R1YWxseSByZXR1cm4gYG5ldyBCdWZmZXIocGlwZS5idWZmZXIpYC5cbi8vIFRPRE86IFRoZSBiZXN0IHNvbHV0aW9uIHdvdWxkIGJlIHRvIGhhdmUgb3VyIG93biBidWZmZXIgdHlwZSBhcm91bmRcbi8vICAgICAgIFVpbnQ4QXJyYXkgd2hpY2ggaXMgc3RhbmRhcmQuXG5pbXBvcnQgeyBQaXBlQXJyYXlCdWZmZXIgYXMgUGlwZSB9IGZyb20gXCIuL2J1ZmZlci5qc1wiO1xuaW1wb3J0IHsgaWxvZzIgfSBmcm9tIFwiLi9iaWdpbnQtbWF0aC5qc1wiO1xuZnVuY3Rpb24gZW9iKCkge1xuICAgIHRocm93IG5ldyBFcnJvcigndW5leHBlY3RlZCBlbmQgb2YgYnVmZmVyJyk7XG59XG4vKipcbiAqXG4gKiBAcGFyYW0gcGlwZSBQaXBlIGZyb20gYnVmZmVyLXBpcGVcbiAqIEBwYXJhbSBudW0gbnVtYmVyXG4gKiBAcmV0dXJucyBVaW50OEFycmF5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzYWZlUmVhZChwaXBlLCBudW0pIHtcbiAgICBpZiAocGlwZS5ieXRlTGVuZ3RoIDwgbnVtKSB7XG4gICAgICAgIGVvYigpO1xuICAgIH1cbiAgICByZXR1cm4gcGlwZS5yZWFkKG51bSk7XG59XG4vKipcbiAqIEBwYXJhbSBwaXBlIC0gUGlwZUFycmF5QnVmZmVyIHNpbXVsYXRpbmcgYnVmZmVyLXBpcGUgYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzYWZlUmVhZFVpbnQ4KHBpcGUpIHtcbiAgICBjb25zdCBieXRlID0gcGlwZS5yZWFkVWludDgoKTtcbiAgICBpZiAoYnl0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGVvYigpO1xuICAgIH1cbiAgICByZXR1cm4gYnl0ZTtcbn1cbi8qKlxuICogRW5jb2RlIGEgcG9zaXRpdmUgbnVtYmVyIChvciBiaWdpbnQpIGludG8gYSBCdWZmZXIuIFRoZSBudW1iZXIgd2lsbCBiZSBmbG9vcmVkIHRvIHRoZVxuICogbmVhcmVzdCBpbnRlZ2VyLlxuICogQHBhcmFtIHZhbHVlIFRoZSBudW1iZXIgdG8gZW5jb2RlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbGViRW5jb2RlKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgdmFsdWUgPSBCaWdJbnQodmFsdWUpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPCBCaWdJbnQoMCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgbGViIGVuY29kZSBuZWdhdGl2ZSB2YWx1ZXMuJyk7XG4gICAgfVxuICAgIGNvbnN0IGJ5dGVMZW5ndGggPSAodmFsdWUgPT09IEJpZ0ludCgwKSA/IDAgOiBpbG9nMih2YWx1ZSkpICsgMTtcbiAgICBjb25zdCBwaXBlID0gbmV3IFBpcGUobmV3IFVpbnQ4QXJyYXkoYnl0ZUxlbmd0aCksIDApO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGNvbnN0IGkgPSBOdW1iZXIodmFsdWUgJiBCaWdJbnQoMHg3ZikpO1xuICAgICAgICB2YWx1ZSAvPSBCaWdJbnQoMHg4MCk7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gQmlnSW50KDApKSB7XG4gICAgICAgICAgICBwaXBlLndyaXRlKG5ldyBVaW50OEFycmF5KFtpXSkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwaXBlLndyaXRlKG5ldyBVaW50OEFycmF5KFtpIHwgMHg4MF0pKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGlwZS5idWZmZXI7XG59XG4vKipcbiAqIERlY29kZSBhIGxlYiBlbmNvZGVkIGJ1ZmZlciBpbnRvIGEgYmlnaW50LiBUaGUgbnVtYmVyIHdpbGwgYWx3YXlzIGJlIHBvc2l0aXZlIChkb2VzIG5vdFxuICogc3VwcG9ydCBzaWduZWQgbGViIGVuY29kaW5nKS5cbiAqIEBwYXJhbSBwaXBlIEEgQnVmZmVyIGNvbnRhaW5pbmcgdGhlIGxlYiBlbmNvZGVkIGJpdHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsZWJEZWNvZGUocGlwZSkge1xuICAgIGxldCB3ZWlnaHQgPSBCaWdJbnQoMSk7XG4gICAgbGV0IHZhbHVlID0gQmlnSW50KDApO1xuICAgIGxldCBieXRlO1xuICAgIGRvIHtcbiAgICAgICAgYnl0ZSA9IHNhZmVSZWFkVWludDgocGlwZSk7XG4gICAgICAgIHZhbHVlICs9IEJpZ0ludChieXRlICYgMHg3ZikudmFsdWVPZigpICogd2VpZ2h0O1xuICAgICAgICB3ZWlnaHQgKj0gQmlnSW50KDEyOCk7XG4gICAgfSB3aGlsZSAoYnl0ZSA+PSAweDgwKTtcbiAgICByZXR1cm4gdmFsdWU7XG59XG4vKipcbiAqIEVuY29kZSBhIG51bWJlciAob3IgYmlnaW50KSBpbnRvIGEgQnVmZmVyLCB3aXRoIHN1cHBvcnQgZm9yIG5lZ2F0aXZlIG51bWJlcnMuIFRoZSBudW1iZXJcbiAqIHdpbGwgYmUgZmxvb3JlZCB0byB0aGUgbmVhcmVzdCBpbnRlZ2VyLlxuICogQHBhcmFtIHZhbHVlIFRoZSBudW1iZXIgdG8gZW5jb2RlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2xlYkVuY29kZSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHZhbHVlID0gQmlnSW50KHZhbHVlKTtcbiAgICB9XG4gICAgY29uc3QgaXNOZWcgPSB2YWx1ZSA8IEJpZ0ludCgwKTtcbiAgICBpZiAoaXNOZWcpIHtcbiAgICAgICAgdmFsdWUgPSAtdmFsdWUgLSBCaWdJbnQoMSk7XG4gICAgfVxuICAgIGNvbnN0IGJ5dGVMZW5ndGggPSAodmFsdWUgPT09IEJpZ0ludCgwKSA/IDAgOiBpbG9nMih2YWx1ZSkpICsgMTtcbiAgICBjb25zdCBwaXBlID0gbmV3IFBpcGUobmV3IFVpbnQ4QXJyYXkoYnl0ZUxlbmd0aCksIDApO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGNvbnN0IGkgPSBnZXRMb3dlckJ5dGVzKHZhbHVlKTtcbiAgICAgICAgdmFsdWUgLz0gQmlnSW50KDB4ODApO1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgaWYgKChpc05lZyAmJiB2YWx1ZSA9PT0gQmlnSW50KDApICYmIChpICYgMHg0MCkgIT09IDApXG4gICAgICAgICAgICB8fCAoIWlzTmVnICYmIHZhbHVlID09PSBCaWdJbnQoMCkgJiYgKGkgJiAweDQwKSA9PT0gMCkpIHtcbiAgICAgICAgICAgIHBpcGUud3JpdGUobmV3IFVpbnQ4QXJyYXkoW2ldKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBpcGUud3JpdGUobmV3IFVpbnQ4QXJyYXkoW2kgfCAweDgwXSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldExvd2VyQnl0ZXMobnVtKSB7XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gbnVtICUgQmlnSW50KDB4ODApO1xuICAgICAgICBpZiAoaXNOZWcpIHtcbiAgICAgICAgICAgIC8vIFdlIHN3YXAgdGhlIGJpdHMgaGVyZSBhZ2FpbiwgYW5kIHJlbW92ZSAxIHRvIGRvIHR3bydzIGNvbXBsZW1lbnQuXG4gICAgICAgICAgICByZXR1cm4gTnVtYmVyKEJpZ0ludCgweDgwKSAtIGJ5dGVzIC0gQmlnSW50KDEpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBOdW1iZXIoYnl0ZXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwaXBlLmJ1ZmZlcjtcbn1cbi8qKlxuICogRGVjb2RlIGEgbGViIGVuY29kZWQgYnVmZmVyIGludG8gYSBiaWdpbnQuIFRoZSBudW1iZXIgaXMgZGVjb2RlZCB3aXRoIHN1cHBvcnQgZm9yIG5lZ2F0aXZlXG4gKiBzaWduZWQtbGViIGVuY29kaW5nLlxuICogQHBhcmFtIHBpcGUgQSBCdWZmZXIgY29udGFpbmluZyB0aGUgc2lnbmVkIGxlYiBlbmNvZGVkIGJpdHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzbGViRGVjb2RlKHBpcGUpIHtcbiAgICAvLyBHZXQgdGhlIHNpemUgb2YgdGhlIGJ1ZmZlciwgdGhlbiBjdXQgYSBidWZmZXIgb2YgdGhhdCBzaXplLlxuICAgIGNvbnN0IHBpcGVWaWV3ID0gbmV3IFVpbnQ4QXJyYXkocGlwZS5idWZmZXIpO1xuICAgIGxldCBsZW4gPSAwO1xuICAgIGZvciAoOyBsZW4gPCBwaXBlVmlldy5ieXRlTGVuZ3RoOyBsZW4rKykge1xuICAgICAgICBpZiAocGlwZVZpZXdbbGVuXSA8IDB4ODApIHtcbiAgICAgICAgICAgIC8vIElmIGl0J3MgYSBwb3NpdGl2ZSBudW1iZXIsIHdlIHJldXNlIGxlYkRlY29kZS5cbiAgICAgICAgICAgIGlmICgocGlwZVZpZXdbbGVuXSAmIDB4NDApID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlYkRlY29kZShwaXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoc2FmZVJlYWQocGlwZSwgbGVuICsgMSkpO1xuICAgIGxldCB2YWx1ZSA9IEJpZ0ludCgwKTtcbiAgICBmb3IgKGxldCBpID0gYnl0ZXMuYnl0ZUxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUgKiBCaWdJbnQoMHg4MCkgKyBCaWdJbnQoMHg4MCAtIChieXRlc1tpXSAmIDB4N2YpIC0gMSk7XG4gICAgfVxuICAgIHJldHVybiAtdmFsdWUgLSBCaWdJbnQoMSk7XG59XG4vKipcbiAqXG4gKiBAcGFyYW0gdmFsdWUgYmlnaW50IG9yIG51bWJlclxuICogQHBhcmFtIGJ5dGVMZW5ndGggbnVtYmVyXG4gKiBAcmV0dXJucyBVaW50OEFycmF5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB3cml0ZVVJbnRMRSh2YWx1ZSwgYnl0ZUxlbmd0aCkge1xuICAgIGlmIChCaWdJbnQodmFsdWUpIDwgQmlnSW50KDApKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHdyaXRlIG5lZ2F0aXZlIHZhbHVlcy4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHdyaXRlSW50TEUodmFsdWUsIGJ5dGVMZW5ndGgpO1xufVxuLyoqXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gYmlnaW50IG9yIG51bWJlclxuICogQHBhcmFtIGJ5dGVMZW5ndGggLSBudW1iZXJcbiAqIEByZXR1cm5zIFVpbnQ4QXJyYXlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdyaXRlSW50TEUodmFsdWUsIGJ5dGVMZW5ndGgpIHtcbiAgICB2YWx1ZSA9IEJpZ0ludCh2YWx1ZSk7XG4gICAgY29uc3QgcGlwZSA9IG5ldyBQaXBlKG5ldyBVaW50OEFycmF5KE1hdGgubWluKDEsIGJ5dGVMZW5ndGgpKSwgMCk7XG4gICAgbGV0IGkgPSAwO1xuICAgIGxldCBtdWwgPSBCaWdJbnQoMjU2KTtcbiAgICBsZXQgc3ViID0gQmlnSW50KDApO1xuICAgIGxldCBieXRlID0gTnVtYmVyKHZhbHVlICUgbXVsKTtcbiAgICBwaXBlLndyaXRlKG5ldyBVaW50OEFycmF5KFtieXRlXSkpO1xuICAgIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoKSB7XG4gICAgICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSBCaWdJbnQoMCkgJiYgYnl0ZSAhPT0gMCkge1xuICAgICAgICAgICAgc3ViID0gQmlnSW50KDEpO1xuICAgICAgICB9XG4gICAgICAgIGJ5dGUgPSBOdW1iZXIoKHZhbHVlIC8gbXVsIC0gc3ViKSAlIEJpZ0ludCgyNTYpKTtcbiAgICAgICAgcGlwZS53cml0ZShuZXcgVWludDhBcnJheShbYnl0ZV0pKTtcbiAgICAgICAgbXVsICo9IEJpZ0ludCgyNTYpO1xuICAgIH1cbiAgICByZXR1cm4gcGlwZS5idWZmZXI7XG59XG4vKipcbiAqXG4gKiBAcGFyYW0gcGlwZSBQaXBlIGZyb20gYnVmZmVyLXBpcGVcbiAqIEBwYXJhbSBieXRlTGVuZ3RoIG51bWJlclxuICogQHJldHVybnMgYmlnaW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZWFkVUludExFKHBpcGUsIGJ5dGVMZW5ndGgpIHtcbiAgICBpZiAoYnl0ZUxlbmd0aCA8PSAwIHx8ICFOdW1iZXIuaXNJbnRlZ2VyKGJ5dGVMZW5ndGgpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQnl0ZSBsZW5ndGggbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXInKTtcbiAgICB9XG4gICAgbGV0IHZhbCA9IEJpZ0ludChzYWZlUmVhZFVpbnQ4KHBpcGUpKTtcbiAgICBsZXQgbXVsID0gQmlnSW50KDEpO1xuICAgIGxldCBpID0gMDtcbiAgICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCkge1xuICAgICAgICBtdWwgKj0gQmlnSW50KDI1Nik7XG4gICAgICAgIGNvbnN0IGJ5dGUgPSBCaWdJbnQoc2FmZVJlYWRVaW50OChwaXBlKSk7XG4gICAgICAgIHZhbCA9IHZhbCArIG11bCAqIGJ5dGU7XG4gICAgfVxuICAgIHJldHVybiB2YWw7XG59XG4vKipcbiAqXG4gKiBAcGFyYW0gcGlwZSBQaXBlIGZyb20gYnVmZmVyLXBpcGVcbiAqIEBwYXJhbSBieXRlTGVuZ3RoIG51bWJlclxuICogQHJldHVybnMgYmlnaW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZWFkSW50TEUocGlwZSwgYnl0ZUxlbmd0aCkge1xuICAgIGlmIChieXRlTGVuZ3RoIDw9IDAgfHwgIU51bWJlci5pc0ludGVnZXIoYnl0ZUxlbmd0aCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCeXRlIGxlbmd0aCBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlcicpO1xuICAgIH1cbiAgICBsZXQgdmFsID0gcmVhZFVJbnRMRShwaXBlLCBieXRlTGVuZ3RoKTtcbiAgICBjb25zdCBtdWwgPSBCaWdJbnQoMikgKiogKEJpZ0ludCg4KSAqIEJpZ0ludChieXRlTGVuZ3RoIC0gMSkgKyBCaWdJbnQoNykpO1xuICAgIGlmICh2YWwgPj0gbXVsKSB7XG4gICAgICAgIHZhbCAtPSBtdWwgKiBCaWdJbnQoMik7XG4gICAgfVxuICAgIHJldHVybiB2YWw7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sZWIxMjguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../packages/sdk-js/node_modules/@dfinity/candid/lib/esm/utils/leb128.js\n");

/***/ }),

/***/ "(ssr)/../../packages/sdk-js/node_modules/@dfinity/cbor/dist/cbor.mjs":
/*!**********************************************************************!*\
  !*** ../../packages/sdk-js/node_modules/@dfinity/cbor/dist/cbor.mjs ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DecodingError: () => (/* binding */ w),\n/* harmony export */   EncodingError: () => (/* binding */ x),\n/* harmony export */   decode: () => (/* binding */ ut),\n/* harmony export */   encode: () => (/* binding */ rt),\n/* harmony export */   encodeWithSelfDescribedTag: () => (/* binding */ dt)\n/* harmony export */ });\nclass w extends Error {\n  constructor(n) {\n    super(n), this.name = \"DecodingError\";\n  }\n}\nconst m = 55799, L = Symbol(\"CBOR_STOP_CODE\");\nvar g = /* @__PURE__ */ ((t) => (t[t.False = 20] = \"False\", t[t.True = 21] = \"True\", t[t.Null = 22] = \"Null\", t[t.Undefined = 23] = \"Undefined\", t[t.Break = 31] = \"Break\", t))(g || {}), c = /* @__PURE__ */ ((t) => (t[t.UnsignedInteger = 0] = \"UnsignedInteger\", t[t.NegativeInteger = 1] = \"NegativeInteger\", t[t.ByteString = 2] = \"ByteString\", t[t.TextString = 3] = \"TextString\", t[t.Array = 4] = \"Array\", t[t.Map = 5] = \"Map\", t[t.Tag = 6] = \"Tag\", t[t.Simple = 7] = \"Simple\", t))(c || {});\nconst z = 23, Y = 255, G = 65535, P = 4294967295, H = BigInt(\"0xffffffffffffffff\");\nvar d = /* @__PURE__ */ ((t) => (t[t.Value = 23] = \"Value\", t[t.OneByte = 24] = \"OneByte\", t[t.TwoBytes = 25] = \"TwoBytes\", t[t.FourBytes = 26] = \"FourBytes\", t[t.EightBytes = 27] = \"EightBytes\", t[t.Indefinite = 31] = \"Indefinite\", t))(d || {});\nconst h = !1;\nfunction W(t) {\n  return t == null;\n}\nfunction R(t, n) {\n  const e = new Uint8Array(n);\n  return e.set(t), e;\n}\nconst K = new TextDecoder();\nfunction Z(t) {\n  return (t & 224) >> 5;\n}\nfunction q(t) {\n  return t & 31;\n}\nlet A = new Uint8Array(), y, a = 0;\nfunction ut(t, n) {\n  A = t, a = 0;\n  const e = B(n);\n  return (n == null ? void 0 : n(e)) ?? e;\n}\nfunction B(t) {\n  const [n, e] = N();\n  switch (n) {\n    case c.UnsignedInteger:\n      return E(e);\n    case c.NegativeInteger:\n      return j(e);\n    case c.ByteString:\n      return $(e);\n    case c.TextString:\n      return F(e);\n    case c.Array:\n      return J(e, t);\n    case c.Map:\n      return b(e, t);\n    case c.Tag:\n      return M(e, t);\n    case c.Simple:\n      return Q(e);\n  }\n  throw new w(`Unsupported major type: ${n}`);\n}\nfunction N() {\n  const t = A.at(a);\n  if (W(t))\n    throw new w(\"Provided CBOR data is empty\");\n  const n = Z(t), e = q(t);\n  return a++, [n, e];\n}\nfunction J(t, n) {\n  const e = E(t);\n  if (e === 1 / 0) {\n    const u = [];\n    let f = B(n);\n    for (; f !== L; )\n      u.push((n == null ? void 0 : n(f)) ?? f), f = B(n);\n    return u;\n  }\n  const i = new Array(e);\n  for (let u = 0; u < e; u++) {\n    const f = B(n);\n    i[u] = (n == null ? void 0 : n(f)) ?? f;\n  }\n  return i;\n}\nfunction Q(t) {\n  switch (t) {\n    case g.False:\n      return !1;\n    case g.True:\n      return !0;\n    case g.Null:\n      return null;\n    case g.Undefined:\n      return;\n    case g.Break:\n      return L;\n  }\n  throw new w(`Unrecognized simple type: ${t.toString(2)}`);\n}\nfunction b(t, n) {\n  const e = E(t), i = {};\n  if (e === 1 / 0) {\n    let [u, f] = N();\n    for (; u !== c.Simple && f !== g.Break; ) {\n      const l = F(f), U = B(n);\n      i[l] = (n == null ? void 0 : n(U, l)) ?? U, [u, f] = N();\n    }\n    return i;\n  }\n  for (let u = 0; u < e; u++) {\n    const [f, l] = N();\n    if (f !== c.TextString)\n      throw new w(\"Map keys must be text strings\");\n    const U = F(l), D = B(n);\n    i[U] = (n == null ? void 0 : n(D, U)) ?? D;\n  }\n  return i;\n}\nfunction E(t) {\n  if (t <= d.Value)\n    return t;\n  switch (y = new DataView(A.buffer, A.byteOffset + a), t) {\n    case d.OneByte:\n      return a++, y.getUint8(0);\n    case d.TwoBytes:\n      return a += 2, y.getUint16(0, h);\n    case d.FourBytes:\n      return a += 4, y.getUint32(0, h);\n    case d.EightBytes:\n      return a += 8, y.getBigUint64(0, h);\n    case d.Indefinite:\n      return 1 / 0;\n    default:\n      throw new w(`Unsupported integer info: ${t.toString(2)}`);\n  }\n}\nfunction j(t) {\n  const n = E(t);\n  return typeof n == \"number\" ? -1 - n : -1n - n;\n}\nfunction $(t) {\n  const n = E(t);\n  if (n > Number.MAX_SAFE_INTEGER)\n    throw new w(\"Byte length is too large\");\n  const e = Number(n);\n  return a += e, A.slice(a - e, a);\n}\nfunction F(t) {\n  const n = $(t);\n  return K.decode(n);\n}\nfunction M(t, n) {\n  const e = E(t);\n  if (e === m)\n    return B(n);\n  throw new w(`Unsupported tag: ${e}.`);\n}\nclass x extends Error {\n  constructor(n) {\n    super(n), this.name = \"SerializationError\";\n  }\n}\nconst p = 2 * 1024, C = 100, v = new TextEncoder();\nfunction S(t) {\n  return t << 5;\n}\nlet o = new Uint8Array(p), r = new DataView(o.buffer), s = 0, O = [];\nfunction rt(t, n) {\n  s = 0;\n  const e = (n == null ? void 0 : n(t)) ?? t;\n  return _(e, n), o.slice(0, s);\n}\nfunction dt(t, n) {\n  s = 0;\n  const e = (n == null ? void 0 : n(t)) ?? t;\n  return it(m, e, n), o.slice(0, s);\n}\nfunction _(t, n) {\n  if (s > o.length - C && (o = R(o, o.length * 2), r = new DataView(o.buffer)), t === !1 || t === !0 || t === null || t === void 0) {\n    et(t);\n    return;\n  }\n  if (typeof t == \"number\" || typeof t == \"bigint\") {\n    ft(t);\n    return;\n  }\n  if (typeof t == \"string\") {\n    X(t);\n    return;\n  }\n  if (t instanceof Uint8Array) {\n    V(t);\n    return;\n  }\n  if (t instanceof ArrayBuffer) {\n    V(new Uint8Array(t));\n    return;\n  }\n  if (Array.isArray(t)) {\n    tt(t, n);\n    return;\n  }\n  if (typeof t == \"object\") {\n    nt(t, n);\n    return;\n  }\n  throw new x(`Unsupported type: ${typeof t}`);\n}\nfunction tt(t, n) {\n  I(c.Array, t.length), t.forEach((e, i) => {\n    _((n == null ? void 0 : n(e, i.toString())) ?? e, n);\n  });\n}\nfunction nt(t, n) {\n  O = Object.entries(t), I(c.Map, O.length), O.forEach(([e, i]) => {\n    X(e), _((n == null ? void 0 : n(i, e)) ?? i, n);\n  });\n}\nfunction I(t, n) {\n  if (n <= z) {\n    r.setUint8(\n      s++,\n      S(t) | Number(n)\n    );\n    return;\n  }\n  if (n <= Y) {\n    r.setUint8(\n      s++,\n      S(t) | d.OneByte\n    ), r.setUint8(s, Number(n)), s += 1;\n    return;\n  }\n  if (n <= G) {\n    r.setUint8(\n      s++,\n      S(t) | d.TwoBytes\n    ), r.setUint16(s, Number(n), h), s += 2;\n    return;\n  }\n  if (n <= P) {\n    r.setUint8(\n      s++,\n      S(t) | d.FourBytes\n    ), r.setUint32(s, Number(n), h), s += 4;\n    return;\n  }\n  if (n <= H) {\n    r.setUint8(\n      s++,\n      S(t) | d.EightBytes\n    ), r.setBigUint64(s, BigInt(n), h), s += 8;\n    return;\n  }\n  throw new x(`Value too large to encode: ${n}`);\n}\nfunction et(t) {\n  I(c.Simple, st(t));\n}\nfunction st(t) {\n  if (t === !1)\n    return g.False;\n  if (t === !0)\n    return g.True;\n  if (t === null)\n    return g.Null;\n  if (t === void 0)\n    return g.Undefined;\n  throw new x(`Unrecognized simple value: ${t.toString()}`);\n}\nfunction k(t, n) {\n  I(t, n.length), s > o.length - n.length && (o = R(o, o.length + n.length), r = new DataView(o.buffer)), o.set(n, s), s += n.length;\n}\nfunction T(t, n) {\n  I(t, n);\n}\nfunction ct(t) {\n  T(c.UnsignedInteger, t);\n}\nfunction ot(t) {\n  T(\n    c.NegativeInteger,\n    typeof t == \"bigint\" ? -1n - t : -1 - t\n  );\n}\nfunction ft(t) {\n  t >= 0 ? ct(t) : ot(t);\n}\nfunction X(t) {\n  k(c.TextString, v.encode(t));\n}\nfunction V(t) {\n  k(c.ByteString, t);\n}\nfunction it(t, n, e) {\n  I(c.Tag, t), _(n, e);\n}\n\n//# sourceMappingURL=cbor.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vcGFja2FnZXMvc2RrLWpzL25vZGVfbW9kdWxlcy9AZGZpbml0eS9jYm9yL2Rpc3QvY2Jvci5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1TEFBdUwsaVRBQWlUO0FBQ3hlO0FBQ0Esb1BBQW9QO0FBQ3BQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsRUFBRTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxjQUFjO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlDQUFpQztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxjQUFjO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxFQUFFO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsU0FBUztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxFQUFFO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLGFBQWE7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFPRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGlxdWJlL29wcy1jb25zb2xlLy4uLy4uL3BhY2thZ2VzL3Nkay1qcy9ub2RlX21vZHVsZXMvQGRmaW5pdHkvY2Jvci9kaXN0L2Nib3IubWpzP2M5YWYiXSwic291cmNlc0NvbnRlbnQiOlsiY2xhc3MgdyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3Iobikge1xuICAgIHN1cGVyKG4pLCB0aGlzLm5hbWUgPSBcIkRlY29kaW5nRXJyb3JcIjtcbiAgfVxufVxuY29uc3QgbSA9IDU1Nzk5LCBMID0gU3ltYm9sKFwiQ0JPUl9TVE9QX0NPREVcIik7XG52YXIgZyA9IC8qIEBfX1BVUkVfXyAqLyAoKHQpID0+ICh0W3QuRmFsc2UgPSAyMF0gPSBcIkZhbHNlXCIsIHRbdC5UcnVlID0gMjFdID0gXCJUcnVlXCIsIHRbdC5OdWxsID0gMjJdID0gXCJOdWxsXCIsIHRbdC5VbmRlZmluZWQgPSAyM10gPSBcIlVuZGVmaW5lZFwiLCB0W3QuQnJlYWsgPSAzMV0gPSBcIkJyZWFrXCIsIHQpKShnIHx8IHt9KSwgYyA9IC8qIEBfX1BVUkVfXyAqLyAoKHQpID0+ICh0W3QuVW5zaWduZWRJbnRlZ2VyID0gMF0gPSBcIlVuc2lnbmVkSW50ZWdlclwiLCB0W3QuTmVnYXRpdmVJbnRlZ2VyID0gMV0gPSBcIk5lZ2F0aXZlSW50ZWdlclwiLCB0W3QuQnl0ZVN0cmluZyA9IDJdID0gXCJCeXRlU3RyaW5nXCIsIHRbdC5UZXh0U3RyaW5nID0gM10gPSBcIlRleHRTdHJpbmdcIiwgdFt0LkFycmF5ID0gNF0gPSBcIkFycmF5XCIsIHRbdC5NYXAgPSA1XSA9IFwiTWFwXCIsIHRbdC5UYWcgPSA2XSA9IFwiVGFnXCIsIHRbdC5TaW1wbGUgPSA3XSA9IFwiU2ltcGxlXCIsIHQpKShjIHx8IHt9KTtcbmNvbnN0IHogPSAyMywgWSA9IDI1NSwgRyA9IDY1NTM1LCBQID0gNDI5NDk2NzI5NSwgSCA9IEJpZ0ludChcIjB4ZmZmZmZmZmZmZmZmZmZmZlwiKTtcbnZhciBkID0gLyogQF9fUFVSRV9fICovICgodCkgPT4gKHRbdC5WYWx1ZSA9IDIzXSA9IFwiVmFsdWVcIiwgdFt0Lk9uZUJ5dGUgPSAyNF0gPSBcIk9uZUJ5dGVcIiwgdFt0LlR3b0J5dGVzID0gMjVdID0gXCJUd29CeXRlc1wiLCB0W3QuRm91ckJ5dGVzID0gMjZdID0gXCJGb3VyQnl0ZXNcIiwgdFt0LkVpZ2h0Qnl0ZXMgPSAyN10gPSBcIkVpZ2h0Qnl0ZXNcIiwgdFt0LkluZGVmaW5pdGUgPSAzMV0gPSBcIkluZGVmaW5pdGVcIiwgdCkpKGQgfHwge30pO1xuY29uc3QgaCA9ICExO1xuZnVuY3Rpb24gVyh0KSB7XG4gIHJldHVybiB0ID09IG51bGw7XG59XG5mdW5jdGlvbiBSKHQsIG4pIHtcbiAgY29uc3QgZSA9IG5ldyBVaW50OEFycmF5KG4pO1xuICByZXR1cm4gZS5zZXQodCksIGU7XG59XG5jb25zdCBLID0gbmV3IFRleHREZWNvZGVyKCk7XG5mdW5jdGlvbiBaKHQpIHtcbiAgcmV0dXJuICh0ICYgMjI0KSA+PiA1O1xufVxuZnVuY3Rpb24gcSh0KSB7XG4gIHJldHVybiB0ICYgMzE7XG59XG5sZXQgQSA9IG5ldyBVaW50OEFycmF5KCksIHksIGEgPSAwO1xuZnVuY3Rpb24gdXQodCwgbikge1xuICBBID0gdCwgYSA9IDA7XG4gIGNvbnN0IGUgPSBCKG4pO1xuICByZXR1cm4gKG4gPT0gbnVsbCA/IHZvaWQgMCA6IG4oZSkpID8/IGU7XG59XG5mdW5jdGlvbiBCKHQpIHtcbiAgY29uc3QgW24sIGVdID0gTigpO1xuICBzd2l0Y2ggKG4pIHtcbiAgICBjYXNlIGMuVW5zaWduZWRJbnRlZ2VyOlxuICAgICAgcmV0dXJuIEUoZSk7XG4gICAgY2FzZSBjLk5lZ2F0aXZlSW50ZWdlcjpcbiAgICAgIHJldHVybiBqKGUpO1xuICAgIGNhc2UgYy5CeXRlU3RyaW5nOlxuICAgICAgcmV0dXJuICQoZSk7XG4gICAgY2FzZSBjLlRleHRTdHJpbmc6XG4gICAgICByZXR1cm4gRihlKTtcbiAgICBjYXNlIGMuQXJyYXk6XG4gICAgICByZXR1cm4gSihlLCB0KTtcbiAgICBjYXNlIGMuTWFwOlxuICAgICAgcmV0dXJuIGIoZSwgdCk7XG4gICAgY2FzZSBjLlRhZzpcbiAgICAgIHJldHVybiBNKGUsIHQpO1xuICAgIGNhc2UgYy5TaW1wbGU6XG4gICAgICByZXR1cm4gUShlKTtcbiAgfVxuICB0aHJvdyBuZXcgdyhgVW5zdXBwb3J0ZWQgbWFqb3IgdHlwZTogJHtufWApO1xufVxuZnVuY3Rpb24gTigpIHtcbiAgY29uc3QgdCA9IEEuYXQoYSk7XG4gIGlmIChXKHQpKVxuICAgIHRocm93IG5ldyB3KFwiUHJvdmlkZWQgQ0JPUiBkYXRhIGlzIGVtcHR5XCIpO1xuICBjb25zdCBuID0gWih0KSwgZSA9IHEodCk7XG4gIHJldHVybiBhKyssIFtuLCBlXTtcbn1cbmZ1bmN0aW9uIEoodCwgbikge1xuICBjb25zdCBlID0gRSh0KTtcbiAgaWYgKGUgPT09IDEgLyAwKSB7XG4gICAgY29uc3QgdSA9IFtdO1xuICAgIGxldCBmID0gQihuKTtcbiAgICBmb3IgKDsgZiAhPT0gTDsgKVxuICAgICAgdS5wdXNoKChuID09IG51bGwgPyB2b2lkIDAgOiBuKGYpKSA/PyBmKSwgZiA9IEIobik7XG4gICAgcmV0dXJuIHU7XG4gIH1cbiAgY29uc3QgaSA9IG5ldyBBcnJheShlKTtcbiAgZm9yIChsZXQgdSA9IDA7IHUgPCBlOyB1KyspIHtcbiAgICBjb25zdCBmID0gQihuKTtcbiAgICBpW3VdID0gKG4gPT0gbnVsbCA/IHZvaWQgMCA6IG4oZikpID8/IGY7XG4gIH1cbiAgcmV0dXJuIGk7XG59XG5mdW5jdGlvbiBRKHQpIHtcbiAgc3dpdGNoICh0KSB7XG4gICAgY2FzZSBnLkZhbHNlOlxuICAgICAgcmV0dXJuICExO1xuICAgIGNhc2UgZy5UcnVlOlxuICAgICAgcmV0dXJuICEwO1xuICAgIGNhc2UgZy5OdWxsOlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgY2FzZSBnLlVuZGVmaW5lZDpcbiAgICAgIHJldHVybjtcbiAgICBjYXNlIGcuQnJlYWs6XG4gICAgICByZXR1cm4gTDtcbiAgfVxuICB0aHJvdyBuZXcgdyhgVW5yZWNvZ25pemVkIHNpbXBsZSB0eXBlOiAke3QudG9TdHJpbmcoMil9YCk7XG59XG5mdW5jdGlvbiBiKHQsIG4pIHtcbiAgY29uc3QgZSA9IEUodCksIGkgPSB7fTtcbiAgaWYgKGUgPT09IDEgLyAwKSB7XG4gICAgbGV0IFt1LCBmXSA9IE4oKTtcbiAgICBmb3IgKDsgdSAhPT0gYy5TaW1wbGUgJiYgZiAhPT0gZy5CcmVhazsgKSB7XG4gICAgICBjb25zdCBsID0gRihmKSwgVSA9IEIobik7XG4gICAgICBpW2xdID0gKG4gPT0gbnVsbCA/IHZvaWQgMCA6IG4oVSwgbCkpID8/IFUsIFt1LCBmXSA9IE4oKTtcbiAgICB9XG4gICAgcmV0dXJuIGk7XG4gIH1cbiAgZm9yIChsZXQgdSA9IDA7IHUgPCBlOyB1KyspIHtcbiAgICBjb25zdCBbZiwgbF0gPSBOKCk7XG4gICAgaWYgKGYgIT09IGMuVGV4dFN0cmluZylcbiAgICAgIHRocm93IG5ldyB3KFwiTWFwIGtleXMgbXVzdCBiZSB0ZXh0IHN0cmluZ3NcIik7XG4gICAgY29uc3QgVSA9IEYobCksIEQgPSBCKG4pO1xuICAgIGlbVV0gPSAobiA9PSBudWxsID8gdm9pZCAwIDogbihELCBVKSkgPz8gRDtcbiAgfVxuICByZXR1cm4gaTtcbn1cbmZ1bmN0aW9uIEUodCkge1xuICBpZiAodCA8PSBkLlZhbHVlKVxuICAgIHJldHVybiB0O1xuICBzd2l0Y2ggKHkgPSBuZXcgRGF0YVZpZXcoQS5idWZmZXIsIEEuYnl0ZU9mZnNldCArIGEpLCB0KSB7XG4gICAgY2FzZSBkLk9uZUJ5dGU6XG4gICAgICByZXR1cm4gYSsrLCB5LmdldFVpbnQ4KDApO1xuICAgIGNhc2UgZC5Ud29CeXRlczpcbiAgICAgIHJldHVybiBhICs9IDIsIHkuZ2V0VWludDE2KDAsIGgpO1xuICAgIGNhc2UgZC5Gb3VyQnl0ZXM6XG4gICAgICByZXR1cm4gYSArPSA0LCB5LmdldFVpbnQzMigwLCBoKTtcbiAgICBjYXNlIGQuRWlnaHRCeXRlczpcbiAgICAgIHJldHVybiBhICs9IDgsIHkuZ2V0QmlnVWludDY0KDAsIGgpO1xuICAgIGNhc2UgZC5JbmRlZmluaXRlOlxuICAgICAgcmV0dXJuIDEgLyAwO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgdyhgVW5zdXBwb3J0ZWQgaW50ZWdlciBpbmZvOiAke3QudG9TdHJpbmcoMil9YCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGoodCkge1xuICBjb25zdCBuID0gRSh0KTtcbiAgcmV0dXJuIHR5cGVvZiBuID09IFwibnVtYmVyXCIgPyAtMSAtIG4gOiAtMW4gLSBuO1xufVxuZnVuY3Rpb24gJCh0KSB7XG4gIGNvbnN0IG4gPSBFKHQpO1xuICBpZiAobiA+IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKVxuICAgIHRocm93IG5ldyB3KFwiQnl0ZSBsZW5ndGggaXMgdG9vIGxhcmdlXCIpO1xuICBjb25zdCBlID0gTnVtYmVyKG4pO1xuICByZXR1cm4gYSArPSBlLCBBLnNsaWNlKGEgLSBlLCBhKTtcbn1cbmZ1bmN0aW9uIEYodCkge1xuICBjb25zdCBuID0gJCh0KTtcbiAgcmV0dXJuIEsuZGVjb2RlKG4pO1xufVxuZnVuY3Rpb24gTSh0LCBuKSB7XG4gIGNvbnN0IGUgPSBFKHQpO1xuICBpZiAoZSA9PT0gbSlcbiAgICByZXR1cm4gQihuKTtcbiAgdGhyb3cgbmV3IHcoYFVuc3VwcG9ydGVkIHRhZzogJHtlfS5gKTtcbn1cbmNsYXNzIHggZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG4pIHtcbiAgICBzdXBlcihuKSwgdGhpcy5uYW1lID0gXCJTZXJpYWxpemF0aW9uRXJyb3JcIjtcbiAgfVxufVxuY29uc3QgcCA9IDIgKiAxMDI0LCBDID0gMTAwLCB2ID0gbmV3IFRleHRFbmNvZGVyKCk7XG5mdW5jdGlvbiBTKHQpIHtcbiAgcmV0dXJuIHQgPDwgNTtcbn1cbmxldCBvID0gbmV3IFVpbnQ4QXJyYXkocCksIHIgPSBuZXcgRGF0YVZpZXcoby5idWZmZXIpLCBzID0gMCwgTyA9IFtdO1xuZnVuY3Rpb24gcnQodCwgbikge1xuICBzID0gMDtcbiAgY29uc3QgZSA9IChuID09IG51bGwgPyB2b2lkIDAgOiBuKHQpKSA/PyB0O1xuICByZXR1cm4gXyhlLCBuKSwgby5zbGljZSgwLCBzKTtcbn1cbmZ1bmN0aW9uIGR0KHQsIG4pIHtcbiAgcyA9IDA7XG4gIGNvbnN0IGUgPSAobiA9PSBudWxsID8gdm9pZCAwIDogbih0KSkgPz8gdDtcbiAgcmV0dXJuIGl0KG0sIGUsIG4pLCBvLnNsaWNlKDAsIHMpO1xufVxuZnVuY3Rpb24gXyh0LCBuKSB7XG4gIGlmIChzID4gby5sZW5ndGggLSBDICYmIChvID0gUihvLCBvLmxlbmd0aCAqIDIpLCByID0gbmV3IERhdGFWaWV3KG8uYnVmZmVyKSksIHQgPT09ICExIHx8IHQgPT09ICEwIHx8IHQgPT09IG51bGwgfHwgdCA9PT0gdm9pZCAwKSB7XG4gICAgZXQodCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICh0eXBlb2YgdCA9PSBcIm51bWJlclwiIHx8IHR5cGVvZiB0ID09IFwiYmlnaW50XCIpIHtcbiAgICBmdCh0KTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHR5cGVvZiB0ID09IFwic3RyaW5nXCIpIHtcbiAgICBYKHQpO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAodCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICBWKHQpO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAodCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgVihuZXcgVWludDhBcnJheSh0KSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHQpKSB7XG4gICAgdHQodCwgbik7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICh0eXBlb2YgdCA9PSBcIm9iamVjdFwiKSB7XG4gICAgbnQodCwgbik7XG4gICAgcmV0dXJuO1xuICB9XG4gIHRocm93IG5ldyB4KGBVbnN1cHBvcnRlZCB0eXBlOiAke3R5cGVvZiB0fWApO1xufVxuZnVuY3Rpb24gdHQodCwgbikge1xuICBJKGMuQXJyYXksIHQubGVuZ3RoKSwgdC5mb3JFYWNoKChlLCBpKSA9PiB7XG4gICAgXygobiA9PSBudWxsID8gdm9pZCAwIDogbihlLCBpLnRvU3RyaW5nKCkpKSA/PyBlLCBuKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBudCh0LCBuKSB7XG4gIE8gPSBPYmplY3QuZW50cmllcyh0KSwgSShjLk1hcCwgTy5sZW5ndGgpLCBPLmZvckVhY2goKFtlLCBpXSkgPT4ge1xuICAgIFgoZSksIF8oKG4gPT0gbnVsbCA/IHZvaWQgMCA6IG4oaSwgZSkpID8/IGksIG4pO1xuICB9KTtcbn1cbmZ1bmN0aW9uIEkodCwgbikge1xuICBpZiAobiA8PSB6KSB7XG4gICAgci5zZXRVaW50OChcbiAgICAgIHMrKyxcbiAgICAgIFModCkgfCBOdW1iZXIobilcbiAgICApO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAobiA8PSBZKSB7XG4gICAgci5zZXRVaW50OChcbiAgICAgIHMrKyxcbiAgICAgIFModCkgfCBkLk9uZUJ5dGVcbiAgICApLCByLnNldFVpbnQ4KHMsIE51bWJlcihuKSksIHMgKz0gMTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKG4gPD0gRykge1xuICAgIHIuc2V0VWludDgoXG4gICAgICBzKyssXG4gICAgICBTKHQpIHwgZC5Ud29CeXRlc1xuICAgICksIHIuc2V0VWludDE2KHMsIE51bWJlcihuKSwgaCksIHMgKz0gMjtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKG4gPD0gUCkge1xuICAgIHIuc2V0VWludDgoXG4gICAgICBzKyssXG4gICAgICBTKHQpIHwgZC5Gb3VyQnl0ZXNcbiAgICApLCByLnNldFVpbnQzMihzLCBOdW1iZXIobiksIGgpLCBzICs9IDQ7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChuIDw9IEgpIHtcbiAgICByLnNldFVpbnQ4KFxuICAgICAgcysrLFxuICAgICAgUyh0KSB8IGQuRWlnaHRCeXRlc1xuICAgICksIHIuc2V0QmlnVWludDY0KHMsIEJpZ0ludChuKSwgaCksIHMgKz0gODtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhyb3cgbmV3IHgoYFZhbHVlIHRvbyBsYXJnZSB0byBlbmNvZGU6ICR7bn1gKTtcbn1cbmZ1bmN0aW9uIGV0KHQpIHtcbiAgSShjLlNpbXBsZSwgc3QodCkpO1xufVxuZnVuY3Rpb24gc3QodCkge1xuICBpZiAodCA9PT0gITEpXG4gICAgcmV0dXJuIGcuRmFsc2U7XG4gIGlmICh0ID09PSAhMClcbiAgICByZXR1cm4gZy5UcnVlO1xuICBpZiAodCA9PT0gbnVsbClcbiAgICByZXR1cm4gZy5OdWxsO1xuICBpZiAodCA9PT0gdm9pZCAwKVxuICAgIHJldHVybiBnLlVuZGVmaW5lZDtcbiAgdGhyb3cgbmV3IHgoYFVucmVjb2duaXplZCBzaW1wbGUgdmFsdWU6ICR7dC50b1N0cmluZygpfWApO1xufVxuZnVuY3Rpb24gayh0LCBuKSB7XG4gIEkodCwgbi5sZW5ndGgpLCBzID4gby5sZW5ndGggLSBuLmxlbmd0aCAmJiAobyA9IFIobywgby5sZW5ndGggKyBuLmxlbmd0aCksIHIgPSBuZXcgRGF0YVZpZXcoby5idWZmZXIpKSwgby5zZXQobiwgcyksIHMgKz0gbi5sZW5ndGg7XG59XG5mdW5jdGlvbiBUKHQsIG4pIHtcbiAgSSh0LCBuKTtcbn1cbmZ1bmN0aW9uIGN0KHQpIHtcbiAgVChjLlVuc2lnbmVkSW50ZWdlciwgdCk7XG59XG5mdW5jdGlvbiBvdCh0KSB7XG4gIFQoXG4gICAgYy5OZWdhdGl2ZUludGVnZXIsXG4gICAgdHlwZW9mIHQgPT0gXCJiaWdpbnRcIiA/IC0xbiAtIHQgOiAtMSAtIHRcbiAgKTtcbn1cbmZ1bmN0aW9uIGZ0KHQpIHtcbiAgdCA+PSAwID8gY3QodCkgOiBvdCh0KTtcbn1cbmZ1bmN0aW9uIFgodCkge1xuICBrKGMuVGV4dFN0cmluZywgdi5lbmNvZGUodCkpO1xufVxuZnVuY3Rpb24gVih0KSB7XG4gIGsoYy5CeXRlU3RyaW5nLCB0KTtcbn1cbmZ1bmN0aW9uIGl0KHQsIG4sIGUpIHtcbiAgSShjLlRhZywgdCksIF8obiwgZSk7XG59XG5leHBvcnQge1xuICB3IGFzIERlY29kaW5nRXJyb3IsXG4gIHggYXMgRW5jb2RpbmdFcnJvcixcbiAgdXQgYXMgZGVjb2RlLFxuICBydCBhcyBlbmNvZGUsXG4gIGR0IGFzIGVuY29kZVdpdGhTZWxmRGVzY3JpYmVkVGFnXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2Jvci5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../packages/sdk-js/node_modules/@dfinity/cbor/dist/cbor.mjs\n");

/***/ }),

/***/ "(ssr)/../../packages/sdk-js/node_modules/@dfinity/principal/lib/esm/principal.js":
/*!**********************************************************************************!*\
  !*** ../../packages/sdk-js/node_modules/@dfinity/principal/lib/esm/principal.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   JSON_KEY_PRINCIPAL: () => (/* binding */ JSON_KEY_PRINCIPAL),\n/* harmony export */   Principal: () => (/* binding */ Principal)\n/* harmony export */ });\n/* harmony import */ var _utils_base32_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/base32.js */ \"(ssr)/../../packages/sdk-js/node_modules/@dfinity/principal/lib/esm/utils/base32.js\");\n/* harmony import */ var _utils_getCrc_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/getCrc.js */ \"(ssr)/../../packages/sdk-js/node_modules/@dfinity/principal/lib/esm/utils/getCrc.js\");\n/* harmony import */ var _noble_hashes_sha2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/sha2 */ \"(ssr)/../../packages/sdk-js/node_modules/@noble/hashes/esm/sha2.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/hashes/utils */ \"(ssr)/../../packages/sdk-js/node_modules/@noble/hashes/esm/utils.js\");\n\n\n\n\nconst JSON_KEY_PRINCIPAL = '__principal__';\nconst SELF_AUTHENTICATING_SUFFIX = 2;\nconst ANONYMOUS_SUFFIX = 4;\nconst MANAGEMENT_CANISTER_PRINCIPAL_TEXT_STR = 'aaaaa-aa';\nclass Principal {\n    static anonymous() {\n        return new this(new Uint8Array([ANONYMOUS_SUFFIX]));\n    }\n    /**\n     * Utility method, returning the principal representing the management canister, decoded from the hex string `'aaaaa-aa'`\n     * @returns {Principal} principal of the management canister\n     */\n    static managementCanister() {\n        return this.fromText(MANAGEMENT_CANISTER_PRINCIPAL_TEXT_STR);\n    }\n    static selfAuthenticating(publicKey) {\n        const sha = (0,_noble_hashes_sha2__WEBPACK_IMPORTED_MODULE_0__.sha224)(publicKey);\n        return new this(new Uint8Array([...sha, SELF_AUTHENTICATING_SUFFIX]));\n    }\n    static from(other) {\n        if (typeof other === 'string') {\n            return Principal.fromText(other);\n        }\n        else if (Object.getPrototypeOf(other) === Uint8Array.prototype) {\n            return new Principal(other);\n        }\n        else if (Principal.isPrincipal(other)) {\n            return new Principal(other._arr);\n        }\n        throw new Error(`Impossible to convert ${JSON.stringify(other)} to Principal.`);\n    }\n    static fromHex(hex) {\n        return new this((0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.hexToBytes)(hex));\n    }\n    static fromText(text) {\n        let maybePrincipal = text;\n        // If formatted as JSON string, parse it first\n        if (text.includes(JSON_KEY_PRINCIPAL)) {\n            const obj = JSON.parse(text);\n            if (JSON_KEY_PRINCIPAL in obj) {\n                maybePrincipal = obj[JSON_KEY_PRINCIPAL];\n            }\n        }\n        const canisterIdNoDash = maybePrincipal.toLowerCase().replace(/-/g, '');\n        let arr = (0,_utils_base32_js__WEBPACK_IMPORTED_MODULE_2__.decode)(canisterIdNoDash);\n        arr = arr.slice(4, arr.length);\n        const principal = new this(arr);\n        if (principal.toText() !== maybePrincipal) {\n            throw new Error(`Principal \"${principal.toText()}\" does not have a valid checksum (original value \"${maybePrincipal}\" may not be a valid Principal ID).`);\n        }\n        return principal;\n    }\n    static fromUint8Array(arr) {\n        return new this(arr);\n    }\n    static isPrincipal(other) {\n        return (other instanceof Principal ||\n            (typeof other === 'object' &&\n                other !== null &&\n                '_isPrincipal' in other &&\n                other['_isPrincipal'] === true &&\n                '_arr' in other &&\n                other['_arr'] instanceof Uint8Array));\n    }\n    constructor(_arr) {\n        this._arr = _arr;\n        this._isPrincipal = true;\n    }\n    isAnonymous() {\n        return this._arr.byteLength === 1 && this._arr[0] === ANONYMOUS_SUFFIX;\n    }\n    toUint8Array() {\n        return this._arr;\n    }\n    toHex() {\n        return (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.bytesToHex)(this._arr).toUpperCase();\n    }\n    toText() {\n        const checksumArrayBuf = new ArrayBuffer(4);\n        const view = new DataView(checksumArrayBuf);\n        view.setUint32(0, (0,_utils_getCrc_js__WEBPACK_IMPORTED_MODULE_3__.getCrc32)(this._arr));\n        const checksum = new Uint8Array(checksumArrayBuf);\n        const array = new Uint8Array([...checksum, ...this._arr]);\n        const result = (0,_utils_base32_js__WEBPACK_IMPORTED_MODULE_2__.encode)(array);\n        const matches = result.match(/.{1,5}/g);\n        if (!matches) {\n            // This should only happen if there's no character, which is unreachable.\n            throw new Error();\n        }\n        return matches.join('-');\n    }\n    toString() {\n        return this.toText();\n    }\n    /**\n     * Serializes to JSON\n     * @returns {JsonnablePrincipal} a JSON object with a single key, {@link JSON_KEY_PRINCIPAL}, whose value is the principal as a string\n     */\n    toJSON() {\n        return { [JSON_KEY_PRINCIPAL]: this.toText() };\n    }\n    /**\n     * Utility method taking a Principal to compare against. Used for determining canister ranges in certificate verification\n     * @param {Principal} other - a {@link Principal} to compare\n     * @returns {'lt' | 'eq' | 'gt'} `'lt' | 'eq' | 'gt'` a string, representing less than, equal to, or greater than\n     */\n    compareTo(other) {\n        for (let i = 0; i < Math.min(this._arr.length, other._arr.length); i++) {\n            if (this._arr[i] < other._arr[i])\n                return 'lt';\n            else if (this._arr[i] > other._arr[i])\n                return 'gt';\n        }\n        // Here, at least one principal is a prefix of the other principal (they could be the same)\n        if (this._arr.length < other._arr.length)\n            return 'lt';\n        if (this._arr.length > other._arr.length)\n            return 'gt';\n        return 'eq';\n    }\n    /**\n     * Utility method checking whether a provided Principal is less than or equal to the current one using the {@link Principal.compareTo} method\n     * @param other a {@link Principal} to compare\n     * @returns {boolean} boolean\n     */\n    ltEq(other) {\n        const cmp = this.compareTo(other);\n        return cmp == 'lt' || cmp == 'eq';\n    }\n    /**\n     * Utility method checking whether a provided Principal is greater than or equal to the current one using the {@link Principal.compareTo} method\n     * @param other a {@link Principal} to compare\n     * @returns {boolean} boolean\n     */\n    gtEq(other) {\n        const cmp = this.compareTo(other);\n        return cmp == 'gt' || cmp == 'eq';\n    }\n}\n//# sourceMappingURL=principal.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vcGFja2FnZXMvc2RrLWpzL25vZGVfbW9kdWxlcy9AZGZpbml0eS9wcmluY2lwYWwvbGliL2VzbS9wcmluY2lwYWwuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQW1EO0FBQ047QUFDRDtBQUNpQjtBQUN0RDtBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixXQUFXO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMERBQU07QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELHVCQUF1QjtBQUN4RTtBQUNBO0FBQ0Esd0JBQXdCLCtEQUFVO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isd0RBQU07QUFDeEI7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLG1CQUFtQixvREFBb0QsZUFBZTtBQUNoSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwrREFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiwwREFBUTtBQUNsQztBQUNBO0FBQ0EsdUJBQXVCLHdEQUFNO0FBQzdCLHdDQUF3QyxJQUFJO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsb0JBQW9CLGtDQUFrQyx5QkFBeUI7QUFDaEc7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxlQUFlLFdBQVcsV0FBVyxpQkFBaUI7QUFDdEQsaUJBQWlCLG9CQUFvQjtBQUNyQztBQUNBO0FBQ0Esd0JBQXdCLG1EQUFtRDtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdIQUFnSCwyQkFBMkI7QUFDM0ksdUJBQXVCLGlCQUFpQjtBQUN4QyxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtSEFBbUgsMkJBQTJCO0FBQzlJLHVCQUF1QixpQkFBaUI7QUFDeEMsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AaXF1YmUvb3BzLWNvbnNvbGUvLi4vLi4vcGFja2FnZXMvc2RrLWpzL25vZGVfbW9kdWxlcy9AZGZpbml0eS9wcmluY2lwYWwvbGliL2VzbS9wcmluY2lwYWwuanM/OWU1NSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBkZWNvZGUsIGVuY29kZSB9IGZyb20gXCIuL3V0aWxzL2Jhc2UzMi5qc1wiO1xuaW1wb3J0IHsgZ2V0Q3JjMzIgfSBmcm9tIFwiLi91dGlscy9nZXRDcmMuanNcIjtcbmltcG9ydCB7IHNoYTIyNCB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvc2hhMic7XG5pbXBvcnQgeyBieXRlc1RvSGV4LCBoZXhUb0J5dGVzIH0gZnJvbSAnQG5vYmxlL2hhc2hlcy91dGlscyc7XG5leHBvcnQgY29uc3QgSlNPTl9LRVlfUFJJTkNJUEFMID0gJ19fcHJpbmNpcGFsX18nO1xuY29uc3QgU0VMRl9BVVRIRU5USUNBVElOR19TVUZGSVggPSAyO1xuY29uc3QgQU5PTllNT1VTX1NVRkZJWCA9IDQ7XG5jb25zdCBNQU5BR0VNRU5UX0NBTklTVEVSX1BSSU5DSVBBTF9URVhUX1NUUiA9ICdhYWFhYS1hYSc7XG5leHBvcnQgY2xhc3MgUHJpbmNpcGFsIHtcbiAgICBzdGF0aWMgYW5vbnltb3VzKCkge1xuICAgICAgICByZXR1cm4gbmV3IHRoaXMobmV3IFVpbnQ4QXJyYXkoW0FOT05ZTU9VU19TVUZGSVhdKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFV0aWxpdHkgbWV0aG9kLCByZXR1cm5pbmcgdGhlIHByaW5jaXBhbCByZXByZXNlbnRpbmcgdGhlIG1hbmFnZW1lbnQgY2FuaXN0ZXIsIGRlY29kZWQgZnJvbSB0aGUgaGV4IHN0cmluZyBgJ2FhYWFhLWFhJ2BcbiAgICAgKiBAcmV0dXJucyB7UHJpbmNpcGFsfSBwcmluY2lwYWwgb2YgdGhlIG1hbmFnZW1lbnQgY2FuaXN0ZXJcbiAgICAgKi9cbiAgICBzdGF0aWMgbWFuYWdlbWVudENhbmlzdGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mcm9tVGV4dChNQU5BR0VNRU5UX0NBTklTVEVSX1BSSU5DSVBBTF9URVhUX1NUUik7XG4gICAgfVxuICAgIHN0YXRpYyBzZWxmQXV0aGVudGljYXRpbmcocHVibGljS2V5KSB7XG4gICAgICAgIGNvbnN0IHNoYSA9IHNoYTIyNChwdWJsaWNLZXkpO1xuICAgICAgICByZXR1cm4gbmV3IHRoaXMobmV3IFVpbnQ4QXJyYXkoWy4uLnNoYSwgU0VMRl9BVVRIRU5USUNBVElOR19TVUZGSVhdKSk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tKG90aGVyKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb3RoZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJpbmNpcGFsLmZyb21UZXh0KG90aGVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChPYmplY3QuZ2V0UHJvdG90eXBlT2Yob3RoZXIpID09PSBVaW50OEFycmF5LnByb3RvdHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcmluY2lwYWwob3RoZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFByaW5jaXBhbC5pc1ByaW5jaXBhbChvdGhlcikpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJpbmNpcGFsKG90aGVyLl9hcnIpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW1wb3NzaWJsZSB0byBjb252ZXJ0ICR7SlNPTi5zdHJpbmdpZnkob3RoZXIpfSB0byBQcmluY2lwYWwuYCk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tSGV4KGhleCkge1xuICAgICAgICByZXR1cm4gbmV3IHRoaXMoaGV4VG9CeXRlcyhoZXgpKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21UZXh0KHRleHQpIHtcbiAgICAgICAgbGV0IG1heWJlUHJpbmNpcGFsID0gdGV4dDtcbiAgICAgICAgLy8gSWYgZm9ybWF0dGVkIGFzIEpTT04gc3RyaW5nLCBwYXJzZSBpdCBmaXJzdFxuICAgICAgICBpZiAodGV4dC5pbmNsdWRlcyhKU09OX0tFWV9QUklOQ0lQQUwpKSB7XG4gICAgICAgICAgICBjb25zdCBvYmogPSBKU09OLnBhcnNlKHRleHQpO1xuICAgICAgICAgICAgaWYgKEpTT05fS0VZX1BSSU5DSVBBTCBpbiBvYmopIHtcbiAgICAgICAgICAgICAgICBtYXliZVByaW5jaXBhbCA9IG9ialtKU09OX0tFWV9QUklOQ0lQQUxdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNhbmlzdGVySWROb0Rhc2ggPSBtYXliZVByaW5jaXBhbC50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoLy0vZywgJycpO1xuICAgICAgICBsZXQgYXJyID0gZGVjb2RlKGNhbmlzdGVySWROb0Rhc2gpO1xuICAgICAgICBhcnIgPSBhcnIuc2xpY2UoNCwgYXJyLmxlbmd0aCk7XG4gICAgICAgIGNvbnN0IHByaW5jaXBhbCA9IG5ldyB0aGlzKGFycik7XG4gICAgICAgIGlmIChwcmluY2lwYWwudG9UZXh0KCkgIT09IG1heWJlUHJpbmNpcGFsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFByaW5jaXBhbCBcIiR7cHJpbmNpcGFsLnRvVGV4dCgpfVwiIGRvZXMgbm90IGhhdmUgYSB2YWxpZCBjaGVja3N1bSAob3JpZ2luYWwgdmFsdWUgXCIke21heWJlUHJpbmNpcGFsfVwiIG1heSBub3QgYmUgYSB2YWxpZCBQcmluY2lwYWwgSUQpLmApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcmluY2lwYWw7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tVWludDhBcnJheShhcnIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzKGFycik7XG4gICAgfVxuICAgIHN0YXRpYyBpc1ByaW5jaXBhbChvdGhlcikge1xuICAgICAgICByZXR1cm4gKG90aGVyIGluc3RhbmNlb2YgUHJpbmNpcGFsIHx8XG4gICAgICAgICAgICAodHlwZW9mIG90aGVyID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgICAgIG90aGVyICE9PSBudWxsICYmXG4gICAgICAgICAgICAgICAgJ19pc1ByaW5jaXBhbCcgaW4gb3RoZXIgJiZcbiAgICAgICAgICAgICAgICBvdGhlclsnX2lzUHJpbmNpcGFsJ10gPT09IHRydWUgJiZcbiAgICAgICAgICAgICAgICAnX2FycicgaW4gb3RoZXIgJiZcbiAgICAgICAgICAgICAgICBvdGhlclsnX2FyciddIGluc3RhbmNlb2YgVWludDhBcnJheSkpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihfYXJyKSB7XG4gICAgICAgIHRoaXMuX2FyciA9IF9hcnI7XG4gICAgICAgIHRoaXMuX2lzUHJpbmNpcGFsID0gdHJ1ZTtcbiAgICB9XG4gICAgaXNBbm9ueW1vdXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hcnIuYnl0ZUxlbmd0aCA9PT0gMSAmJiB0aGlzLl9hcnJbMF0gPT09IEFOT05ZTU9VU19TVUZGSVg7XG4gICAgfVxuICAgIHRvVWludDhBcnJheSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FycjtcbiAgICB9XG4gICAgdG9IZXgoKSB7XG4gICAgICAgIHJldHVybiBieXRlc1RvSGV4KHRoaXMuX2FycikudG9VcHBlckNhc2UoKTtcbiAgICB9XG4gICAgdG9UZXh0KCkge1xuICAgICAgICBjb25zdCBjaGVja3N1bUFycmF5QnVmID0gbmV3IEFycmF5QnVmZmVyKDQpO1xuICAgICAgICBjb25zdCB2aWV3ID0gbmV3IERhdGFWaWV3KGNoZWNrc3VtQXJyYXlCdWYpO1xuICAgICAgICB2aWV3LnNldFVpbnQzMigwLCBnZXRDcmMzMih0aGlzLl9hcnIpKTtcbiAgICAgICAgY29uc3QgY2hlY2tzdW0gPSBuZXcgVWludDhBcnJheShjaGVja3N1bUFycmF5QnVmKTtcbiAgICAgICAgY29uc3QgYXJyYXkgPSBuZXcgVWludDhBcnJheShbLi4uY2hlY2tzdW0sIC4uLnRoaXMuX2Fycl0pO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBlbmNvZGUoYXJyYXkpO1xuICAgICAgICBjb25zdCBtYXRjaGVzID0gcmVzdWx0Lm1hdGNoKC8uezEsNX0vZyk7XG4gICAgICAgIGlmICghbWF0Y2hlcykge1xuICAgICAgICAgICAgLy8gVGhpcyBzaG91bGQgb25seSBoYXBwZW4gaWYgdGhlcmUncyBubyBjaGFyYWN0ZXIsIHdoaWNoIGlzIHVucmVhY2hhYmxlLlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hdGNoZXMuam9pbignLScpO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9UZXh0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlcmlhbGl6ZXMgdG8gSlNPTlxuICAgICAqIEByZXR1cm5zIHtKc29ubmFibGVQcmluY2lwYWx9IGEgSlNPTiBvYmplY3Qgd2l0aCBhIHNpbmdsZSBrZXksIHtAbGluayBKU09OX0tFWV9QUklOQ0lQQUx9LCB3aG9zZSB2YWx1ZSBpcyB0aGUgcHJpbmNpcGFsIGFzIGEgc3RyaW5nXG4gICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4geyBbSlNPTl9LRVlfUFJJTkNJUEFMXTogdGhpcy50b1RleHQoKSB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVdGlsaXR5IG1ldGhvZCB0YWtpbmcgYSBQcmluY2lwYWwgdG8gY29tcGFyZSBhZ2FpbnN0LiBVc2VkIGZvciBkZXRlcm1pbmluZyBjYW5pc3RlciByYW5nZXMgaW4gY2VydGlmaWNhdGUgdmVyaWZpY2F0aW9uXG4gICAgICogQHBhcmFtIHtQcmluY2lwYWx9IG90aGVyIC0gYSB7QGxpbmsgUHJpbmNpcGFsfSB0byBjb21wYXJlXG4gICAgICogQHJldHVybnMgeydsdCcgfCAnZXEnIHwgJ2d0J30gYCdsdCcgfCAnZXEnIHwgJ2d0J2AgYSBzdHJpbmcsIHJlcHJlc2VudGluZyBsZXNzIHRoYW4sIGVxdWFsIHRvLCBvciBncmVhdGVyIHRoYW5cbiAgICAgKi9cbiAgICBjb21wYXJlVG8ob3RoZXIpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBNYXRoLm1pbih0aGlzLl9hcnIubGVuZ3RoLCBvdGhlci5fYXJyLmxlbmd0aCk7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2FycltpXSA8IG90aGVyLl9hcnJbaV0pXG4gICAgICAgICAgICAgICAgcmV0dXJuICdsdCc7XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9hcnJbaV0gPiBvdGhlci5fYXJyW2ldKVxuICAgICAgICAgICAgICAgIHJldHVybiAnZ3QnO1xuICAgICAgICB9XG4gICAgICAgIC8vIEhlcmUsIGF0IGxlYXN0IG9uZSBwcmluY2lwYWwgaXMgYSBwcmVmaXggb2YgdGhlIG90aGVyIHByaW5jaXBhbCAodGhleSBjb3VsZCBiZSB0aGUgc2FtZSlcbiAgICAgICAgaWYgKHRoaXMuX2Fyci5sZW5ndGggPCBvdGhlci5fYXJyLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiAnbHQnO1xuICAgICAgICBpZiAodGhpcy5fYXJyLmxlbmd0aCA+IG90aGVyLl9hcnIubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuICdndCc7XG4gICAgICAgIHJldHVybiAnZXEnO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVdGlsaXR5IG1ldGhvZCBjaGVja2luZyB3aGV0aGVyIGEgcHJvdmlkZWQgUHJpbmNpcGFsIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgY3VycmVudCBvbmUgdXNpbmcgdGhlIHtAbGluayBQcmluY2lwYWwuY29tcGFyZVRvfSBtZXRob2RcbiAgICAgKiBAcGFyYW0gb3RoZXIgYSB7QGxpbmsgUHJpbmNpcGFsfSB0byBjb21wYXJlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IGJvb2xlYW5cbiAgICAgKi9cbiAgICBsdEVxKG90aGVyKSB7XG4gICAgICAgIGNvbnN0IGNtcCA9IHRoaXMuY29tcGFyZVRvKG90aGVyKTtcbiAgICAgICAgcmV0dXJuIGNtcCA9PSAnbHQnIHx8IGNtcCA9PSAnZXEnO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVdGlsaXR5IG1ldGhvZCBjaGVja2luZyB3aGV0aGVyIGEgcHJvdmlkZWQgUHJpbmNpcGFsIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB0aGUgY3VycmVudCBvbmUgdXNpbmcgdGhlIHtAbGluayBQcmluY2lwYWwuY29tcGFyZVRvfSBtZXRob2RcbiAgICAgKiBAcGFyYW0gb3RoZXIgYSB7QGxpbmsgUHJpbmNpcGFsfSB0byBjb21wYXJlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IGJvb2xlYW5cbiAgICAgKi9cbiAgICBndEVxKG90aGVyKSB7XG4gICAgICAgIGNvbnN0IGNtcCA9IHRoaXMuY29tcGFyZVRvKG90aGVyKTtcbiAgICAgICAgcmV0dXJuIGNtcCA9PSAnZ3QnIHx8IGNtcCA9PSAnZXEnO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByaW5jaXBhbC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../packages/sdk-js/node_modules/@dfinity/principal/lib/esm/principal.js\n");

/***/ }),

/***/ "(ssr)/../../packages/sdk-js/node_modules/@dfinity/principal/lib/esm/utils/base32.js":
/*!*************************************************************************************!*\
  !*** ../../packages/sdk-js/node_modules/@dfinity/principal/lib/esm/utils/base32.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decode: () => (/* binding */ decode),\n/* harmony export */   encode: () => (/* binding */ encode)\n/* harmony export */ });\nconst alphabet = 'abcdefghijklmnopqrstuvwxyz234567';\n// Build a lookup table for decoding.\nconst lookupTable = Object.create(null);\nfor (let i = 0; i < alphabet.length; i++) {\n    lookupTable[alphabet[i]] = i;\n}\n// Add aliases for rfc4648.\nlookupTable['0'] = lookupTable.o;\nlookupTable['1'] = lookupTable.i;\n/**\n * @param input The Uint8Array to encode.\n * @returns A Base32 string encoding the input.\n */\nfunction encode(input) {\n    // How many bits will we skip from the first byte.\n    let skip = 0;\n    // 5 high bits, carry from one byte to the next.\n    let bits = 0;\n    // The output string in base32.\n    let output = '';\n    function encodeByte(byte) {\n        if (skip < 0) {\n            // we have a carry from the previous byte\n            bits |= byte >> -skip;\n        }\n        else {\n            // no carry\n            bits = (byte << skip) & 248;\n        }\n        if (skip > 3) {\n            // Not enough data to produce a character, get us another one\n            skip -= 8;\n            return 1;\n        }\n        if (skip < 4) {\n            // produce a character\n            output += alphabet[bits >> 3];\n            skip += 5;\n        }\n        return 0;\n    }\n    for (let i = 0; i < input.length;) {\n        i += encodeByte(input[i]);\n    }\n    return output + (skip < 0 ? alphabet[bits >> 3] : '');\n}\n/**\n * @param input The base32 encoded string to decode.\n */\nfunction decode(input) {\n    // how many bits we have from the previous character.\n    let skip = 0;\n    // current byte we're producing.\n    let byte = 0;\n    const output = new Uint8Array(((input.length * 4) / 3) | 0);\n    let o = 0;\n    function decodeChar(char) {\n        // Consume a character from the stream, store\n        // the output in this.output. As before, better\n        // to use update().\n        let val = lookupTable[char.toLowerCase()];\n        if (val === undefined) {\n            throw new Error(`Invalid character: ${JSON.stringify(char)}`);\n        }\n        // move to the high bits\n        val <<= 3;\n        byte |= val >>> skip;\n        skip += 5;\n        if (skip >= 8) {\n            // We have enough bytes to produce an output\n            output[o++] = byte;\n            skip -= 8;\n            if (skip > 0) {\n                byte = (val << (5 - skip)) & 255;\n            }\n            else {\n                byte = 0;\n            }\n        }\n    }\n    for (const c of input) {\n        decodeChar(c);\n    }\n    return output.slice(0, o);\n}\n//# sourceMappingURL=base32.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vcGFja2FnZXMvc2RrLWpzL25vZGVfbW9kdWxlcy9AZGZpbml0eS9wcmluY2lwYWwvbGliL2VzbS91dGlscy9iYXNlMzIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IscUJBQXFCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELHFCQUFxQjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGlxdWJlL29wcy1jb25zb2xlLy4uLy4uL3BhY2thZ2VzL3Nkay1qcy9ub2RlX21vZHVsZXMvQGRmaW5pdHkvcHJpbmNpcGFsL2xpYi9lc20vdXRpbHMvYmFzZTMyLmpzP2YzODIiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgYWxwaGFiZXQgPSAnYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoyMzQ1NjcnO1xuLy8gQnVpbGQgYSBsb29rdXAgdGFibGUgZm9yIGRlY29kaW5nLlxuY29uc3QgbG9va3VwVGFibGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuZm9yIChsZXQgaSA9IDA7IGkgPCBhbHBoYWJldC5sZW5ndGg7IGkrKykge1xuICAgIGxvb2t1cFRhYmxlW2FscGhhYmV0W2ldXSA9IGk7XG59XG4vLyBBZGQgYWxpYXNlcyBmb3IgcmZjNDY0OC5cbmxvb2t1cFRhYmxlWycwJ10gPSBsb29rdXBUYWJsZS5vO1xubG9va3VwVGFibGVbJzEnXSA9IGxvb2t1cFRhYmxlLmk7XG4vKipcbiAqIEBwYXJhbSBpbnB1dCBUaGUgVWludDhBcnJheSB0byBlbmNvZGUuXG4gKiBAcmV0dXJucyBBIEJhc2UzMiBzdHJpbmcgZW5jb2RpbmcgdGhlIGlucHV0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlKGlucHV0KSB7XG4gICAgLy8gSG93IG1hbnkgYml0cyB3aWxsIHdlIHNraXAgZnJvbSB0aGUgZmlyc3QgYnl0ZS5cbiAgICBsZXQgc2tpcCA9IDA7XG4gICAgLy8gNSBoaWdoIGJpdHMsIGNhcnJ5IGZyb20gb25lIGJ5dGUgdG8gdGhlIG5leHQuXG4gICAgbGV0IGJpdHMgPSAwO1xuICAgIC8vIFRoZSBvdXRwdXQgc3RyaW5nIGluIGJhc2UzMi5cbiAgICBsZXQgb3V0cHV0ID0gJyc7XG4gICAgZnVuY3Rpb24gZW5jb2RlQnl0ZShieXRlKSB7XG4gICAgICAgIGlmIChza2lwIDwgMCkge1xuICAgICAgICAgICAgLy8gd2UgaGF2ZSBhIGNhcnJ5IGZyb20gdGhlIHByZXZpb3VzIGJ5dGVcbiAgICAgICAgICAgIGJpdHMgfD0gYnl0ZSA+PiAtc2tpcDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIG5vIGNhcnJ5XG4gICAgICAgICAgICBiaXRzID0gKGJ5dGUgPDwgc2tpcCkgJiAyNDg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNraXAgPiAzKSB7XG4gICAgICAgICAgICAvLyBOb3QgZW5vdWdoIGRhdGEgdG8gcHJvZHVjZSBhIGNoYXJhY3RlciwgZ2V0IHVzIGFub3RoZXIgb25lXG4gICAgICAgICAgICBza2lwIC09IDg7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2tpcCA8IDQpIHtcbiAgICAgICAgICAgIC8vIHByb2R1Y2UgYSBjaGFyYWN0ZXJcbiAgICAgICAgICAgIG91dHB1dCArPSBhbHBoYWJldFtiaXRzID4+IDNdO1xuICAgICAgICAgICAgc2tpcCArPSA1O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDspIHtcbiAgICAgICAgaSArPSBlbmNvZGVCeXRlKGlucHV0W2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dCArIChza2lwIDwgMCA/IGFscGhhYmV0W2JpdHMgPj4gM10gOiAnJyk7XG59XG4vKipcbiAqIEBwYXJhbSBpbnB1dCBUaGUgYmFzZTMyIGVuY29kZWQgc3RyaW5nIHRvIGRlY29kZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZShpbnB1dCkge1xuICAgIC8vIGhvdyBtYW55IGJpdHMgd2UgaGF2ZSBmcm9tIHRoZSBwcmV2aW91cyBjaGFyYWN0ZXIuXG4gICAgbGV0IHNraXAgPSAwO1xuICAgIC8vIGN1cnJlbnQgYnl0ZSB3ZSdyZSBwcm9kdWNpbmcuXG4gICAgbGV0IGJ5dGUgPSAwO1xuICAgIGNvbnN0IG91dHB1dCA9IG5ldyBVaW50OEFycmF5KCgoaW5wdXQubGVuZ3RoICogNCkgLyAzKSB8IDApO1xuICAgIGxldCBvID0gMDtcbiAgICBmdW5jdGlvbiBkZWNvZGVDaGFyKGNoYXIpIHtcbiAgICAgICAgLy8gQ29uc3VtZSBhIGNoYXJhY3RlciBmcm9tIHRoZSBzdHJlYW0sIHN0b3JlXG4gICAgICAgIC8vIHRoZSBvdXRwdXQgaW4gdGhpcy5vdXRwdXQuIEFzIGJlZm9yZSwgYmV0dGVyXG4gICAgICAgIC8vIHRvIHVzZSB1cGRhdGUoKS5cbiAgICAgICAgbGV0IHZhbCA9IGxvb2t1cFRhYmxlW2NoYXIudG9Mb3dlckNhc2UoKV07XG4gICAgICAgIGlmICh2YWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGNoYXJhY3RlcjogJHtKU09OLnN0cmluZ2lmeShjaGFyKX1gKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBtb3ZlIHRvIHRoZSBoaWdoIGJpdHNcbiAgICAgICAgdmFsIDw8PSAzO1xuICAgICAgICBieXRlIHw9IHZhbCA+Pj4gc2tpcDtcbiAgICAgICAgc2tpcCArPSA1O1xuICAgICAgICBpZiAoc2tpcCA+PSA4KSB7XG4gICAgICAgICAgICAvLyBXZSBoYXZlIGVub3VnaCBieXRlcyB0byBwcm9kdWNlIGFuIG91dHB1dFxuICAgICAgICAgICAgb3V0cHV0W28rK10gPSBieXRlO1xuICAgICAgICAgICAgc2tpcCAtPSA4O1xuICAgICAgICAgICAgaWYgKHNraXAgPiAwKSB7XG4gICAgICAgICAgICAgICAgYnl0ZSA9ICh2YWwgPDwgKDUgLSBza2lwKSkgJiAyNTU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBieXRlID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IGMgb2YgaW5wdXQpIHtcbiAgICAgICAgZGVjb2RlQ2hhcihjKTtcbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dC5zbGljZSgwLCBvKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJhc2UzMi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../packages/sdk-js/node_modules/@dfinity/principal/lib/esm/utils/base32.js\n");

/***/ }),

/***/ "(ssr)/../../packages/sdk-js/node_modules/@dfinity/principal/lib/esm/utils/getCrc.js":
/*!*************************************************************************************!*\
  !*** ../../packages/sdk-js/node_modules/@dfinity/principal/lib/esm/utils/getCrc.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getCrc32: () => (/* binding */ getCrc32)\n/* harmony export */ });\n// This file is translated to JavaScript from\n// https://lxp32.github.io/docs/a-simple-example-crc32-calculation/\nconst lookUpTable = new Uint32Array([\n    0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f, 0xe963a535, 0x9e6495a3,\n    0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91,\n    0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,\n    0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9, 0xfa0f3d63, 0x8d080df5,\n    0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172, 0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b,\n    0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,\n    0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423, 0xcfba9599, 0xb8bda50f,\n    0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924, 0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d,\n    0x76dc4190, 0x01db7106, 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,\n    0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01,\n    0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e, 0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457,\n    0x65b0d9c6, 0x12b7e950, 0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,\n    0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb,\n    0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0, 0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9,\n    0x5005713c, 0x270241aa, 0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,\n    0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad,\n    0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a, 0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683,\n    0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,\n    0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb, 0x196c3671, 0x6e6b06e7,\n    0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5,\n    0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,\n    0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55, 0x316e8eef, 0x4669be79,\n    0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236, 0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f,\n    0xc5ba3bbe, 0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,\n    0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713,\n    0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38, 0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21,\n    0x86d3d2d4, 0xf1d4e242, 0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,\n    0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45,\n    0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db,\n    0xaed16a4a, 0xd9d65adc, 0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,\n    0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693, 0x54de5729, 0x23d967bf,\n    0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94, 0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d,\n]);\n/**\n * Calculate the CRC32 of a Uint8Array.\n * @param buf The Uint8Array to calculate the CRC32 of.\n */\nfunction getCrc32(buf) {\n    let crc = -1;\n    for (let i = 0; i < buf.length; i++) {\n        const byte = buf[i];\n        const t = (byte ^ crc) & 0xff;\n        crc = lookUpTable[t] ^ (crc >>> 8);\n    }\n    return (crc ^ -1) >>> 0;\n}\n//# sourceMappingURL=getCrc.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vcGFja2FnZXMvc2RrLWpzL25vZGVfbW9kdWxlcy9AZGZpbml0eS9wcmluY2lwYWwvbGliL2VzbS91dGlscy9nZXRDcmMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AaXF1YmUvb3BzLWNvbnNvbGUvLi4vLi4vcGFja2FnZXMvc2RrLWpzL25vZGVfbW9kdWxlcy9AZGZpbml0eS9wcmluY2lwYWwvbGliL2VzbS91dGlscy9nZXRDcmMuanM/YzdmOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBUaGlzIGZpbGUgaXMgdHJhbnNsYXRlZCB0byBKYXZhU2NyaXB0IGZyb21cbi8vIGh0dHBzOi8vbHhwMzIuZ2l0aHViLmlvL2RvY3MvYS1zaW1wbGUtZXhhbXBsZS1jcmMzMi1jYWxjdWxhdGlvbi9cbmNvbnN0IGxvb2tVcFRhYmxlID0gbmV3IFVpbnQzMkFycmF5KFtcbiAgICAweDAwMDAwMDAwLCAweDc3MDczMDk2LCAweGVlMGU2MTJjLCAweDk5MDk1MWJhLCAweDA3NmRjNDE5LCAweDcwNmFmNDhmLCAweGU5NjNhNTM1LCAweDllNjQ5NWEzLFxuICAgIDB4MGVkYjg4MzIsIDB4NzlkY2I4YTQsIDB4ZTBkNWU5MWUsIDB4OTdkMmQ5ODgsIDB4MDliNjRjMmIsIDB4N2ViMTdjYmQsIDB4ZTdiODJkMDcsIDB4OTBiZjFkOTEsXG4gICAgMHgxZGI3MTA2NCwgMHg2YWIwMjBmMiwgMHhmM2I5NzE0OCwgMHg4NGJlNDFkZSwgMHgxYWRhZDQ3ZCwgMHg2ZGRkZTRlYiwgMHhmNGQ0YjU1MSwgMHg4M2QzODVjNyxcbiAgICAweDEzNmM5ODU2LCAweDY0NmJhOGMwLCAweGZkNjJmOTdhLCAweDhhNjVjOWVjLCAweDE0MDE1YzRmLCAweDYzMDY2Y2Q5LCAweGZhMGYzZDYzLCAweDhkMDgwZGY1LFxuICAgIDB4M2I2ZTIwYzgsIDB4NGM2OTEwNWUsIDB4ZDU2MDQxZTQsIDB4YTI2NzcxNzIsIDB4M2MwM2U0ZDEsIDB4NGIwNGQ0NDcsIDB4ZDIwZDg1ZmQsIDB4YTUwYWI1NmIsXG4gICAgMHgzNWI1YThmYSwgMHg0MmIyOTg2YywgMHhkYmJiYzlkNiwgMHhhY2JjZjk0MCwgMHgzMmQ4NmNlMywgMHg0NWRmNWM3NSwgMHhkY2Q2MGRjZiwgMHhhYmQxM2Q1OSxcbiAgICAweDI2ZDkzMGFjLCAweDUxZGUwMDNhLCAweGM4ZDc1MTgwLCAweGJmZDA2MTE2LCAweDIxYjRmNGI1LCAweDU2YjNjNDIzLCAweGNmYmE5NTk5LCAweGI4YmRhNTBmLFxuICAgIDB4MjgwMmI4OWUsIDB4NWYwNTg4MDgsIDB4YzYwY2Q5YjIsIDB4YjEwYmU5MjQsIDB4MmY2ZjdjODcsIDB4NTg2ODRjMTEsIDB4YzE2MTFkYWIsIDB4YjY2NjJkM2QsXG4gICAgMHg3NmRjNDE5MCwgMHgwMWRiNzEwNiwgMHg5OGQyMjBiYywgMHhlZmQ1MTAyYSwgMHg3MWIxODU4OSwgMHgwNmI2YjUxZiwgMHg5ZmJmZTRhNSwgMHhlOGI4ZDQzMyxcbiAgICAweDc4MDdjOWEyLCAweDBmMDBmOTM0LCAweDk2MDlhODhlLCAweGUxMGU5ODE4LCAweDdmNmEwZGJiLCAweDA4NmQzZDJkLCAweDkxNjQ2Yzk3LCAweGU2NjM1YzAxLFxuICAgIDB4NmI2YjUxZjQsIDB4MWM2YzYxNjIsIDB4ODU2NTMwZDgsIDB4ZjI2MjAwNGUsIDB4NmMwNjk1ZWQsIDB4MWIwMWE1N2IsIDB4ODIwOGY0YzEsIDB4ZjUwZmM0NTcsXG4gICAgMHg2NWIwZDljNiwgMHgxMmI3ZTk1MCwgMHg4YmJlYjhlYSwgMHhmY2I5ODg3YywgMHg2MmRkMWRkZiwgMHgxNWRhMmQ0OSwgMHg4Y2QzN2NmMywgMHhmYmQ0NGM2NSxcbiAgICAweDRkYjI2MTU4LCAweDNhYjU1MWNlLCAweGEzYmMwMDc0LCAweGQ0YmIzMGUyLCAweDRhZGZhNTQxLCAweDNkZDg5NWQ3LCAweGE0ZDFjNDZkLCAweGQzZDZmNGZiLFxuICAgIDB4NDM2OWU5NmEsIDB4MzQ2ZWQ5ZmMsIDB4YWQ2Nzg4NDYsIDB4ZGE2MGI4ZDAsIDB4NDQwNDJkNzMsIDB4MzMwMzFkZTUsIDB4YWEwYTRjNWYsIDB4ZGQwZDdjYzksXG4gICAgMHg1MDA1NzEzYywgMHgyNzAyNDFhYSwgMHhiZTBiMTAxMCwgMHhjOTBjMjA4NiwgMHg1NzY4YjUyNSwgMHgyMDZmODViMywgMHhiOTY2ZDQwOSwgMHhjZTYxZTQ5ZixcbiAgICAweDVlZGVmOTBlLCAweDI5ZDljOTk4LCAweGIwZDA5ODIyLCAweGM3ZDdhOGI0LCAweDU5YjMzZDE3LCAweDJlYjQwZDgxLCAweGI3YmQ1YzNiLCAweGMwYmE2Y2FkLFxuICAgIDB4ZWRiODgzMjAsIDB4OWFiZmIzYjYsIDB4MDNiNmUyMGMsIDB4NzRiMWQyOWEsIDB4ZWFkNTQ3MzksIDB4OWRkMjc3YWYsIDB4MDRkYjI2MTUsIDB4NzNkYzE2ODMsXG4gICAgMHhlMzYzMGIxMiwgMHg5NDY0M2I4NCwgMHgwZDZkNmEzZSwgMHg3YTZhNWFhOCwgMHhlNDBlY2YwYiwgMHg5MzA5ZmY5ZCwgMHgwYTAwYWUyNywgMHg3ZDA3OWViMSxcbiAgICAweGYwMGY5MzQ0LCAweDg3MDhhM2QyLCAweDFlMDFmMjY4LCAweDY5MDZjMmZlLCAweGY3NjI1NzVkLCAweDgwNjU2N2NiLCAweDE5NmMzNjcxLCAweDZlNmIwNmU3LFxuICAgIDB4ZmVkNDFiNzYsIDB4ODlkMzJiZTAsIDB4MTBkYTdhNWEsIDB4NjdkZDRhY2MsIDB4ZjliOWRmNmYsIDB4OGViZWVmZjksIDB4MTdiN2JlNDMsIDB4NjBiMDhlZDUsXG4gICAgMHhkNmQ2YTNlOCwgMHhhMWQxOTM3ZSwgMHgzOGQ4YzJjNCwgMHg0ZmRmZjI1MiwgMHhkMWJiNjdmMSwgMHhhNmJjNTc2NywgMHgzZmI1MDZkZCwgMHg0OGIyMzY0YixcbiAgICAweGQ4MGQyYmRhLCAweGFmMGExYjRjLCAweDM2MDM0YWY2LCAweDQxMDQ3YTYwLCAweGRmNjBlZmMzLCAweGE4NjdkZjU1LCAweDMxNmU4ZWVmLCAweDQ2NjliZTc5LFxuICAgIDB4Y2I2MWIzOGMsIDB4YmM2NjgzMWEsIDB4MjU2ZmQyYTAsIDB4NTI2OGUyMzYsIDB4Y2MwYzc3OTUsIDB4YmIwYjQ3MDMsIDB4MjIwMjE2YjksIDB4NTUwNTI2MmYsXG4gICAgMHhjNWJhM2JiZSwgMHhiMmJkMGIyOCwgMHgyYmI0NWE5MiwgMHg1Y2IzNmEwNCwgMHhjMmQ3ZmZhNywgMHhiNWQwY2YzMSwgMHgyY2Q5OWU4YiwgMHg1YmRlYWUxZCxcbiAgICAweDliNjRjMmIwLCAweGVjNjNmMjI2LCAweDc1NmFhMzljLCAweDAyNmQ5MzBhLCAweDljMDkwNmE5LCAweGViMGUzNjNmLCAweDcyMDc2Nzg1LCAweDA1MDA1NzEzLFxuICAgIDB4OTViZjRhODIsIDB4ZTJiODdhMTQsIDB4N2JiMTJiYWUsIDB4MGNiNjFiMzgsIDB4OTJkMjhlOWIsIDB4ZTVkNWJlMGQsIDB4N2NkY2VmYjcsIDB4MGJkYmRmMjEsXG4gICAgMHg4NmQzZDJkNCwgMHhmMWQ0ZTI0MiwgMHg2OGRkYjNmOCwgMHgxZmRhODM2ZSwgMHg4MWJlMTZjZCwgMHhmNmI5MjY1YiwgMHg2ZmIwNzdlMSwgMHgxOGI3NDc3NyxcbiAgICAweDg4MDg1YWU2LCAweGZmMGY2YTcwLCAweDY2MDYzYmNhLCAweDExMDEwYjVjLCAweDhmNjU5ZWZmLCAweGY4NjJhZTY5LCAweDYxNmJmZmQzLCAweDE2NmNjZjQ1LFxuICAgIDB4YTAwYWUyNzgsIDB4ZDcwZGQyZWUsIDB4NGUwNDgzNTQsIDB4MzkwM2IzYzIsIDB4YTc2NzI2NjEsIDB4ZDA2MDE2ZjcsIDB4NDk2OTQ3NGQsIDB4M2U2ZTc3ZGIsXG4gICAgMHhhZWQxNmE0YSwgMHhkOWQ2NWFkYywgMHg0MGRmMGI2NiwgMHgzN2Q4M2JmMCwgMHhhOWJjYWU1MywgMHhkZWJiOWVjNSwgMHg0N2IyY2Y3ZiwgMHgzMGI1ZmZlOSxcbiAgICAweGJkYmRmMjFjLCAweGNhYmFjMjhhLCAweDUzYjM5MzMwLCAweDI0YjRhM2E2LCAweGJhZDAzNjA1LCAweGNkZDcwNjkzLCAweDU0ZGU1NzI5LCAweDIzZDk2N2JmLFxuICAgIDB4YjM2NjdhMmUsIDB4YzQ2MTRhYjgsIDB4NWQ2ODFiMDIsIDB4MmE2ZjJiOTQsIDB4YjQwYmJlMzcsIDB4YzMwYzhlYTEsIDB4NWEwNWRmMWIsIDB4MmQwMmVmOGQsXG5dKTtcbi8qKlxuICogQ2FsY3VsYXRlIHRoZSBDUkMzMiBvZiBhIFVpbnQ4QXJyYXkuXG4gKiBAcGFyYW0gYnVmIFRoZSBVaW50OEFycmF5IHRvIGNhbGN1bGF0ZSB0aGUgQ1JDMzIgb2YuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRDcmMzMihidWYpIHtcbiAgICBsZXQgY3JjID0gLTE7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBidWYubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYnl0ZSA9IGJ1ZltpXTtcbiAgICAgICAgY29uc3QgdCA9IChieXRlIF4gY3JjKSAmIDB4ZmY7XG4gICAgICAgIGNyYyA9IGxvb2tVcFRhYmxlW3RdIF4gKGNyYyA+Pj4gOCk7XG4gICAgfVxuICAgIHJldHVybiAoY3JjIF4gLTEpID4+PiAwO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0Q3JjLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../packages/sdk-js/node_modules/@dfinity/principal/lib/esm/utils/getCrc.js\n");

/***/ })

};
;