"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/../../packages/sdk-js/dist/index.js":
/*!*******************************************!*\
  !*** ../../packages/sdk-js/dist/index.js ***!
  \*******************************************/
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getAnchorStatus: function() { return /* binding */ getAnchorStatus; },\n/* harmony export */   getDualLockStatus: function() { return /* binding */ getDualLockStatus; },\n/* harmony export */   getEVMTransactionStatus: function() { return /* binding */ getEVMTransactionStatus; },\n/* harmony export */   getOrdinalPresence: function() { return /* binding */ getOrdinalPresence; },\n/* harmony export */   getSupportedChains: function() { return /* binding */ getSupportedChains; },\n/* harmony export */   initializeEVMRPC: function() { return /* binding */ initializeEVMRPC; },\n/* harmony export */   submitForAnchoring: function() { return /* binding */ submitForAnchoring; }\n/* harmony export */ });\n/* harmony import */ var _dfinity_agent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @dfinity/agent */ \"(app-pages-browser)/../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/agent/http/index.js\");\n/* harmony import */ var _dfinity_agent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @dfinity/agent */ \"(app-pages-browser)/../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/actor.js\");\n// @iqube/sdk-js - SDK for interacting with iQube services\n\nconst CANISTER_CONFIG = {\n    proof_of_state: {\n        canisterId: \"umunu-kh777-77774-qaaca-cai\",\n        host: \"http://127.0.0.1:4943\"\n    },\n    btc_signer_psbt: {\n        canisterId: \"uxrrr-q7777-77774-qaaaq-cai\",\n        host: \"http://127.0.0.1:4943\"\n    },\n    cross_chain_service: {\n        canisterId: \"u6s2n-gx777-77774-qaaba-cai\",\n        host: \"http://127.0.0.1:4943\"\n    },\n    evm_rpc: {\n        canisterId: \"uzt4z-lp777-77774-qaabq-cai\",\n        host: \"http://127.0.0.1:4943\"\n    }\n};\n// Candid interface definitions\nconst proofOfStateIDL = (param)=>{\n    let { IDL } = param;\n    const Receipt = IDL.Record({\n        \"id\": IDL.Text,\n        \"data_hash\": IDL.Text,\n        \"timestamp\": IDL.Nat64,\n        \"merkle_proof\": IDL.Vec(IDL.Text)\n    });\n    const MerkleBatch = IDL.Record({\n        \"root\": IDL.Text,\n        \"receipts\": IDL.Vec(Receipt),\n        \"created_at\": IDL.Nat64,\n        \"btc_anchor_txid\": IDL.Opt(IDL.Text),\n        \"btc_block_height\": IDL.Opt(IDL.Nat64)\n    });\n    return IDL.Service({\n        \"issue_receipt\": IDL.Func([\n            IDL.Text\n        ], [\n            IDL.Text\n        ], []),\n        \"batch\": IDL.Func([], [\n            IDL.Text\n        ], []),\n        \"anchor\": IDL.Func([], [\n            IDL.Text\n        ], []),\n        \"get_receipt\": IDL.Func([\n            IDL.Text\n        ], [\n            IDL.Opt(Receipt)\n        ], [\n            \"query\"\n        ]),\n        \"get_batches\": IDL.Func([], [\n            IDL.Vec(MerkleBatch)\n        ], [\n            \"query\"\n        ]),\n        \"get_pending_count\": IDL.Func([], [\n            IDL.Nat64\n        ], [\n            \"query\"\n        ])\n    });\n};\nconst crossChainServiceIDL = (param)=>{\n    let { IDL } = param;\n    const DVNMessage = IDL.Record({\n        \"id\": IDL.Text,\n        \"source_chain\": IDL.Text,\n        \"destination_chain\": IDL.Text,\n        \"payload\": IDL.Text,\n        \"created_at\": IDL.Nat64\n    });\n    return IDL.Service({\n        \"get_pending_messages\": IDL.Func([], [\n            IDL.Vec(DVNMessage)\n        ], [\n            \"query\"\n        ]),\n        \"get_ready_messages\": IDL.Func([], [\n            IDL.Vec(DVNMessage)\n        ], [\n            \"query\"\n        ])\n    });\n};\n// Create agent and actors for live canister calls\nlet agent = null;\nlet proofOfStateActor = null;\nlet crossChainServiceActor = null;\nasync function getAgent() {\n    if (!agent) {\n        agent = new _dfinity_agent__WEBPACK_IMPORTED_MODULE_0__.HttpAgent({\n            host: \"http://127.0.0.1:4943\",\n            verifyQuerySignatures: false // Disable signature verification for local development\n        });\n        // Fetch root key for local development\n        try {\n            await agent.fetchRootKey();\n        } catch (error) {\n            console.warn(\"Failed to fetch root key, continuing without verification:\", error);\n        }\n    }\n    return agent;\n}\nasync function getProofOfStateActor() {\n    if (!proofOfStateActor) {\n        const agentInstance = await getAgent();\n        proofOfStateActor = _dfinity_agent__WEBPACK_IMPORTED_MODULE_1__.Actor.createActor(proofOfStateIDL, {\n            agent: agentInstance,\n            canisterId: CANISTER_CONFIG.proof_of_state.canisterId\n        });\n    }\n    return proofOfStateActor;\n}\nasync function getCrossChainServiceActor() {\n    if (!crossChainServiceActor) {\n        const agentInstance = await getAgent();\n        crossChainServiceActor = _dfinity_agent__WEBPACK_IMPORTED_MODULE_1__.Actor.createActor(crossChainServiceIDL, {\n            agent: agentInstance,\n            canisterId: CANISTER_CONFIG.cross_chain_service.canisterId\n        });\n    }\n    return crossChainServiceActor;\n}\nasync function callICPCanister(canister, method) {\n    let args = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];\n    try {\n        if (canister === \"proof_of_state\") {\n            const actor = await getProofOfStateActor();\n            return await actor[method](...args);\n        } else if (canister === \"cross_chain_service\") {\n            const actor = await getCrossChainServiceActor();\n            return await actor[method](...args);\n        }\n        // Fallback for other canisters\n        return null;\n    } catch (error) {\n        console.warn(\"ICP canister call failed for \".concat(canister, \".\").concat(method, \":\"), error instanceof Error ? error.message : error);\n        // For proof_of_state get_batches, return hardcoded live data from the actual canister\n        if (canister === \"proof_of_state\" && method === \"get_batches\") {\n            return [\n                {\n                    root: \"200c03bfeb3d63a3c7d579b298da2bb8d14ec0e1a0d4693b0e658df8755dcd4c\",\n                    created_at: 1757976412825515000n,\n                    btc_anchor_txid: \"mock_btc_txid_200c03bf\",\n                    btc_block_height: 800000n,\n                    receipts: [\n                        {\n                            id: \"receipt_1757976411384398000\",\n                            timestamp: 1757976411384398000n,\n                            data_hash: \"dfx canister call btc_signer_psbt get_public_key\",\n                            merkle_proof: []\n                        }\n                    ]\n                }\n            ];\n        }\n        return null;\n    }\n}\nasync function getAnchorStatus(iQubeId) {\n    try {\n        // Get latest batch info directly - this is more reliable than individual receipts\n        const batches = await callICPCanister(\"proof_of_state\", \"get_batches\", []);\n        if (batches && batches.length > 0) {\n            const latestBatch = batches[batches.length - 1];\n            if (latestBatch.btc_anchor_txid) {\n                return {\n                    btcTxHash: latestBatch.btc_anchor_txid,\n                    confirmations: 6,\n                    blockHeight: Number(latestBatch.btc_block_height) || 800000,\n                    isConfirmed: true\n                };\n            } else {\n                // Batch exists but no BTC anchor yet\n                return {\n                    btcTxHash: \"pending_anchor_\".concat(latestBatch.root.slice(0, 12)),\n                    confirmations: 0,\n                    blockHeight: 0,\n                    isConfirmed: false\n                };\n            }\n        }\n    } catch (error) {\n        console.warn(\"Failed to get real anchor status, using fallback:\", error);\n    }\n    // Fallback to mock data only if canister call completely fails\n    return {\n        btcTxHash: \"mock_btc_txid_\" + iQubeId.slice(-8),\n        confirmations: 6,\n        blockHeight: 850000,\n        isConfirmed: true\n    };\n}\nasync function getDualLockStatus(iQubeId) {\n    try {\n        // Try to get real dual lock status from cross_chain_service canister\n        const pendingMessages = await callICPCanister(\"cross_chain_service\", \"get_pending_messages\", []);\n        if (pendingMessages && pendingMessages.length > 0) {\n            var _message_id;\n            const message = pendingMessages[0];\n            return {\n                evmTxHash: \"live_evm_tx_\".concat(((_message_id = message.id) === null || _message_id === void 0 ? void 0 : _message_id.slice(-8)) || \"pending\"),\n                icpReceiptId: message.id || \"live_icp_receipt\",\n                isLocked: false,\n                unlockHeight: 851000\n            };\n        }\n        // Also try to get ready messages (messages with enough attestations)\n        const readyMessages = await callICPCanister(\"cross_chain_service\", \"get_ready_messages\", []);\n        if (readyMessages && readyMessages.length > 0) {\n            var _latestMessage_id;\n            const latestMessage = readyMessages[readyMessages.length - 1];\n            return {\n                evmTxHash: \"live_cross_chain_\".concat(((_latestMessage_id = latestMessage.id) === null || _latestMessage_id === void 0 ? void 0 : _latestMessage_id.slice(-8)) || \"ready\"),\n                icpReceiptId: latestMessage.id || \"live_ready_receipt\",\n                isLocked: true,\n                unlockHeight: 851000\n            };\n        }\n        // If no messages, show that cross-chain service is live but empty\n        return {\n            evmTxHash: \"live_no_pending_messages\",\n            icpReceiptId: \"live_cross_chain_empty\",\n            isLocked: false,\n            unlockHeight: 851000\n        };\n    } catch (error) {\n        console.warn(\"Failed to get real dual lock status, using fallback:\", error);\n    }\n    // Fallback to mock data only if canister call completely fails\n    return {\n        evmTxHash: \"mock_evm_tx_hash_\" + iQubeId.slice(-8),\n        icpReceiptId: \"mock_icp_receipt_\" + iQubeId.slice(-8),\n        isLocked: true,\n        unlockHeight: 851000\n    };\n}\n// New function to submit data for anchoring\nasync function submitForAnchoring(data, metadata) {\n    try {\n        // Use the correct method name from our canister\n        const receiptId = await callICPCanister(\"proof_of_state\", \"issue_receipt\", [\n            data\n        ]);\n        if (receiptId) {\n            // Also trigger batching and anchoring\n            const batchRoot = await callICPCanister(\"proof_of_state\", \"batch\", []);\n            if (batchRoot) {\n                // Trigger anchoring\n                await callICPCanister(\"proof_of_state\", \"anchor\", []);\n            }\n            return {\n                receiptId: receiptId,\n                batchId: batchRoot || undefined\n            };\n        }\n    } catch (error) {\n        console.warn(\"Failed to submit for anchoring:\", error);\n    }\n    // Fallback to mock\n    return {\n        receiptId: \"mock_receipt_\" + Date.now(),\n        batchId: \"mock_batch_\" + Date.now()\n    };\n}\n// New function to check EVM transaction status\nasync function getEVMTransactionStatus(chainId, txHash) {\n    try {\n        const result = await callICPCanister(\"evm_rpc\", \"get_transaction_receipt\", [\n            chainId,\n            txHash\n        ]);\n        if (result && result.Ok) {\n            const receipt = result.Ok;\n            return {\n                confirmed: receipt.status,\n                blockNumber: receipt.block_number,\n                gasUsed: receipt.gas_used\n            };\n        }\n    } catch (error) {\n        console.warn(\"Failed to get EVM transaction status:\", error);\n    }\n    // Fallback to mock\n    return {\n        confirmed: true,\n        blockNumber: 18500000,\n        gasUsed: 21000\n    };\n}\nasync function getOrdinalPresence(iqubeId) {\n    // TODO: query ordinal adapter\n    return false;\n}\n// Function to initialize EVM RPC canister\nasync function initializeEVMRPC() {\n    try {\n        await callICPCanister(\"evm_rpc\", \"init_chain_configs\", []);\n    } catch (error) {\n        console.warn(\"Failed to initialize EVM RPC:\", error);\n    }\n}\n// Function to get supported chains\nasync function getSupportedChains() {\n    try {\n        const chains = await callICPCanister(\"evm_rpc\", \"get_supported_chains\", []);\n        return chains || [];\n    } catch (error) {\n        console.warn(\"Failed to get supported chains:\", error);\n        return [];\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = __webpack_module__.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = __webpack_module__.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, __webpack_module__.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                __webpack_module__.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                __webpack_module__.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        __webpack_module__.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    __webpack_module__.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9wYWNrYWdlcy9zZGstanMvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQSwwREFBMEQ7QUFDUjtBQUNsRCxNQUFNRSxrQkFBa0I7SUFDcEJDLGdCQUFnQjtRQUNaQyxZQUFZO1FBQ1pDLE1BQU07SUFDVjtJQUNBQyxpQkFBaUI7UUFDYkYsWUFBWTtRQUNaQyxNQUFNO0lBQ1Y7SUFDQUUscUJBQXFCO1FBQ2pCSCxZQUFZO1FBQ1pDLE1BQU07SUFDVjtJQUNBRyxTQUFTO1FBQ0xKLFlBQVk7UUFDWkMsTUFBTTtJQUNWO0FBQ0o7QUFDQSwrQkFBK0I7QUFDL0IsTUFBTUksa0JBQWtCO1FBQUMsRUFBRUMsR0FBRyxFQUFFO0lBQzVCLE1BQU1DLFVBQVVELElBQUlFLE1BQU0sQ0FBQztRQUN2QixNQUFNRixJQUFJRyxJQUFJO1FBQ2QsYUFBYUgsSUFBSUcsSUFBSTtRQUNyQixhQUFhSCxJQUFJSSxLQUFLO1FBQ3RCLGdCQUFnQkosSUFBSUssR0FBRyxDQUFDTCxJQUFJRyxJQUFJO0lBQ3BDO0lBQ0EsTUFBTUcsY0FBY04sSUFBSUUsTUFBTSxDQUFDO1FBQzNCLFFBQVFGLElBQUlHLElBQUk7UUFDaEIsWUFBWUgsSUFBSUssR0FBRyxDQUFDSjtRQUNwQixjQUFjRCxJQUFJSSxLQUFLO1FBQ3ZCLG1CQUFtQkosSUFBSU8sR0FBRyxDQUFDUCxJQUFJRyxJQUFJO1FBQ25DLG9CQUFvQkgsSUFBSU8sR0FBRyxDQUFDUCxJQUFJSSxLQUFLO0lBQ3pDO0lBQ0EsT0FBT0osSUFBSVEsT0FBTyxDQUFDO1FBQ2YsaUJBQWlCUixJQUFJUyxJQUFJLENBQUM7WUFBQ1QsSUFBSUcsSUFBSTtTQUFDLEVBQUU7WUFBQ0gsSUFBSUcsSUFBSTtTQUFDLEVBQUUsRUFBRTtRQUNwRCxTQUFTSCxJQUFJUyxJQUFJLENBQUMsRUFBRSxFQUFFO1lBQUNULElBQUlHLElBQUk7U0FBQyxFQUFFLEVBQUU7UUFDcEMsVUFBVUgsSUFBSVMsSUFBSSxDQUFDLEVBQUUsRUFBRTtZQUFDVCxJQUFJRyxJQUFJO1NBQUMsRUFBRSxFQUFFO1FBQ3JDLGVBQWVILElBQUlTLElBQUksQ0FBQztZQUFDVCxJQUFJRyxJQUFJO1NBQUMsRUFBRTtZQUFDSCxJQUFJTyxHQUFHLENBQUNOO1NBQVMsRUFBRTtZQUFDO1NBQVE7UUFDakUsZUFBZUQsSUFBSVMsSUFBSSxDQUFDLEVBQUUsRUFBRTtZQUFDVCxJQUFJSyxHQUFHLENBQUNDO1NBQWEsRUFBRTtZQUFDO1NBQVE7UUFDN0QscUJBQXFCTixJQUFJUyxJQUFJLENBQUMsRUFBRSxFQUFFO1lBQUNULElBQUlJLEtBQUs7U0FBQyxFQUFFO1lBQUM7U0FBUTtJQUM1RDtBQUNKO0FBQ0EsTUFBTU0sdUJBQXVCO1FBQUMsRUFBRVYsR0FBRyxFQUFFO0lBQ2pDLE1BQU1XLGFBQWFYLElBQUlFLE1BQU0sQ0FBQztRQUMxQixNQUFNRixJQUFJRyxJQUFJO1FBQ2QsZ0JBQWdCSCxJQUFJRyxJQUFJO1FBQ3hCLHFCQUFxQkgsSUFBSUcsSUFBSTtRQUM3QixXQUFXSCxJQUFJRyxJQUFJO1FBQ25CLGNBQWNILElBQUlJLEtBQUs7SUFDM0I7SUFDQSxPQUFPSixJQUFJUSxPQUFPLENBQUM7UUFDZix3QkFBd0JSLElBQUlTLElBQUksQ0FBQyxFQUFFLEVBQUU7WUFBQ1QsSUFBSUssR0FBRyxDQUFDTTtTQUFZLEVBQUU7WUFBQztTQUFRO1FBQ3JFLHNCQUFzQlgsSUFBSVMsSUFBSSxDQUFDLEVBQUUsRUFBRTtZQUFDVCxJQUFJSyxHQUFHLENBQUNNO1NBQVksRUFBRTtZQUFDO1NBQVE7SUFDdkU7QUFDSjtBQUNBLGtEQUFrRDtBQUNsRCxJQUFJQyxRQUFRO0FBQ1osSUFBSUMsb0JBQW9CO0FBQ3hCLElBQUlDLHlCQUF5QjtBQUM3QixlQUFlQztJQUNYLElBQUksQ0FBQ0gsT0FBTztRQUNSQSxRQUFRLElBQUl0QixxREFBU0EsQ0FBQztZQUNsQkssTUFBTTtZQUNOcUIsdUJBQXVCLE1BQU0sdURBQXVEO1FBQ3hGO1FBQ0EsdUNBQXVDO1FBQ3ZDLElBQUk7WUFDQSxNQUFNSixNQUFNSyxZQUFZO1FBQzVCLEVBQ0EsT0FBT0MsT0FBTztZQUNWQyxRQUFRQyxJQUFJLENBQUMsOERBQThERjtRQUMvRTtJQUNKO0lBQ0EsT0FBT047QUFDWDtBQUNBLGVBQWVTO0lBQ1gsSUFBSSxDQUFDUixtQkFBbUI7UUFDcEIsTUFBTVMsZ0JBQWdCLE1BQU1QO1FBQzVCRixvQkFBb0J0QixpREFBS0EsQ0FBQ2dDLFdBQVcsQ0FBQ3hCLGlCQUFpQjtZQUNuRGEsT0FBT1U7WUFDUDVCLFlBQVlGLGdCQUFnQkMsY0FBYyxDQUFDQyxVQUFVO1FBQ3pEO0lBQ0o7SUFDQSxPQUFPbUI7QUFDWDtBQUNBLGVBQWVXO0lBQ1gsSUFBSSxDQUFDVix3QkFBd0I7UUFDekIsTUFBTVEsZ0JBQWdCLE1BQU1QO1FBQzVCRCx5QkFBeUJ2QixpREFBS0EsQ0FBQ2dDLFdBQVcsQ0FBQ2Isc0JBQXNCO1lBQzdERSxPQUFPVTtZQUNQNUIsWUFBWUYsZ0JBQWdCSyxtQkFBbUIsQ0FBQ0gsVUFBVTtRQUM5RDtJQUNKO0lBQ0EsT0FBT29CO0FBQ1g7QUFDQSxlQUFlVyxnQkFBZ0JDLFFBQVEsRUFBRUMsTUFBTTtRQUFFQyxPQUFBQSxpRUFBTyxFQUFFO0lBQ3RELElBQUk7UUFDQSxJQUFJRixhQUFhLGtCQUFrQjtZQUMvQixNQUFNRyxRQUFRLE1BQU1SO1lBQ3BCLE9BQU8sTUFBTVEsS0FBSyxDQUFDRixPQUFPLElBQUlDO1FBQ2xDLE9BQ0ssSUFBSUYsYUFBYSx1QkFBdUI7WUFDekMsTUFBTUcsUUFBUSxNQUFNTDtZQUNwQixPQUFPLE1BQU1LLEtBQUssQ0FBQ0YsT0FBTyxJQUFJQztRQUNsQztRQUNBLCtCQUErQjtRQUMvQixPQUFPO0lBQ1gsRUFDQSxPQUFPVixPQUFPO1FBQ1ZDLFFBQVFDLElBQUksQ0FBQyxnQ0FBNENPLE9BQVpELFVBQVMsS0FBVSxPQUFQQyxRQUFPLE1BQUlULGlCQUFpQlksUUFBUVosTUFBTWEsT0FBTyxHQUFHYjtRQUM3RyxzRkFBc0Y7UUFDdEYsSUFBSVEsYUFBYSxvQkFBb0JDLFdBQVcsZUFBZTtZQUMzRCxPQUFPO2dCQUFDO29CQUNBSyxNQUFNO29CQUNOQyxZQUFZLG9CQUFvQjtvQkFDaENDLGlCQUFpQjtvQkFDakJDLGtCQUFrQixPQUFPO29CQUN6QkMsVUFBVTt3QkFBQzs0QkFDSEMsSUFBSTs0QkFDSkMsV0FBVyxvQkFBb0I7NEJBQy9CQyxXQUFXOzRCQUNYQyxjQUFjLEVBQUU7d0JBQ3BCO3FCQUFFO2dCQUNWO2FBQUU7UUFDVjtRQUNBLE9BQU87SUFDWDtBQUNKO0FBQ08sZUFBZUMsZ0JBQWdCQyxPQUFPO0lBQ3pDLElBQUk7UUFDQSxrRkFBa0Y7UUFDbEYsTUFBTUMsVUFBVSxNQUFNbEIsZ0JBQWdCLGtCQUFrQixlQUFlLEVBQUU7UUFDekUsSUFBSWtCLFdBQVdBLFFBQVFDLE1BQU0sR0FBRyxHQUFHO1lBQy9CLE1BQU1DLGNBQWNGLE9BQU8sQ0FBQ0EsUUFBUUMsTUFBTSxHQUFHLEVBQUU7WUFDL0MsSUFBSUMsWUFBWVgsZUFBZSxFQUFFO2dCQUM3QixPQUFPO29CQUNIWSxXQUFXRCxZQUFZWCxlQUFlO29CQUN0Q2EsZUFBZTtvQkFDZkMsYUFBYUMsT0FBT0osWUFBWVYsZ0JBQWdCLEtBQUs7b0JBQ3JEZSxhQUFhO2dCQUNqQjtZQUNKLE9BQ0s7Z0JBQ0QscUNBQXFDO2dCQUNyQyxPQUFPO29CQUNISixXQUFXLGtCQUFnRCxPQUE5QkQsWUFBWWIsSUFBSSxDQUFDbUIsS0FBSyxDQUFDLEdBQUc7b0JBQ3ZESixlQUFlO29CQUNmQyxhQUFhO29CQUNiRSxhQUFhO2dCQUNqQjtZQUNKO1FBQ0o7SUFDSixFQUNBLE9BQU9oQyxPQUFPO1FBQ1ZDLFFBQVFDLElBQUksQ0FBQyxxREFBcURGO0lBQ3RFO0lBQ0EsK0RBQStEO0lBQy9ELE9BQU87UUFDSDRCLFdBQVcsbUJBQW1CSixRQUFRUyxLQUFLLENBQUMsQ0FBQztRQUM3Q0osZUFBZTtRQUNmQyxhQUFhO1FBQ2JFLGFBQWE7SUFDakI7QUFDSjtBQUNPLGVBQWVFLGtCQUFrQlYsT0FBTztJQUMzQyxJQUFJO1FBQ0EscUVBQXFFO1FBQ3JFLE1BQU1XLGtCQUFrQixNQUFNNUIsZ0JBQWdCLHVCQUF1Qix3QkFBd0IsRUFBRTtRQUMvRixJQUFJNEIsbUJBQW1CQSxnQkFBZ0JULE1BQU0sR0FBRyxHQUFHO2dCQUdqQmI7WUFGOUIsTUFBTUEsVUFBVXNCLGVBQWUsQ0FBQyxFQUFFO1lBQ2xDLE9BQU87Z0JBQ0hDLFdBQVcsZUFBa0QsT0FBbkN2QixFQUFBQSxjQUFBQSxRQUFRTSxFQUFFLGNBQVZOLGtDQUFBQSxZQUFZb0IsS0FBSyxDQUFDLENBQUMsT0FBTTtnQkFDbkRJLGNBQWN4QixRQUFRTSxFQUFFLElBQUk7Z0JBQzVCbUIsVUFBVTtnQkFDVkMsY0FBYztZQUNsQjtRQUNKO1FBQ0EscUVBQXFFO1FBQ3JFLE1BQU1DLGdCQUFnQixNQUFNakMsZ0JBQWdCLHVCQUF1QixzQkFBc0IsRUFBRTtRQUMzRixJQUFJaUMsaUJBQWlCQSxjQUFjZCxNQUFNLEdBQUcsR0FBRztnQkFHUmU7WUFGbkMsTUFBTUEsZ0JBQWdCRCxhQUFhLENBQUNBLGNBQWNkLE1BQU0sR0FBRyxFQUFFO1lBQzdELE9BQU87Z0JBQ0hVLFdBQVcsb0JBQTJELE9BQXZDSyxFQUFBQSxvQkFBQUEsY0FBY3RCLEVBQUUsY0FBaEJzQix3Q0FBQUEsa0JBQWtCUixLQUFLLENBQUMsQ0FBQyxPQUFNO2dCQUM5REksY0FBY0ksY0FBY3RCLEVBQUUsSUFBSTtnQkFDbENtQixVQUFVO2dCQUNWQyxjQUFjO1lBQ2xCO1FBQ0o7UUFDQSxrRUFBa0U7UUFDbEUsT0FBTztZQUNISCxXQUFXO1lBQ1hDLGNBQWM7WUFDZEMsVUFBVTtZQUNWQyxjQUFjO1FBQ2xCO0lBQ0osRUFDQSxPQUFPdkMsT0FBTztRQUNWQyxRQUFRQyxJQUFJLENBQUMsd0RBQXdERjtJQUN6RTtJQUNBLCtEQUErRDtJQUMvRCxPQUFPO1FBQ0hvQyxXQUFXLHNCQUFzQlosUUFBUVMsS0FBSyxDQUFDLENBQUM7UUFDaERJLGNBQWMsc0JBQXNCYixRQUFRUyxLQUFLLENBQUMsQ0FBQztRQUNuREssVUFBVTtRQUNWQyxjQUFjO0lBQ2xCO0FBQ0o7QUFDQSw0Q0FBNEM7QUFDckMsZUFBZUcsbUJBQW1CQyxJQUFJLEVBQUVDLFFBQVE7SUFDbkQsSUFBSTtRQUNBLGdEQUFnRDtRQUNoRCxNQUFNQyxZQUFZLE1BQU10QyxnQkFBZ0Isa0JBQWtCLGlCQUFpQjtZQUFDb0M7U0FBSztRQUNqRixJQUFJRSxXQUFXO1lBQ1gsc0NBQXNDO1lBQ3RDLE1BQU1DLFlBQVksTUFBTXZDLGdCQUFnQixrQkFBa0IsU0FBUyxFQUFFO1lBQ3JFLElBQUl1QyxXQUFXO2dCQUNYLG9CQUFvQjtnQkFDcEIsTUFBTXZDLGdCQUFnQixrQkFBa0IsVUFBVSxFQUFFO1lBQ3hEO1lBQ0EsT0FBTztnQkFDSHNDLFdBQVdBO2dCQUNYRSxTQUFTRCxhQUFhRTtZQUMxQjtRQUNKO0lBQ0osRUFDQSxPQUFPaEQsT0FBTztRQUNWQyxRQUFRQyxJQUFJLENBQUMsbUNBQW1DRjtJQUNwRDtJQUNBLG1CQUFtQjtJQUNuQixPQUFPO1FBQ0g2QyxXQUFXLGtCQUFrQkksS0FBS0MsR0FBRztRQUNyQ0gsU0FBUyxnQkFBZ0JFLEtBQUtDLEdBQUc7SUFDckM7QUFDSjtBQUNBLCtDQUErQztBQUN4QyxlQUFlQyx3QkFBd0JDLE9BQU8sRUFBRUMsTUFBTTtJQUN6RCxJQUFJO1FBQ0EsTUFBTUMsU0FBUyxNQUFNL0MsZ0JBQWdCLFdBQVcsMkJBQTJCO1lBQUM2QztZQUFTQztTQUFPO1FBQzVGLElBQUlDLFVBQVVBLE9BQU9DLEVBQUUsRUFBRTtZQUNyQixNQUFNQyxVQUFVRixPQUFPQyxFQUFFO1lBQ3pCLE9BQU87Z0JBQ0hFLFdBQVdELFFBQVFFLE1BQU07Z0JBQ3pCQyxhQUFhSCxRQUFRSSxZQUFZO2dCQUNqQ0MsU0FBU0wsUUFBUU0sUUFBUTtZQUM3QjtRQUNKO0lBQ0osRUFDQSxPQUFPOUQsT0FBTztRQUNWQyxRQUFRQyxJQUFJLENBQUMseUNBQXlDRjtJQUMxRDtJQUNBLG1CQUFtQjtJQUNuQixPQUFPO1FBQ0h5RCxXQUFXO1FBQ1hFLGFBQWE7UUFDYkUsU0FBUztJQUNiO0FBQ0o7QUFDTyxlQUFlRSxtQkFBbUJDLE9BQU87SUFDNUMsOEJBQThCO0lBQzlCLE9BQU87QUFDWDtBQUNBLDBDQUEwQztBQUNuQyxlQUFlQztJQUNsQixJQUFJO1FBQ0EsTUFBTTFELGdCQUFnQixXQUFXLHNCQUFzQixFQUFFO0lBQzdELEVBQ0EsT0FBT1AsT0FBTztRQUNWQyxRQUFRQyxJQUFJLENBQUMsaUNBQWlDRjtJQUNsRDtBQUNKO0FBQ0EsbUNBQW1DO0FBQzVCLGVBQWVrRTtJQUNsQixJQUFJO1FBQ0EsTUFBTUMsU0FBUyxNQUFNNUQsZ0JBQWdCLFdBQVcsd0JBQXdCLEVBQUU7UUFDMUUsT0FBTzRELFVBQVUsRUFBRTtJQUN2QixFQUNBLE9BQU9uRSxPQUFPO1FBQ1ZDLFFBQVFDLElBQUksQ0FBQyxtQ0FBbUNGO1FBQ2hELE9BQU8sRUFBRTtJQUNiO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL3BhY2thZ2VzL3Nkay1qcy9kaXN0L2luZGV4LmpzPzdjYjAiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQGlxdWJlL3Nkay1qcyAtIFNESyBmb3IgaW50ZXJhY3Rpbmcgd2l0aCBpUXViZSBzZXJ2aWNlc1xuaW1wb3J0IHsgSHR0cEFnZW50LCBBY3RvciB9IGZyb20gJ0BkZmluaXR5L2FnZW50JztcbmNvbnN0IENBTklTVEVSX0NPTkZJRyA9IHtcbiAgICBwcm9vZl9vZl9zdGF0ZToge1xuICAgICAgICBjYW5pc3RlcklkOiAndW11bnUta2g3NzctNzc3NzQtcWFhY2EtY2FpJyxcbiAgICAgICAgaG9zdDogJ2h0dHA6Ly8xMjcuMC4wLjE6NDk0MycsXG4gICAgfSxcbiAgICBidGNfc2lnbmVyX3BzYnQ6IHtcbiAgICAgICAgY2FuaXN0ZXJJZDogJ3V4cnJyLXE3Nzc3LTc3Nzc0LXFhYWFxLWNhaScsXG4gICAgICAgIGhvc3Q6ICdodHRwOi8vMTI3LjAuMC4xOjQ5NDMnLFxuICAgIH0sXG4gICAgY3Jvc3NfY2hhaW5fc2VydmljZToge1xuICAgICAgICBjYW5pc3RlcklkOiAndTZzMm4tZ3g3NzctNzc3NzQtcWFhYmEtY2FpJyxcbiAgICAgICAgaG9zdDogJ2h0dHA6Ly8xMjcuMC4wLjE6NDk0MycsXG4gICAgfSxcbiAgICBldm1fcnBjOiB7XG4gICAgICAgIGNhbmlzdGVySWQ6ICd1enQ0ei1scDc3Ny03Nzc3NC1xYWFicS1jYWknLFxuICAgICAgICBob3N0OiAnaHR0cDovLzEyNy4wLjAuMTo0OTQzJyxcbiAgICB9LFxufTtcbi8vIENhbmRpZCBpbnRlcmZhY2UgZGVmaW5pdGlvbnNcbmNvbnN0IHByb29mT2ZTdGF0ZUlETCA9ICh7IElETCB9KSA9PiB7XG4gICAgY29uc3QgUmVjZWlwdCA9IElETC5SZWNvcmQoe1xuICAgICAgICAnaWQnOiBJREwuVGV4dCxcbiAgICAgICAgJ2RhdGFfaGFzaCc6IElETC5UZXh0LFxuICAgICAgICAndGltZXN0YW1wJzogSURMLk5hdDY0LFxuICAgICAgICAnbWVya2xlX3Byb29mJzogSURMLlZlYyhJREwuVGV4dCksXG4gICAgfSk7XG4gICAgY29uc3QgTWVya2xlQmF0Y2ggPSBJREwuUmVjb3JkKHtcbiAgICAgICAgJ3Jvb3QnOiBJREwuVGV4dCxcbiAgICAgICAgJ3JlY2VpcHRzJzogSURMLlZlYyhSZWNlaXB0KSxcbiAgICAgICAgJ2NyZWF0ZWRfYXQnOiBJREwuTmF0NjQsXG4gICAgICAgICdidGNfYW5jaG9yX3R4aWQnOiBJREwuT3B0KElETC5UZXh0KSxcbiAgICAgICAgJ2J0Y19ibG9ja19oZWlnaHQnOiBJREwuT3B0KElETC5OYXQ2NCksXG4gICAgfSk7XG4gICAgcmV0dXJuIElETC5TZXJ2aWNlKHtcbiAgICAgICAgJ2lzc3VlX3JlY2VpcHQnOiBJREwuRnVuYyhbSURMLlRleHRdLCBbSURMLlRleHRdLCBbXSksXG4gICAgICAgICdiYXRjaCc6IElETC5GdW5jKFtdLCBbSURMLlRleHRdLCBbXSksXG4gICAgICAgICdhbmNob3InOiBJREwuRnVuYyhbXSwgW0lETC5UZXh0XSwgW10pLFxuICAgICAgICAnZ2V0X3JlY2VpcHQnOiBJREwuRnVuYyhbSURMLlRleHRdLCBbSURMLk9wdChSZWNlaXB0KV0sIFsncXVlcnknXSksXG4gICAgICAgICdnZXRfYmF0Y2hlcyc6IElETC5GdW5jKFtdLCBbSURMLlZlYyhNZXJrbGVCYXRjaCldLCBbJ3F1ZXJ5J10pLFxuICAgICAgICAnZ2V0X3BlbmRpbmdfY291bnQnOiBJREwuRnVuYyhbXSwgW0lETC5OYXQ2NF0sIFsncXVlcnknXSksXG4gICAgfSk7XG59O1xuY29uc3QgY3Jvc3NDaGFpblNlcnZpY2VJREwgPSAoeyBJREwgfSkgPT4ge1xuICAgIGNvbnN0IERWTk1lc3NhZ2UgPSBJREwuUmVjb3JkKHtcbiAgICAgICAgJ2lkJzogSURMLlRleHQsXG4gICAgICAgICdzb3VyY2VfY2hhaW4nOiBJREwuVGV4dCxcbiAgICAgICAgJ2Rlc3RpbmF0aW9uX2NoYWluJzogSURMLlRleHQsXG4gICAgICAgICdwYXlsb2FkJzogSURMLlRleHQsXG4gICAgICAgICdjcmVhdGVkX2F0JzogSURMLk5hdDY0LFxuICAgIH0pO1xuICAgIHJldHVybiBJREwuU2VydmljZSh7XG4gICAgICAgICdnZXRfcGVuZGluZ19tZXNzYWdlcyc6IElETC5GdW5jKFtdLCBbSURMLlZlYyhEVk5NZXNzYWdlKV0sIFsncXVlcnknXSksXG4gICAgICAgICdnZXRfcmVhZHlfbWVzc2FnZXMnOiBJREwuRnVuYyhbXSwgW0lETC5WZWMoRFZOTWVzc2FnZSldLCBbJ3F1ZXJ5J10pLFxuICAgIH0pO1xufTtcbi8vIENyZWF0ZSBhZ2VudCBhbmQgYWN0b3JzIGZvciBsaXZlIGNhbmlzdGVyIGNhbGxzXG5sZXQgYWdlbnQgPSBudWxsO1xubGV0IHByb29mT2ZTdGF0ZUFjdG9yID0gbnVsbDtcbmxldCBjcm9zc0NoYWluU2VydmljZUFjdG9yID0gbnVsbDtcbmFzeW5jIGZ1bmN0aW9uIGdldEFnZW50KCkge1xuICAgIGlmICghYWdlbnQpIHtcbiAgICAgICAgYWdlbnQgPSBuZXcgSHR0cEFnZW50KHtcbiAgICAgICAgICAgIGhvc3Q6ICdodHRwOi8vMTI3LjAuMC4xOjQ5NDMnLFxuICAgICAgICAgICAgdmVyaWZ5UXVlcnlTaWduYXR1cmVzOiBmYWxzZSAvLyBEaXNhYmxlIHNpZ25hdHVyZSB2ZXJpZmljYXRpb24gZm9yIGxvY2FsIGRldmVsb3BtZW50XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBGZXRjaCByb290IGtleSBmb3IgbG9jYWwgZGV2ZWxvcG1lbnRcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IGFnZW50LmZldGNoUm9vdEtleSgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gZmV0Y2ggcm9vdCBrZXksIGNvbnRpbnVpbmcgd2l0aG91dCB2ZXJpZmljYXRpb246JywgZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhZ2VudDtcbn1cbmFzeW5jIGZ1bmN0aW9uIGdldFByb29mT2ZTdGF0ZUFjdG9yKCkge1xuICAgIGlmICghcHJvb2ZPZlN0YXRlQWN0b3IpIHtcbiAgICAgICAgY29uc3QgYWdlbnRJbnN0YW5jZSA9IGF3YWl0IGdldEFnZW50KCk7XG4gICAgICAgIHByb29mT2ZTdGF0ZUFjdG9yID0gQWN0b3IuY3JlYXRlQWN0b3IocHJvb2ZPZlN0YXRlSURMLCB7XG4gICAgICAgICAgICBhZ2VudDogYWdlbnRJbnN0YW5jZSxcbiAgICAgICAgICAgIGNhbmlzdGVySWQ6IENBTklTVEVSX0NPTkZJRy5wcm9vZl9vZl9zdGF0ZS5jYW5pc3RlcklkLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHByb29mT2ZTdGF0ZUFjdG9yO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2V0Q3Jvc3NDaGFpblNlcnZpY2VBY3RvcigpIHtcbiAgICBpZiAoIWNyb3NzQ2hhaW5TZXJ2aWNlQWN0b3IpIHtcbiAgICAgICAgY29uc3QgYWdlbnRJbnN0YW5jZSA9IGF3YWl0IGdldEFnZW50KCk7XG4gICAgICAgIGNyb3NzQ2hhaW5TZXJ2aWNlQWN0b3IgPSBBY3Rvci5jcmVhdGVBY3Rvcihjcm9zc0NoYWluU2VydmljZUlETCwge1xuICAgICAgICAgICAgYWdlbnQ6IGFnZW50SW5zdGFuY2UsXG4gICAgICAgICAgICBjYW5pc3RlcklkOiBDQU5JU1RFUl9DT05GSUcuY3Jvc3NfY2hhaW5fc2VydmljZS5jYW5pc3RlcklkLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGNyb3NzQ2hhaW5TZXJ2aWNlQWN0b3I7XG59XG5hc3luYyBmdW5jdGlvbiBjYWxsSUNQQ2FuaXN0ZXIoY2FuaXN0ZXIsIG1ldGhvZCwgYXJncyA9IFtdKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKGNhbmlzdGVyID09PSAncHJvb2Zfb2Zfc3RhdGUnKSB7XG4gICAgICAgICAgICBjb25zdCBhY3RvciA9IGF3YWl0IGdldFByb29mT2ZTdGF0ZUFjdG9yKCk7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgYWN0b3JbbWV0aG9kXSguLi5hcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjYW5pc3RlciA9PT0gJ2Nyb3NzX2NoYWluX3NlcnZpY2UnKSB7XG4gICAgICAgICAgICBjb25zdCBhY3RvciA9IGF3YWl0IGdldENyb3NzQ2hhaW5TZXJ2aWNlQWN0b3IoKTtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBhY3RvclttZXRob2RdKC4uLmFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZhbGxiYWNrIGZvciBvdGhlciBjYW5pc3RlcnNcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLndhcm4oYElDUCBjYW5pc3RlciBjYWxsIGZhaWxlZCBmb3IgJHtjYW5pc3Rlcn0uJHttZXRob2R9OmAsIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogZXJyb3IpO1xuICAgICAgICAvLyBGb3IgcHJvb2Zfb2Zfc3RhdGUgZ2V0X2JhdGNoZXMsIHJldHVybiBoYXJkY29kZWQgbGl2ZSBkYXRhIGZyb20gdGhlIGFjdHVhbCBjYW5pc3RlclxuICAgICAgICBpZiAoY2FuaXN0ZXIgPT09ICdwcm9vZl9vZl9zdGF0ZScgJiYgbWV0aG9kID09PSAnZ2V0X2JhdGNoZXMnKSB7XG4gICAgICAgICAgICByZXR1cm4gW3tcbiAgICAgICAgICAgICAgICAgICAgcm9vdDogXCIyMDBjMDNiZmViM2Q2M2EzYzdkNTc5YjI5OGRhMmJiOGQxNGVjMGUxYTBkNDY5M2IwZTY1OGRmODc1NWRjZDRjXCIsXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZWRfYXQ6IDE3NTc5NzY0MTI4MjU1MTUwMDBuLFxuICAgICAgICAgICAgICAgICAgICBidGNfYW5jaG9yX3R4aWQ6IFwibW9ja19idGNfdHhpZF8yMDBjMDNiZlwiLFxuICAgICAgICAgICAgICAgICAgICBidGNfYmxvY2tfaGVpZ2h0OiA4MDAwMDBuLFxuICAgICAgICAgICAgICAgICAgICByZWNlaXB0czogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogXCJyZWNlaXB0XzE3NTc5NzY0MTEzODQzOTgwMDBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IDE3NTc5NzY0MTEzODQzOTgwMDBuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFfaGFzaDogXCJkZnggY2FuaXN0ZXIgY2FsbCBidGNfc2lnbmVyX3BzYnQgZ2V0X3B1YmxpY19rZXlcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXJrbGVfcHJvb2Y6IFtdXG4gICAgICAgICAgICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgICAgIH1dO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRBbmNob3JTdGF0dXMoaVF1YmVJZCkge1xuICAgIHRyeSB7XG4gICAgICAgIC8vIEdldCBsYXRlc3QgYmF0Y2ggaW5mbyBkaXJlY3RseSAtIHRoaXMgaXMgbW9yZSByZWxpYWJsZSB0aGFuIGluZGl2aWR1YWwgcmVjZWlwdHNcbiAgICAgICAgY29uc3QgYmF0Y2hlcyA9IGF3YWl0IGNhbGxJQ1BDYW5pc3RlcigncHJvb2Zfb2Zfc3RhdGUnLCAnZ2V0X2JhdGNoZXMnLCBbXSk7XG4gICAgICAgIGlmIChiYXRjaGVzICYmIGJhdGNoZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgbGF0ZXN0QmF0Y2ggPSBiYXRjaGVzW2JhdGNoZXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBpZiAobGF0ZXN0QmF0Y2guYnRjX2FuY2hvcl90eGlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgYnRjVHhIYXNoOiBsYXRlc3RCYXRjaC5idGNfYW5jaG9yX3R4aWQsXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpcm1hdGlvbnM6IDYsXG4gICAgICAgICAgICAgICAgICAgIGJsb2NrSGVpZ2h0OiBOdW1iZXIobGF0ZXN0QmF0Y2guYnRjX2Jsb2NrX2hlaWdodCkgfHwgODAwMDAwLFxuICAgICAgICAgICAgICAgICAgICBpc0NvbmZpcm1lZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQmF0Y2ggZXhpc3RzIGJ1dCBubyBCVEMgYW5jaG9yIHlldFxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGJ0Y1R4SGFzaDogYHBlbmRpbmdfYW5jaG9yXyR7bGF0ZXN0QmF0Y2gucm9vdC5zbGljZSgwLCAxMil9YCxcbiAgICAgICAgICAgICAgICAgICAgY29uZmlybWF0aW9uczogMCxcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tIZWlnaHQ6IDAsXG4gICAgICAgICAgICAgICAgICAgIGlzQ29uZmlybWVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBnZXQgcmVhbCBhbmNob3Igc3RhdHVzLCB1c2luZyBmYWxsYmFjazonLCBlcnJvcik7XG4gICAgfVxuICAgIC8vIEZhbGxiYWNrIHRvIG1vY2sgZGF0YSBvbmx5IGlmIGNhbmlzdGVyIGNhbGwgY29tcGxldGVseSBmYWlsc1xuICAgIHJldHVybiB7XG4gICAgICAgIGJ0Y1R4SGFzaDogJ21vY2tfYnRjX3R4aWRfJyArIGlRdWJlSWQuc2xpY2UoLTgpLFxuICAgICAgICBjb25maXJtYXRpb25zOiA2LFxuICAgICAgICBibG9ja0hlaWdodDogODUwMDAwLFxuICAgICAgICBpc0NvbmZpcm1lZDogdHJ1ZSxcbiAgICB9O1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldER1YWxMb2NrU3RhdHVzKGlRdWJlSWQpIHtcbiAgICB0cnkge1xuICAgICAgICAvLyBUcnkgdG8gZ2V0IHJlYWwgZHVhbCBsb2NrIHN0YXR1cyBmcm9tIGNyb3NzX2NoYWluX3NlcnZpY2UgY2FuaXN0ZXJcbiAgICAgICAgY29uc3QgcGVuZGluZ01lc3NhZ2VzID0gYXdhaXQgY2FsbElDUENhbmlzdGVyKCdjcm9zc19jaGFpbl9zZXJ2aWNlJywgJ2dldF9wZW5kaW5nX21lc3NhZ2VzJywgW10pO1xuICAgICAgICBpZiAocGVuZGluZ01lc3NhZ2VzICYmIHBlbmRpbmdNZXNzYWdlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gcGVuZGluZ01lc3NhZ2VzWzBdO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBldm1UeEhhc2g6IGBsaXZlX2V2bV90eF8ke21lc3NhZ2UuaWQ/LnNsaWNlKC04KSB8fCAncGVuZGluZyd9YCxcbiAgICAgICAgICAgICAgICBpY3BSZWNlaXB0SWQ6IG1lc3NhZ2UuaWQgfHwgJ2xpdmVfaWNwX3JlY2VpcHQnLFxuICAgICAgICAgICAgICAgIGlzTG9ja2VkOiBmYWxzZSwgLy8gU3RpbGwgcGVuZGluZ1xuICAgICAgICAgICAgICAgIHVubG9ja0hlaWdodDogODUxMDAwLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBbHNvIHRyeSB0byBnZXQgcmVhZHkgbWVzc2FnZXMgKG1lc3NhZ2VzIHdpdGggZW5vdWdoIGF0dGVzdGF0aW9ucylcbiAgICAgICAgY29uc3QgcmVhZHlNZXNzYWdlcyA9IGF3YWl0IGNhbGxJQ1BDYW5pc3RlcignY3Jvc3NfY2hhaW5fc2VydmljZScsICdnZXRfcmVhZHlfbWVzc2FnZXMnLCBbXSk7XG4gICAgICAgIGlmIChyZWFkeU1lc3NhZ2VzICYmIHJlYWR5TWVzc2FnZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgbGF0ZXN0TWVzc2FnZSA9IHJlYWR5TWVzc2FnZXNbcmVhZHlNZXNzYWdlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZXZtVHhIYXNoOiBgbGl2ZV9jcm9zc19jaGFpbl8ke2xhdGVzdE1lc3NhZ2UuaWQ/LnNsaWNlKC04KSB8fCAncmVhZHknfWAsXG4gICAgICAgICAgICAgICAgaWNwUmVjZWlwdElkOiBsYXRlc3RNZXNzYWdlLmlkIHx8ICdsaXZlX3JlYWR5X3JlY2VpcHQnLFxuICAgICAgICAgICAgICAgIGlzTG9ja2VkOiB0cnVlLFxuICAgICAgICAgICAgICAgIHVubG9ja0hlaWdodDogODUxMDAwLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBubyBtZXNzYWdlcywgc2hvdyB0aGF0IGNyb3NzLWNoYWluIHNlcnZpY2UgaXMgbGl2ZSBidXQgZW1wdHlcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGV2bVR4SGFzaDogJ2xpdmVfbm9fcGVuZGluZ19tZXNzYWdlcycsXG4gICAgICAgICAgICBpY3BSZWNlaXB0SWQ6ICdsaXZlX2Nyb3NzX2NoYWluX2VtcHR5JyxcbiAgICAgICAgICAgIGlzTG9ja2VkOiBmYWxzZSxcbiAgICAgICAgICAgIHVubG9ja0hlaWdodDogODUxMDAwLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gZ2V0IHJlYWwgZHVhbCBsb2NrIHN0YXR1cywgdXNpbmcgZmFsbGJhY2s6JywgZXJyb3IpO1xuICAgIH1cbiAgICAvLyBGYWxsYmFjayB0byBtb2NrIGRhdGEgb25seSBpZiBjYW5pc3RlciBjYWxsIGNvbXBsZXRlbHkgZmFpbHNcbiAgICByZXR1cm4ge1xuICAgICAgICBldm1UeEhhc2g6ICdtb2NrX2V2bV90eF9oYXNoXycgKyBpUXViZUlkLnNsaWNlKC04KSxcbiAgICAgICAgaWNwUmVjZWlwdElkOiAnbW9ja19pY3BfcmVjZWlwdF8nICsgaVF1YmVJZC5zbGljZSgtOCksXG4gICAgICAgIGlzTG9ja2VkOiB0cnVlLFxuICAgICAgICB1bmxvY2tIZWlnaHQ6IDg1MTAwMCxcbiAgICB9O1xufVxuLy8gTmV3IGZ1bmN0aW9uIHRvIHN1Ym1pdCBkYXRhIGZvciBhbmNob3JpbmdcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzdWJtaXRGb3JBbmNob3JpbmcoZGF0YSwgbWV0YWRhdGEpIHtcbiAgICB0cnkge1xuICAgICAgICAvLyBVc2UgdGhlIGNvcnJlY3QgbWV0aG9kIG5hbWUgZnJvbSBvdXIgY2FuaXN0ZXJcbiAgICAgICAgY29uc3QgcmVjZWlwdElkID0gYXdhaXQgY2FsbElDUENhbmlzdGVyKCdwcm9vZl9vZl9zdGF0ZScsICdpc3N1ZV9yZWNlaXB0JywgW2RhdGFdKTtcbiAgICAgICAgaWYgKHJlY2VpcHRJZCkge1xuICAgICAgICAgICAgLy8gQWxzbyB0cmlnZ2VyIGJhdGNoaW5nIGFuZCBhbmNob3JpbmdcbiAgICAgICAgICAgIGNvbnN0IGJhdGNoUm9vdCA9IGF3YWl0IGNhbGxJQ1BDYW5pc3RlcigncHJvb2Zfb2Zfc3RhdGUnLCAnYmF0Y2gnLCBbXSk7XG4gICAgICAgICAgICBpZiAoYmF0Y2hSb290KSB7XG4gICAgICAgICAgICAgICAgLy8gVHJpZ2dlciBhbmNob3JpbmdcbiAgICAgICAgICAgICAgICBhd2FpdCBjYWxsSUNQQ2FuaXN0ZXIoJ3Byb29mX29mX3N0YXRlJywgJ2FuY2hvcicsIFtdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcmVjZWlwdElkOiByZWNlaXB0SWQsXG4gICAgICAgICAgICAgICAgYmF0Y2hJZDogYmF0Y2hSb290IHx8IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIHN1Ym1pdCBmb3IgYW5jaG9yaW5nOicsIGVycm9yKTtcbiAgICB9XG4gICAgLy8gRmFsbGJhY2sgdG8gbW9ja1xuICAgIHJldHVybiB7XG4gICAgICAgIHJlY2VpcHRJZDogJ21vY2tfcmVjZWlwdF8nICsgRGF0ZS5ub3coKSxcbiAgICAgICAgYmF0Y2hJZDogJ21vY2tfYmF0Y2hfJyArIERhdGUubm93KCksXG4gICAgfTtcbn1cbi8vIE5ldyBmdW5jdGlvbiB0byBjaGVjayBFVk0gdHJhbnNhY3Rpb24gc3RhdHVzXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0RVZNVHJhbnNhY3Rpb25TdGF0dXMoY2hhaW5JZCwgdHhIYXNoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY2FsbElDUENhbmlzdGVyKCdldm1fcnBjJywgJ2dldF90cmFuc2FjdGlvbl9yZWNlaXB0JywgW2NoYWluSWQsIHR4SGFzaF0pO1xuICAgICAgICBpZiAocmVzdWx0ICYmIHJlc3VsdC5Paykge1xuICAgICAgICAgICAgY29uc3QgcmVjZWlwdCA9IHJlc3VsdC5PaztcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgY29uZmlybWVkOiByZWNlaXB0LnN0YXR1cyxcbiAgICAgICAgICAgICAgICBibG9ja051bWJlcjogcmVjZWlwdC5ibG9ja19udW1iZXIsXG4gICAgICAgICAgICAgICAgZ2FzVXNlZDogcmVjZWlwdC5nYXNfdXNlZCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIGdldCBFVk0gdHJhbnNhY3Rpb24gc3RhdHVzOicsIGVycm9yKTtcbiAgICB9XG4gICAgLy8gRmFsbGJhY2sgdG8gbW9ja1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvbmZpcm1lZDogdHJ1ZSxcbiAgICAgICAgYmxvY2tOdW1iZXI6IDE4NTAwMDAwLFxuICAgICAgICBnYXNVc2VkOiAyMTAwMCxcbiAgICB9O1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldE9yZGluYWxQcmVzZW5jZShpcXViZUlkKSB7XG4gICAgLy8gVE9ETzogcXVlcnkgb3JkaW5hbCBhZGFwdGVyXG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLy8gRnVuY3Rpb24gdG8gaW5pdGlhbGl6ZSBFVk0gUlBDIGNhbmlzdGVyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaW5pdGlhbGl6ZUVWTVJQQygpIHtcbiAgICB0cnkge1xuICAgICAgICBhd2FpdCBjYWxsSUNQQ2FuaXN0ZXIoJ2V2bV9ycGMnLCAnaW5pdF9jaGFpbl9jb25maWdzJywgW10pO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gaW5pdGlhbGl6ZSBFVk0gUlBDOicsIGVycm9yKTtcbiAgICB9XG59XG4vLyBGdW5jdGlvbiB0byBnZXQgc3VwcG9ydGVkIGNoYWluc1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFN1cHBvcnRlZENoYWlucygpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBjaGFpbnMgPSBhd2FpdCBjYWxsSUNQQ2FuaXN0ZXIoJ2V2bV9ycGMnLCAnZ2V0X3N1cHBvcnRlZF9jaGFpbnMnLCBbXSk7XG4gICAgICAgIHJldHVybiBjaGFpbnMgfHwgW107XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBnZXQgc3VwcG9ydGVkIGNoYWluczonLCBlcnJvcik7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG59XG4iXSwibmFtZXMiOlsiSHR0cEFnZW50IiwiQWN0b3IiLCJDQU5JU1RFUl9DT05GSUciLCJwcm9vZl9vZl9zdGF0ZSIsImNhbmlzdGVySWQiLCJob3N0IiwiYnRjX3NpZ25lcl9wc2J0IiwiY3Jvc3NfY2hhaW5fc2VydmljZSIsImV2bV9ycGMiLCJwcm9vZk9mU3RhdGVJREwiLCJJREwiLCJSZWNlaXB0IiwiUmVjb3JkIiwiVGV4dCIsIk5hdDY0IiwiVmVjIiwiTWVya2xlQmF0Y2giLCJPcHQiLCJTZXJ2aWNlIiwiRnVuYyIsImNyb3NzQ2hhaW5TZXJ2aWNlSURMIiwiRFZOTWVzc2FnZSIsImFnZW50IiwicHJvb2ZPZlN0YXRlQWN0b3IiLCJjcm9zc0NoYWluU2VydmljZUFjdG9yIiwiZ2V0QWdlbnQiLCJ2ZXJpZnlRdWVyeVNpZ25hdHVyZXMiLCJmZXRjaFJvb3RLZXkiLCJlcnJvciIsImNvbnNvbGUiLCJ3YXJuIiwiZ2V0UHJvb2ZPZlN0YXRlQWN0b3IiLCJhZ2VudEluc3RhbmNlIiwiY3JlYXRlQWN0b3IiLCJnZXRDcm9zc0NoYWluU2VydmljZUFjdG9yIiwiY2FsbElDUENhbmlzdGVyIiwiY2FuaXN0ZXIiLCJtZXRob2QiLCJhcmdzIiwiYWN0b3IiLCJFcnJvciIsIm1lc3NhZ2UiLCJyb290IiwiY3JlYXRlZF9hdCIsImJ0Y19hbmNob3JfdHhpZCIsImJ0Y19ibG9ja19oZWlnaHQiLCJyZWNlaXB0cyIsImlkIiwidGltZXN0YW1wIiwiZGF0YV9oYXNoIiwibWVya2xlX3Byb29mIiwiZ2V0QW5jaG9yU3RhdHVzIiwiaVF1YmVJZCIsImJhdGNoZXMiLCJsZW5ndGgiLCJsYXRlc3RCYXRjaCIsImJ0Y1R4SGFzaCIsImNvbmZpcm1hdGlvbnMiLCJibG9ja0hlaWdodCIsIk51bWJlciIsImlzQ29uZmlybWVkIiwic2xpY2UiLCJnZXREdWFsTG9ja1N0YXR1cyIsInBlbmRpbmdNZXNzYWdlcyIsImV2bVR4SGFzaCIsImljcFJlY2VpcHRJZCIsImlzTG9ja2VkIiwidW5sb2NrSGVpZ2h0IiwicmVhZHlNZXNzYWdlcyIsImxhdGVzdE1lc3NhZ2UiLCJzdWJtaXRGb3JBbmNob3JpbmciLCJkYXRhIiwibWV0YWRhdGEiLCJyZWNlaXB0SWQiLCJiYXRjaFJvb3QiLCJiYXRjaElkIiwidW5kZWZpbmVkIiwiRGF0ZSIsIm5vdyIsImdldEVWTVRyYW5zYWN0aW9uU3RhdHVzIiwiY2hhaW5JZCIsInR4SGFzaCIsInJlc3VsdCIsIk9rIiwicmVjZWlwdCIsImNvbmZpcm1lZCIsInN0YXR1cyIsImJsb2NrTnVtYmVyIiwiYmxvY2tfbnVtYmVyIiwiZ2FzVXNlZCIsImdhc191c2VkIiwiZ2V0T3JkaW5hbFByZXNlbmNlIiwiaXF1YmVJZCIsImluaXRpYWxpemVFVk1SUEMiLCJnZXRTdXBwb3J0ZWRDaGFpbnMiLCJjaGFpbnMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../packages/sdk-js/dist/index.js\n"));

/***/ })

});