"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/../../packages/sdk-js/dist/index.js":
/*!*******************************************!*\
  !*** ../../packages/sdk-js/dist/index.js ***!
  \*******************************************/
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getAnchorStatus: function() { return /* binding */ getAnchorStatus; },\n/* harmony export */   getDualLockStatus: function() { return /* binding */ getDualLockStatus; },\n/* harmony export */   getEVMTransactionStatus: function() { return /* binding */ getEVMTransactionStatus; },\n/* harmony export */   getOrdinalPresence: function() { return /* binding */ getOrdinalPresence; },\n/* harmony export */   submitForAnchoring: function() { return /* binding */ submitForAnchoring; }\n/* harmony export */ });\n/* harmony import */ var _dfinity_agent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @dfinity/agent */ \"(app-pages-browser)/../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/agent/http/index.js\");\n/* harmony import */ var _dfinity_agent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @dfinity/agent */ \"(app-pages-browser)/../../packages/sdk-js/node_modules/@dfinity/agent/lib/esm/actor.js\");\n// @iqube/sdk-js - SDK for interacting with iQube services\n\nconst CANISTER_CONFIG = {\n    proof_of_state: {\n        canisterId: \"umunu-kh777-77774-qaaca-cai\",\n        host: \"http://127.0.0.1:4943\"\n    },\n    btc_signer_psbt: {\n        canisterId: \"uxrrr-q7777-77774-qaaaq-cai\",\n        host: \"http://127.0.0.1:4943\"\n    },\n    cross_chain_service: {\n        canisterId: \"u6s2n-gx777-77774-qaaba-cai\",\n        host: \"http://127.0.0.1:4943\"\n    },\n    evm_rpc: {\n        canisterId: \"uzt4z-lp777-77774-qaabq-cai\",\n        host: \"http://127.0.0.1:4943\"\n    }\n};\n// Candid interface definitions\nconst proofOfStateIDL = (param)=>{\n    let { IDL } = param;\n    const Receipt = IDL.Record({\n        \"id\": IDL.Text,\n        \"data_hash\": IDL.Text,\n        \"timestamp\": IDL.Nat64,\n        \"merkle_proof\": IDL.Vec(IDL.Text)\n    });\n    const MerkleBatch = IDL.Record({\n        \"root\": IDL.Text,\n        \"receipts\": IDL.Vec(Receipt),\n        \"created_at\": IDL.Nat64,\n        \"btc_anchor_txid\": IDL.Opt(IDL.Text),\n        \"btc_block_height\": IDL.Opt(IDL.Nat64)\n    });\n    return IDL.Service({\n        \"issue_receipt\": IDL.Func([\n            IDL.Text\n        ], [\n            IDL.Text\n        ], []),\n        \"batch\": IDL.Func([], [\n            IDL.Text\n        ], []),\n        \"anchor\": IDL.Func([], [\n            IDL.Text\n        ], []),\n        \"get_receipt\": IDL.Func([\n            IDL.Text\n        ], [\n            IDL.Opt(Receipt)\n        ], [\n            \"query\"\n        ]),\n        \"get_batches\": IDL.Func([], [\n            IDL.Vec(MerkleBatch)\n        ], [\n            \"query\"\n        ]),\n        \"get_pending_count\": IDL.Func([], [\n            IDL.Nat64\n        ], [\n            \"query\"\n        ])\n    });\n};\nconst crossChainServiceIDL = (param)=>{\n    let { IDL } = param;\n    const DVNMessage = IDL.Record({\n        \"id\": IDL.Text,\n        \"source_chain\": IDL.Text,\n        \"destination_chain\": IDL.Text,\n        \"payload\": IDL.Text,\n        \"created_at\": IDL.Nat64\n    });\n    return IDL.Service({\n        \"get_pending_messages\": IDL.Func([], [\n            IDL.Vec(DVNMessage)\n        ], [\n            \"query\"\n        ]),\n        \"get_ready_messages\": IDL.Func([], [\n            IDL.Vec(DVNMessage)\n        ], [\n            \"query\"\n        ])\n    });\n};\n// Create agent and actors for live canister calls\nlet agent = null;\nlet proofOfStateActor = null;\nlet crossChainServiceActor = null;\nasync function getAgent() {\n    if (!agent) {\n        agent = new _dfinity_agent__WEBPACK_IMPORTED_MODULE_0__.HttpAgent({\n            host: \"http://127.0.0.1:4943\",\n            verifyQuerySignatures: false // Disable signature verification for local development\n        });\n        // Fetch root key for local development\n        try {\n            await agent.fetchRootKey();\n        } catch (error) {\n            console.warn(\"Failed to fetch root key, continuing without verification:\", error);\n        }\n    }\n    return agent;\n}\nasync function getProofOfStateActor() {\n    if (!proofOfStateActor) {\n        const agentInstance = await getAgent();\n        proofOfStateActor = _dfinity_agent__WEBPACK_IMPORTED_MODULE_1__.Actor.createActor(proofOfStateIDL, {\n            agent: agentInstance,\n            canisterId: CANISTER_CONFIG.proof_of_state.canisterId\n        });\n    }\n    return proofOfStateActor;\n}\nasync function getCrossChainServiceActor() {\n    if (!crossChainServiceActor) {\n        const agentInstance = await getAgent();\n        crossChainServiceActor = _dfinity_agent__WEBPACK_IMPORTED_MODULE_1__.Actor.createActor(crossChainServiceIDL, {\n            agent: agentInstance,\n            canisterId: CANISTER_CONFIG.cross_chain_service.canisterId\n        });\n    }\n    return crossChainServiceActor;\n}\nasync function callICPCanister(canister, method) {\n    let args = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];\n    try {\n        if (canister === \"proof_of_state\") {\n            const actor = await getProofOfStateActor();\n            return await actor[method](...args);\n        } else if (canister === \"cross_chain_service\") {\n            const actor = await getCrossChainServiceActor();\n            return await actor[method](...args);\n        }\n        // Fallback for other canisters\n        return null;\n    } catch (error) {\n        console.warn(\"ICP canister call failed, falling back to mock data:\", error);\n        return null;\n    }\n}\nasync function getAnchorStatus(iQubeId) {\n    try {\n        // Get latest batch info directly - this is more reliable than individual receipts\n        const batches = await callICPCanister(\"proof_of_state\", \"get_batches\", []);\n        if (batches && batches.length > 0) {\n            const latestBatch = batches[batches.length - 1];\n            if (latestBatch.btc_anchor_txid) {\n                return {\n                    btcTxHash: latestBatch.btc_anchor_txid,\n                    confirmations: 6,\n                    blockHeight: Number(latestBatch.btc_block_height) || 800000,\n                    isConfirmed: true\n                };\n            } else {\n                // Batch exists but no BTC anchor yet\n                return {\n                    btcTxHash: \"pending_anchor_\".concat(latestBatch.root.slice(0, 12)),\n                    confirmations: 0,\n                    blockHeight: 0,\n                    isConfirmed: false\n                };\n            }\n        }\n    } catch (error) {\n        console.warn(\"Failed to get real anchor status, using fallback:\", error);\n    }\n    // Fallback to mock data only if canister call completely fails\n    return {\n        btcTxHash: \"mock_btc_txid_\" + iQubeId.slice(-8),\n        confirmations: 6,\n        blockHeight: 850000,\n        isConfirmed: true\n    };\n}\nasync function getDualLockStatus(iQubeId) {\n    try {\n        // Try to get real dual lock status from cross_chain_service canister\n        const pendingMessages = await callICPCanister(\"cross_chain_service\", \"get_pending_messages\", []);\n        if (pendingMessages && pendingMessages.length > 0) {\n            var _message_id;\n            const message = pendingMessages[0];\n            return {\n                evmTxHash: \"live_evm_tx_\".concat(((_message_id = message.id) === null || _message_id === void 0 ? void 0 : _message_id.slice(-8)) || \"pending\"),\n                icpReceiptId: message.id || \"live_icp_receipt\",\n                isLocked: false,\n                unlockHeight: 851000\n            };\n        }\n        // Also try to get ready messages (messages with enough attestations)\n        const readyMessages = await callICPCanister(\"cross_chain_service\", \"get_ready_messages\", []);\n        if (readyMessages && readyMessages.length > 0) {\n            var _latestMessage_id;\n            const latestMessage = readyMessages[readyMessages.length - 1];\n            return {\n                evmTxHash: \"live_cross_chain_\".concat(((_latestMessage_id = latestMessage.id) === null || _latestMessage_id === void 0 ? void 0 : _latestMessage_id.slice(-8)) || \"ready\"),\n                icpReceiptId: latestMessage.id || \"live_ready_receipt\",\n                isLocked: true,\n                unlockHeight: 851000\n            };\n        }\n        // If no messages, show that cross-chain service is live but empty\n        return {\n            evmTxHash: \"live_no_pending_messages\",\n            icpReceiptId: \"live_cross_chain_empty\",\n            isLocked: false,\n            unlockHeight: 851000\n        };\n    } catch (error) {\n        console.warn(\"Failed to get real dual lock status, using fallback:\", error);\n    }\n    // Fallback to mock data only if canister call completely fails\n    return {\n        evmTxHash: \"mock_evm_tx_hash_\" + iQubeId.slice(-8),\n        icpReceiptId: \"mock_icp_receipt_\" + iQubeId.slice(-8),\n        isLocked: true,\n        unlockHeight: 851000\n    };\n}\n// New function to submit data for anchoring\nasync function submitForAnchoring(data, metadata) {\n    try {\n        // Use the correct method name from our canister\n        const receiptId = await callICPCanister(\"proof_of_state\", \"issue_receipt\", [\n            data\n        ]);\n        if (receiptId) {\n            // Also trigger batching and anchoring\n            const batchRoot = await callICPCanister(\"proof_of_state\", \"batch\", []);\n            if (batchRoot) {\n                // Trigger anchoring\n                await callICPCanister(\"proof_of_state\", \"anchor\", []);\n            }\n            return {\n                receiptId: receiptId,\n                batchId: batchRoot || undefined\n            };\n        }\n    } catch (error) {\n        console.warn(\"Failed to submit for anchoring:\", error);\n    }\n    // Fallback to mock\n    return {\n        receiptId: \"mock_receipt_\" + Date.now(),\n        batchId: \"mock_batch_\" + Date.now()\n    };\n}\n// New function to check EVM transaction status\nasync function getEVMTransactionStatus(chainId, txHash) {\n    try {\n        const result = await callICPCanister(\"evm_rpc\", \"get_transaction_receipt\", [\n            chainId,\n            txHash\n        ]);\n        if (result && result.Ok) {\n            const receipt = result.Ok;\n            return {\n                confirmed: receipt.status,\n                blockNumber: receipt.block_number,\n                gasUsed: receipt.gas_used\n            };\n        }\n    } catch (error) {\n        console.warn(\"Failed to get EVM transaction status:\", error);\n    }\n    // Fallback to mock\n    return {\n        confirmed: true,\n        blockNumber: 18500000,\n        gasUsed: 21000\n    };\n}\nasync function getOrdinalPresence(iqubeId) {\n    // TODO: query ordinal adapter\n    return false;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = __webpack_module__.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = __webpack_module__.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, __webpack_module__.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                __webpack_module__.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                __webpack_module__.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        __webpack_module__.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    __webpack_module__.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9wYWNrYWdlcy9zZGstanMvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUEsMERBQTBEO0FBQ1I7QUFDbEQsTUFBTUUsa0JBQWtCO0lBQ3BCQyxnQkFBZ0I7UUFDWkMsWUFBWTtRQUNaQyxNQUFNO0lBQ1Y7SUFDQUMsaUJBQWlCO1FBQ2JGLFlBQVk7UUFDWkMsTUFBTTtJQUNWO0lBQ0FFLHFCQUFxQjtRQUNqQkgsWUFBWTtRQUNaQyxNQUFNO0lBQ1Y7SUFDQUcsU0FBUztRQUNMSixZQUFZO1FBQ1pDLE1BQU07SUFDVjtBQUNKO0FBQ0EsK0JBQStCO0FBQy9CLE1BQU1JLGtCQUFrQjtRQUFDLEVBQUVDLEdBQUcsRUFBRTtJQUM1QixNQUFNQyxVQUFVRCxJQUFJRSxNQUFNLENBQUM7UUFDdkIsTUFBTUYsSUFBSUcsSUFBSTtRQUNkLGFBQWFILElBQUlHLElBQUk7UUFDckIsYUFBYUgsSUFBSUksS0FBSztRQUN0QixnQkFBZ0JKLElBQUlLLEdBQUcsQ0FBQ0wsSUFBSUcsSUFBSTtJQUNwQztJQUNBLE1BQU1HLGNBQWNOLElBQUlFLE1BQU0sQ0FBQztRQUMzQixRQUFRRixJQUFJRyxJQUFJO1FBQ2hCLFlBQVlILElBQUlLLEdBQUcsQ0FBQ0o7UUFDcEIsY0FBY0QsSUFBSUksS0FBSztRQUN2QixtQkFBbUJKLElBQUlPLEdBQUcsQ0FBQ1AsSUFBSUcsSUFBSTtRQUNuQyxvQkFBb0JILElBQUlPLEdBQUcsQ0FBQ1AsSUFBSUksS0FBSztJQUN6QztJQUNBLE9BQU9KLElBQUlRLE9BQU8sQ0FBQztRQUNmLGlCQUFpQlIsSUFBSVMsSUFBSSxDQUFDO1lBQUNULElBQUlHLElBQUk7U0FBQyxFQUFFO1lBQUNILElBQUlHLElBQUk7U0FBQyxFQUFFLEVBQUU7UUFDcEQsU0FBU0gsSUFBSVMsSUFBSSxDQUFDLEVBQUUsRUFBRTtZQUFDVCxJQUFJRyxJQUFJO1NBQUMsRUFBRSxFQUFFO1FBQ3BDLFVBQVVILElB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O1lBQ3hEO1lBQ0EsT0FBTztnQkFDSGdDLFdBQVdBO2dCQUNYRSxTQUFTRCxhQUFhRTtZQUMxQjtRQUNKO0lBQ0osRUFDQSxPQUFPMUMsT0FBTztRQUNWQyxRQUFRQyxJQUFJLENBQUMsbUNBQW1DRjtJQUNwRDtJQUNBLG1CQUFtQjtJQUNuQixPQUFPO1FBQ0h1QyxXQUFXLGtCQUFrQkksS0FBS0MsR0FBRztRQUNyQ0gsU0FBUyxnQkFBZ0JFLEtBQUtDLEdBQUc7SUFDckM7QUFDSjtBQUNBLCtDQUErQztBQUN4QyxlQUFlQyx3QkFBd0JDLE9BQU8sRUFBRUMsTUFBTTtJQUN6RCxJQUFJO1FBQ0EsTUFBTUMsU0FBUyxNQUFNekMsZ0JBQWdCLFdBQVcsMkJBQTJCO1lBQUN1QztZQUFTQztTQUFPO1FBQzVGLElBQUlDLFVBQVVBLE9BQU9DLEVBQUUsRUFBRTtZQUNyQixNQUFNQyxVQUFVRixPQUFPQyxFQUFFO1lBQ3pCLE9BQU87Z0JBQ0hFLFdBQVdELFFBQVFFLE1BQU07Z0JBQ3pCQyxhQUFhSCxRQUFRSSxZQUFZO2dCQUNqQ0MsU0FBU0wsUUFBUU0sUUFBUTtZQUM3QjtRQUNKO0lBQ0osRUFDQSxPQUFPeEQsT0FBTztRQUNWQyxRQUFRQyxJQUFJLENBQUMseUNBQXlDRjtJQUMxRDtJQUNBLG1CQUFtQjtJQUNuQixPQUFPO1FBQ0htRCxXQUFXO1FBQ1hFLGFBQWE7UUFDYkUsU0FBUztJQUNiO0FBQ0o7QUFDTyxlQUFlRSxtQkFBbUJDLE9BQU87SUFDNUMsOEJBQThCO0lBQzlCLE9BQU87QUFDWCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vcGFja2FnZXMvc2RrLWpzL2Rpc3QvaW5kZXguanM/N2NiMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBAaXF1YmUvc2RrLWpzIC0gU0RLIGZvciBpbnRlcmFjdGluZyB3aXRoIGlRdWJlIHNlcnZpY2VzXG5pbXBvcnQgeyBIdHRwQWdlbnQsIEFjdG9yIH0gZnJvbSAnQGRmaW5pdHkvYWdlbnQnO1xuY29uc3QgQ0FOSVNURVJfQ09ORklHID0ge1xuICAgIHByb29mX29mX3N0YXRlOiB7XG4gICAgICAgIGNhbmlzdGVySWQ6ICd1bXVudS1raDc3Ny03Nzc3NC1xYWFjYS1jYWknLFxuICAgICAgICBob3N0OiAnaHR0cDovLzEyNy4wLjAuMTo0OTQzJyxcbiAgICB9LFxuICAgIGJ0Y19zaWduZXJfcHNidDoge1xuICAgICAgICBjYW5pc3RlcklkOiAndXhycnItcTc3NzctNzc3NzQtcWFhYXEtY2FpJyxcbiAgICAgICAgaG9zdDogJ2h0dHA6Ly8xMjcuMC4wLjE6NDk0MycsXG4gICAgfSxcbiAgICBjcm9zc19jaGFpbl9zZXJ2aWNlOiB7XG4gICAgICAgIGNhbmlzdGVySWQ6ICd1NnMybi1neDc3Ny03Nzc3NC1xYWFiYS1jYWknLFxuICAgICAgICBob3N0OiAnaHR0cDovLzEyNy4wLjAuMTo0OTQzJyxcbiAgICB9LFxuICAgIGV2bV9ycGM6IHtcbiAgICAgICAgY2FuaXN0ZXJJZDogJ3V6dDR6LWxwNzc3LTc3Nzc0LXFhYWJxLWNhaScsXG4gICAgICAgIGhvc3Q6ICdodHRwOi8vMTI3LjAuMC4xOjQ5NDMnLFxuICAgIH0sXG59O1xuLy8gQ2FuZGlkIGludGVyZmFjZSBkZWZpbml0aW9uc1xuY29uc3QgcHJvb2ZPZlN0YXRlSURMID0gKHsgSURMIH0pID0+IHtcbiAgICBjb25zdCBSZWNlaXB0ID0gSURMLlJlY29yZCh7XG4gICAgICAgICdpZCc6IElETC5UZXh0LFxuICAgICAgICAnZGF0YV9oYXNoJzogSURMLlRleHQsXG4gICAgICAgICd0aW1lc3RhbXAnOiBJREwuTmF0NjQsXG4gICAgICAgICdtZXJrbGVfcHJvb2YnOiBJREwuVmVjKElETC5UZXh0KSxcbiAgICB9KTtcbiAgICBjb25zdCBNZXJrbGVCYXRjaCA9IElETC5SZWNvcmQoe1xuICAgICAgICAncm9vdCc6IElETC5UZXh0LFxuICAgICAgICAncmVjZWlwdHMnOiBJREwuVmVjKFJlY2VpcHQpLFxuICAgICAgICAnY3JlYXRlZF9hdCc6IElETC5OYXQ2NCxcbiAgICAgICAgJ2J0Y19hbmNob3JfdHhpZCc6IElETC5PcHQoSURMLlRleHQpLFxuICAgICAgICAnYnRjX2Jsb2NrX2hlaWdodCc6IElETC5PcHQoSURMLk5hdDY0KSxcbiAgICB9KTtcbiAgICByZXR1cm4gSURMLlNlcnZpY2Uoe1xuICAgICAgICAnaXNzdWVfcmVjZWlwdCc6IElETC5GdW5jKFtJREwuVGV4dF0sIFtJREwuVGV4dF0sIFtdKSxcbiAgICAgICAgJ2JhdGNoJzogSURMLkZ1bmMoW10sIFtJREwuVGV4dF0sIFtdKSxcbiAgICAgICAgJ2FuY2hvcic6IElETC5GdW5jKFtdLCBbSURMLlRleHRdLCBbXSksXG4gICAgICAgICdnZXRfcmVjZWlwdCc6IElETC5GdW5jKFtJREwuVGV4dF0sIFtJREwuT3B0KFJlY2VpcHQpXSwgWydxdWVyeSddKSxcbiAgICAgICAgJ2dldF9iYXRjaGVzJzogSURMLkZ1bmMoW10sIFtJREwuVmVjKE1lcmtsZUJhdGNoKV0sIFsncXVlcnknXSksXG4gICAgICAgICdnZXRfcGVuZGluZ19jb3VudCc6IElETC5GdW5jKFtdLCBbSURMLk5hdDY0XSwgWydxdWVyeSddKSxcbiAgICB9KTtcbn07XG5jb25zdCBjcm9zc0NoYWluU2VydmljZUlETCA9ICh7IElETCB9KSA9PiB7XG4gICAgY29uc3QgRFZOTWVzc2FnZSA9IElETC5SZWNvcmQoe1xuICAgICAgICAnaWQnOiBJREwuVGV4dCxcbiAgICAgICAgJ3NvdXJjZV9jaGFpbic6IElETC5UZXh0LFxuICAgICAgICAnZGVzdGluYXRpb25fY2hhaW4nOiBJREwuVGV4dCxcbiAgICAgICAgJ3BheWxvYWQnOiBJREwuVGV4dCxcbiAgICAgICAgJ2NyZWF0ZWRfYXQnOiBJREwuTmF0NjQsXG4gICAgfSk7XG4gICAgcmV0dXJuIElETC5TZXJ2aWNlKHtcbiAgICAgICAgJ2dldF9wZW5kaW5nX21lc3NhZ2VzJzogSURMLkZ1bmMoW10sIFtJREwuVmVjKERWTk1lc3NhZ2UpXSwgWydxdWVyeSddKSxcbiAgICAgICAgJ2dldF9yZWFkeV9tZXNzYWdlcyc6IElETC5GdW5jKFtdLCBbSURMLlZlYyhEVk5NZXNzYWdlKV0sIFsncXVlcnknXSksXG4gICAgfSk7XG59O1xuLy8gQ3JlYXRlIGFnZW50IGFuZCBhY3RvcnMgZm9yIGxpdmUgY2FuaXN0ZXIgY2FsbHNcbmxldCBhZ2VudCA9IG51bGw7XG5sZXQgcHJvb2ZPZlN0YXRlQWN0b3IgPSBudWxsO1xubGV0IGNyb3NzQ2hhaW5TZXJ2aWNlQWN0b3IgPSBudWxsO1xuYXN5bmMgZnVuY3Rpb24gZ2V0QWdlbnQoKSB7XG4gICAgaWYgKCFhZ2VudCkge1xuICAgICAgICBhZ2VudCA9IG5ldyBIdHRwQWdlbnQoe1xuICAgICAgICAgICAgaG9zdDogJ2h0dHA6Ly8xMjcuMC4wLjE6NDk0MycsXG4gICAgICAgICAgICB2ZXJpZnlRdWVyeVNpZ25hdHVyZXM6IGZhbHNlIC8vIERpc2FibGUgc2lnbmF0dXJlIHZlcmlmaWNhdGlvbiBmb3IgbG9jYWwgZGV2ZWxvcG1lbnRcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEZldGNoIHJvb3Qga2V5IGZvciBsb2NhbCBkZXZlbG9wbWVudFxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgYWdlbnQuZmV0Y2hSb290S2V5KCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBmZXRjaCByb290IGtleSwgY29udGludWluZyB3aXRob3V0IHZlcmlmaWNhdGlvbjonLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFnZW50O1xufVxuYXN5bmMgZnVuY3Rpb24gZ2V0UHJvb2ZPZlN0YXRlQWN0b3IoKSB7XG4gICAgaWYgKCFwcm9vZk9mU3RhdGVBY3Rvcikge1xuICAgICAgICBjb25zdCBhZ2VudEluc3RhbmNlID0gYXdhaXQgZ2V0QWdlbnQoKTtcbiAgICAgICAgcHJvb2ZPZlN0YXRlQWN0b3IgPSBBY3Rvci5jcmVhdGVBY3Rvcihwcm9vZk9mU3RhdGVJREwsIHtcbiAgICAgICAgICAgIGFnZW50OiBhZ2VudEluc3RhbmNlLFxuICAgICAgICAgICAgY2FuaXN0ZXJJZDogQ0FOSVNURVJfQ09ORklHLnByb29mX29mX3N0YXRlLmNhbmlzdGVySWQsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcHJvb2ZPZlN0YXRlQWN0b3I7XG59XG5hc3luYyBmdW5jdGlvbiBnZXRDcm9zc0NoYWluU2VydmljZUFjdG9yKCkge1xuICAgIGlmICghY3Jvc3NDaGFpblNlcnZpY2VBY3Rvcikge1xuICAgICAgICBjb25zdCBhZ2VudEluc3RhbmNlID0gYXdhaXQgZ2V0QWdlbnQoKTtcbiAgICAgICAgY3Jvc3NDaGFpblNlcnZpY2VBY3RvciA9IEFjdG9yLmNyZWF0ZUFjdG9yKGNyb3NzQ2hhaW5TZXJ2aWNlSURMLCB7XG4gICAgICAgICAgICBhZ2VudDogYWdlbnRJbnN0YW5jZSxcbiAgICAgICAgICAgIGNhbmlzdGVySWQ6IENBTklTVEVSX0NPTkZJRy5jcm9zc19jaGFpbl9zZXJ2aWNlLmNhbmlzdGVySWQsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gY3Jvc3NDaGFpblNlcnZpY2VBY3Rvcjtcbn1cbmFzeW5jIGZ1bmN0aW9uIGNhbGxJQ1BDYW5pc3RlcihjYW5pc3RlciwgbWV0aG9kLCBhcmdzID0gW10pIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAoY2FuaXN0ZXIgPT09ICdwcm9vZl9vZl9zdGF0ZScpIHtcbiAgICAgICAgICAgIGNvbnN0IGFjdG9yID0gYXdhaXQgZ2V0UHJvb2ZPZlN0YXRlQWN0b3IoKTtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBhY3RvclttZXRob2RdKC4uLmFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNhbmlzdGVyID09PSAnY3Jvc3NfY2hhaW5fc2VydmljZScpIHtcbiAgICAgICAgICAgIGNvbnN0IGFjdG9yID0gYXdhaXQgZ2V0Q3Jvc3NDaGFpblNlcnZpY2VBY3RvcigpO1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGFjdG9yW21ldGhvZF0oLi4uYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmFsbGJhY2sgZm9yIG90aGVyIGNhbmlzdGVyc1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgSUNQIGNhbmlzdGVyIGNhbGwgZmFpbGVkLCBmYWxsaW5nIGJhY2sgdG8gbW9jayBkYXRhOmAsIGVycm9yKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEFuY2hvclN0YXR1cyhpUXViZUlkKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gR2V0IGxhdGVzdCBiYXRjaCBpbmZvIGRpcmVjdGx5IC0gdGhpcyBpcyBtb3JlIHJlbGlhYmxlIHRoYW4gaW5kaXZpZHVhbCByZWNlaXB0c1xuICAgICAgICBjb25zdCBiYXRjaGVzID0gYXdhaXQgY2FsbElDUENhbmlzdGVyKCdwcm9vZl9vZl9zdGF0ZScsICdnZXRfYmF0Y2hlcycsIFtdKTtcbiAgICAgICAgaWYgKGJhdGNoZXMgJiYgYmF0Y2hlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBsYXRlc3RCYXRjaCA9IGJhdGNoZXNbYmF0Y2hlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGlmIChsYXRlc3RCYXRjaC5idGNfYW5jaG9yX3R4aWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBidGNUeEhhc2g6IGxhdGVzdEJhdGNoLmJ0Y19hbmNob3JfdHhpZCxcbiAgICAgICAgICAgICAgICAgICAgY29uZmlybWF0aW9uczogNixcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tIZWlnaHQ6IE51bWJlcihsYXRlc3RCYXRjaC5idGNfYmxvY2tfaGVpZ2h0KSB8fCA4MDAwMDAsXG4gICAgICAgICAgICAgICAgICAgIGlzQ29uZmlybWVkOiB0cnVlLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBCYXRjaCBleGlzdHMgYnV0IG5vIEJUQyBhbmNob3IgeWV0XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgYnRjVHhIYXNoOiBgcGVuZGluZ19hbmNob3JfJHtsYXRlc3RCYXRjaC5yb290LnNsaWNlKDAsIDEyKX1gLFxuICAgICAgICAgICAgICAgICAgICBjb25maXJtYXRpb25zOiAwLFxuICAgICAgICAgICAgICAgICAgICBibG9ja0hlaWdodDogMCxcbiAgICAgICAgICAgICAgICAgICAgaXNDb25maXJtZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIGdldCByZWFsIGFuY2hvciBzdGF0dXMsIHVzaW5nIGZhbGxiYWNrOicsIGVycm9yKTtcbiAgICB9XG4gICAgLy8gRmFsbGJhY2sgdG8gbW9jayBkYXRhIG9ubHkgaWYgY2FuaXN0ZXIgY2FsbCBjb21wbGV0ZWx5IGZhaWxzXG4gICAgcmV0dXJuIHtcbiAgICAgICAgYnRjVHhIYXNoOiAnbW9ja19idGNfdHhpZF8nICsgaVF1YmVJZC5zbGljZSgtOCksXG4gICAgICAgIGNvbmZpcm1hdGlvbnM6IDYsXG4gICAgICAgIGJsb2NrSGVpZ2h0OiA4NTAwMDAsXG4gICAgICAgIGlzQ29uZmlybWVkOiB0cnVlLFxuICAgIH07XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0RHVhbExvY2tTdGF0dXMoaVF1YmVJZCkge1xuICAgIHRyeSB7XG4gICAgICAgIC8vIFRyeSB0byBnZXQgcmVhbCBkdWFsIGxvY2sgc3RhdHVzIGZyb20gY3Jvc3NfY2hhaW5fc2VydmljZSBjYW5pc3RlclxuICAgICAgICBjb25zdCBwZW5kaW5nTWVzc2FnZXMgPSBhd2FpdCBjYWxsSUNQQ2FuaXN0ZXIoJ2Nyb3NzX2NoYWluX3NlcnZpY2UnLCAnZ2V0X3BlbmRpbmdfbWVzc2FnZXMnLCBbXSk7XG4gICAgICAgIGlmIChwZW5kaW5nTWVzc2FnZXMgJiYgcGVuZGluZ01lc3NhZ2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBwZW5kaW5nTWVzc2FnZXNbMF07XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGV2bVR4SGFzaDogYGxpdmVfZXZtX3R4XyR7bWVzc2FnZS5pZD8uc2xpY2UoLTgpIHx8ICdwZW5kaW5nJ31gLFxuICAgICAgICAgICAgICAgIGljcFJlY2VpcHRJZDogbWVzc2FnZS5pZCB8fCAnbGl2ZV9pY3BfcmVjZWlwdCcsXG4gICAgICAgICAgICAgICAgaXNMb2NrZWQ6IGZhbHNlLCAvLyBTdGlsbCBwZW5kaW5nXG4gICAgICAgICAgICAgICAgdW5sb2NrSGVpZ2h0OiA4NTEwMDAsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIC8vIEFsc28gdHJ5IHRvIGdldCByZWFkeSBtZXNzYWdlcyAobWVzc2FnZXMgd2l0aCBlbm91Z2ggYXR0ZXN0YXRpb25zKVxuICAgICAgICBjb25zdCByZWFkeU1lc3NhZ2VzID0gYXdhaXQgY2FsbElDUENhbmlzdGVyKCdjcm9zc19jaGFpbl9zZXJ2aWNlJywgJ2dldF9yZWFkeV9tZXNzYWdlcycsIFtdKTtcbiAgICAgICAgaWYgKHJlYWR5TWVzc2FnZXMgJiYgcmVhZHlNZXNzYWdlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBsYXRlc3RNZXNzYWdlID0gcmVhZHlNZXNzYWdlc1tyZWFkeU1lc3NhZ2VzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBldm1UeEhhc2g6IGBsaXZlX2Nyb3NzX2NoYWluXyR7bGF0ZXN0TWVzc2FnZS5pZD8uc2xpY2UoLTgpIHx8ICdyZWFkeSd9YCxcbiAgICAgICAgICAgICAgICBpY3BSZWNlaXB0SWQ6IGxhdGVzdE1lc3NhZ2UuaWQgfHwgJ2xpdmVfcmVhZHlfcmVjZWlwdCcsXG4gICAgICAgICAgICAgICAgaXNMb2NrZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgdW5sb2NrSGVpZ2h0OiA4NTEwMDAsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIG5vIG1lc3NhZ2VzLCBzaG93IHRoYXQgY3Jvc3MtY2hhaW4gc2VydmljZSBpcyBsaXZlIGJ1dCBlbXB0eVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZXZtVHhIYXNoOiAnbGl2ZV9ub19wZW5kaW5nX21lc3NhZ2VzJyxcbiAgICAgICAgICAgIGljcFJlY2VpcHRJZDogJ2xpdmVfY3Jvc3NfY2hhaW5fZW1wdHknLFxuICAgICAgICAgICAgaXNMb2NrZWQ6IGZhbHNlLFxuICAgICAgICAgICAgdW5sb2NrSGVpZ2h0OiA4NTEwMDAsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBnZXQgcmVhbCBkdWFsIGxvY2sgc3RhdHVzLCB1c2luZyBmYWxsYmFjazonLCBlcnJvcik7XG4gICAgfVxuICAgIC8vIEZhbGxiYWNrIHRvIG1vY2sgZGF0YSBvbmx5IGlmIGNhbmlzdGVyIGNhbGwgY29tcGxldGVseSBmYWlsc1xuICAgIHJldHVybiB7XG4gICAgICAgIGV2bVR4SGFzaDogJ21vY2tfZXZtX3R4X2hhc2hfJyArIGlRdWJlSWQuc2xpY2UoLTgpLFxuICAgICAgICBpY3BSZWNlaXB0SWQ6ICdtb2NrX2ljcF9yZWNlaXB0XycgKyBpUXViZUlkLnNsaWNlKC04KSxcbiAgICAgICAgaXNMb2NrZWQ6IHRydWUsXG4gICAgICAgIHVubG9ja0hlaWdodDogODUxMDAwLFxuICAgIH07XG59XG4vLyBOZXcgZnVuY3Rpb24gdG8gc3VibWl0IGRhdGEgZm9yIGFuY2hvcmluZ1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHN1Ym1pdEZvckFuY2hvcmluZyhkYXRhLCBtZXRhZGF0YSkge1xuICAgIHRyeSB7XG4gICAgICAgIC8vIFVzZSB0aGUgY29ycmVjdCBtZXRob2QgbmFtZSBmcm9tIG91ciBjYW5pc3RlclxuICAgICAgICBjb25zdCByZWNlaXB0SWQgPSBhd2FpdCBjYWxsSUNQQ2FuaXN0ZXIoJ3Byb29mX29mX3N0YXRlJywgJ2lzc3VlX3JlY2VpcHQnLCBbZGF0YV0pO1xuICAgICAgICBpZiAocmVjZWlwdElkKSB7XG4gICAgICAgICAgICAvLyBBbHNvIHRyaWdnZXIgYmF0Y2hpbmcgYW5kIGFuY2hvcmluZ1xuICAgICAgICAgICAgY29uc3QgYmF0Y2hSb290ID0gYXdhaXQgY2FsbElDUENhbmlzdGVyKCdwcm9vZl9vZl9zdGF0ZScsICdiYXRjaCcsIFtdKTtcbiAgICAgICAgICAgIGlmIChiYXRjaFJvb3QpIHtcbiAgICAgICAgICAgICAgICAvLyBUcmlnZ2VyIGFuY2hvcmluZ1xuICAgICAgICAgICAgICAgIGF3YWl0IGNhbGxJQ1BDYW5pc3RlcigncHJvb2Zfb2Zfc3RhdGUnLCAnYW5jaG9yJywgW10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICByZWNlaXB0SWQ6IHJlY2VpcHRJZCxcbiAgICAgICAgICAgICAgICBiYXRjaElkOiBiYXRjaFJvb3QgfHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gc3VibWl0IGZvciBhbmNob3Jpbmc6JywgZXJyb3IpO1xuICAgIH1cbiAgICAvLyBGYWxsYmFjayB0byBtb2NrXG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmVjZWlwdElkOiAnbW9ja19yZWNlaXB0XycgKyBEYXRlLm5vdygpLFxuICAgICAgICBiYXRjaElkOiAnbW9ja19iYXRjaF8nICsgRGF0ZS5ub3coKSxcbiAgICB9O1xufVxuLy8gTmV3IGZ1bmN0aW9uIHRvIGNoZWNrIEVWTSB0cmFuc2FjdGlvbiBzdGF0dXNcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRFVk1UcmFuc2FjdGlvblN0YXR1cyhjaGFpbklkLCB0eEhhc2gpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjYWxsSUNQQ2FuaXN0ZXIoJ2V2bV9ycGMnLCAnZ2V0X3RyYW5zYWN0aW9uX3JlY2VpcHQnLCBbY2hhaW5JZCwgdHhIYXNoXSk7XG4gICAgICAgIGlmIChyZXN1bHQgJiYgcmVzdWx0Lk9rKSB7XG4gICAgICAgICAgICBjb25zdCByZWNlaXB0ID0gcmVzdWx0Lk9rO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjb25maXJtZWQ6IHJlY2VpcHQuc3RhdHVzLFxuICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyOiByZWNlaXB0LmJsb2NrX251bWJlcixcbiAgICAgICAgICAgICAgICBnYXNVc2VkOiByZWNlaXB0Lmdhc191c2VkLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gZ2V0IEVWTSB0cmFuc2FjdGlvbiBzdGF0dXM6JywgZXJyb3IpO1xuICAgIH1cbiAgICAvLyBGYWxsYmFjayB0byBtb2NrXG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29uZmlybWVkOiB0cnVlLFxuICAgICAgICBibG9ja051bWJlcjogMTg1MDAwMDAsXG4gICAgICAgIGdhc1VzZWQ6IDIxMDAwLFxuICAgIH07XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0T3JkaW5hbFByZXNlbmNlKGlxdWJlSWQpIHtcbiAgICAvLyBUT0RPOiBxdWVyeSBvcmRpbmFsIGFkYXB0ZXJcbiAgICByZXR1cm4gZmFsc2U7XG59XG4iXSwibmFtZXMiOlsiSHR0cEFnZW50IiwiQWN0b3IiLCJDQU5JU1RFUl9DT05GSUciLCJwcm9vZl9vZl9zdGF0ZSIsImNhbmlzdGVySWQiLCJob3N0IiwiYnRjX3NpZ25lcl9wc2J0IiwiY3Jvc3NfY2hhaW5fc2VydmljZSIsImV2bV9ycGMiLCJwcm9vZk9mU3RhdGVJREwiLCJJREwiLCJSZWNlaXB0IiwiUmVjb3JkIiwiVGV4dCIsIk5hdDY0IiwiVmVjIiwiTWVya2xlQmF0Y2giLCJPcHQiLCJTZXJ2aWNlIiwiRnVuYyIsImNyb3NzQ2hhaW5TZXJ2aWNlSURMIiwiRFZOTWVzc2FnZSIsImFnZW50IiwicHJvb2ZPZlN0YXRlQWN0b3IiLCJjcm9zc0NoYWluU2VydmljZUFjdG9yIiwiZ2V0QWdlbnQiLCJ2ZXJpZnlRdWVyeVNpZ25hdHVyZXMiLCJmZXRjaFJvb3RLZXkiLCJlcnJvciIsImNvbnNvbGUiLCJ3YXJuIiwiZ2V0UHJvb2ZPZlN0YXRlQWN0b3IiLCJhZ2VudEluc3RhbmNlIiwiY3JlYXRlQWN0b3IiLCJnZXRDcm9zc0NoYWluU2VydmljZUFjdG9yIiwiY2FsbElDUENhbmlzdGVyIiwiY2FuaXN0ZXIiLCJtZXRob2QiLCJhcmdzIiwiYWN0b3IiLCJnZXRBbmNob3JTdGF0dXMiLCJpUXViZUlkIiwiYmF0Y2hlcyIsImxlbmd0aCIsImxhdGVzdEJhdGNoIiwiYnRjX2FuY2hvcl90eGlkIiwiYnRjVHhIYXNoIiwiY29uZmlybWF0aW9ucyIsImJsb2NrSGVpZ2h0IiwiTnVtYmVyIiwiYnRjX2Jsb2NrX2hlaWdodCIsImlzQ29uZmlybWVkIiwicm9vdCIsInNsaWNlIiwiZ2V0RHVhbExvY2tTdGF0dXMiLCJwZW5kaW5nTWVzc2FnZXMiLCJtZXNzYWdlIiwiZXZtVHhIYXNoIiwiaWQiLCJpY3BSZWNlaXB0SWQiLCJpc0xvY2tlZCIsInVubG9ja0hlaWdodCIsInJlYWR5TWVzc2FnZXMiLCJsYXRlc3RNZXNzYWdlIiwic3VibWl0Rm9yQW5jaG9yaW5nIiwiZGF0YSIsIm1ldGFkYXRhIiwicmVjZWlwdElkIiwiYmF0Y2hSb290IiwiYmF0Y2hJZCIsInVuZGVmaW5lZCIsIkRhdGUiLCJub3ciLCJnZXRFVk1UcmFuc2FjdGlvblN0YXR1cyIsImNoYWluSWQiLCJ0eEhhc2giLCJyZXN1bHQiLCJPayIsInJlY2VpcHQiLCJjb25maXJtZWQiLCJzdGF0dXMiLCJibG9ja051bWJlciIsImJsb2NrX251bWJlciIsImdhc1VzZWQiLCJnYXNfdXNlZCIsImdldE9yZGluYWxQcmVzZW5jZSIsImlxdWJlSWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../packages/sdk-js/dist/index.js\n"));

/***/ })

});